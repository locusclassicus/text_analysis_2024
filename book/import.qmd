# Импорт: JSON & XML

Ранее мы научились импортировать табличные данные с расширениями .csv и .tsv. Подробнее об импорте таблиц, текстов и изображений можно посмотреть [предыдущую версию](https://locusclassicus.github.io/text_analysis_2023/%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82-%D0%B8-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.html) курса. В этом уроке речь пойдет о работе со структурированными данными. 

## JSON

Формат JSON (JavaScript Object Notation) предназначен для представления структурированных данных. JSON имеет шесть основных [типов данных](https://r4ds.hadley.nz/rectangling#json). Четыре из них - скаляры:

-   cамый простой тип - `null`, который играет ту же роль, что и `NA` в R. Он представляет собой отсутствие данных;
-   cтрока (string) похожа на строку в R, но в ней всегда должны использоваться двойные кавычки;
-   число аналогично числам в R, при этом поддерживается целочисленная (например, 123), десятичная (например, 123.45) или научная (например, 1,23e3) нотация. JSON не поддерживает `Inf`, `-Inf` или `NaN`;
-   логическое значение аналогично `TRUE` и `FALSE` в R, но использует строчные буквы `true` и `false`.

Строки, числа и булевы значения в JSON очень похожи на символьные, числовые и логические векторы в R. Основное отличие заключается в том, что скаляры JSON могут представлять только одно значение. Для представления нескольких значений необходимо использовать один из двух оставшихся типов: массивы и объекты.

И массивы, и объекты похожи на списки в R, разница заключается в том, именованы они или нет. _Массив_ подобен безымянному списку и записывается через `[]`. Например, `[1, 2, 3]` - это массив, содержащий 3 числа, а `[null, 1, "string", false]` - массив, содержащий ноль, число, строку и булево значение. 

_Объект_ подобен именованному списку и записывается через `{}`. Имена (ключи в терминологии JSON) являются строками, поэтому должны быть заключены в кавычки. Например, {"x": 1, "y": 2} - это объект, который сопоставляет x с 1, а y -- с 2.

### Пакет `jsonlite`

Загрузим небольшой файл `TBBT.json`, хранящий данные о сериале "Теория большого взрыва" ([источник](https://gist.github.com/sahithyandev/540c82170a19f97deef9e23796083f01)). Скачать лучше из репозитория курса [ссылка](https://github.com/locusclassicus/text_analysis_2024/raw/main/files/TBBT.json). 

```{r message=FALSE}
library(jsonlite)

path <- "../files/TBBT.json"
tbbt <- read_json(path)
```

Функция `read_json()` вернула нам список со следующими элементами:

```{r}
summary(tbbt)
```
### От списка к таблице

Выборочно преобразуем список в тиббл. Функция `transpose()` берет _список списков_ и выворачивает его наизнанку: вместо списка, в котором для каждого из персонажей  указан актер и первое появление, мы получаем три списка: с персонажами, актерами и эпизодами. На месте отсутствующих значений ставится NULL.

```{r message=FALSE}
library(tidyverse)

cast_tbl <- tbbt$casting |> 
  transpose() |> 
  map(as.character) |> 
  as_tibble()

cast_tbl
```

Проделаем то же самое для списка эпизодов, но другим способом. Функция `pluck()` представляет собой аналог `[[`, который можно использовать в пайпе. Она позволяет эффективно индексировать многоуровневые списки. Поскольку списков много, мы используем ее в сочетании с `map_chr()`.

```{r}
episodes_tbl <- tibble(
  episode_id = map_chr(tbbt$episode_list, pluck, "episode_id"),
  title = map_chr(tbbt$episode_list, pluck, "title"))

episodes_tbl
```


:::{.callout-warning icon=false}
Самостоятельно создайте тиббл, в котором будет храниться количество серий для каждого сезона.
:::

Еще один способ описан [здесь](https://tidyr.tidyverse.org/articles/rectangle.html).

###  Датасет: Шедевры Пушкинского музея 

JSON -- популярный формат для публикации открытых данных. В таком виде часто публикуют данные органы государственной власти, культурные и некоммерческие организации и др. Например, [Пушкинский музей](https://pushkinmuseum.art/open_data/).

Взглянем на датасет "Шедевры из коллекции музея". JSON можно прочитать напрямую из Сети.

```{r}
doc <- read_json("https://pushkinmuseum.art/json/masterpieces.json")
```

Датасет содержит информацию о 97 единицах хранения.

```{r}
names(doc)
```
Для каждого предмета дано подробное описание. 

```{r}
summary(doc[[1]])
```
Заберем только то, что нам интересно. 

```{r}
masterpieces <- tibble(
  name = map_chr(doc, pluck, "name", "ru"),
  get_year = map_chr(doc, pluck, "get_year"),
  year = map_int(doc, pluck, "year"),
  period = map_chr(doc, pluck, "period", "name", "ru"),
  country = map_chr(doc, pluck, "country", "ru"),
  gallery = paste0("https://pushkinmuseum.art", map_chr(doc, pluck, "gallery", 1, 1)))
```

Библиотека `imager` позволяет работать с изображениями из датасета. Вот так мы могли бы забрать одно из них.

```{r eval=FALSE}
library(imager)
img <- load.image(masterpieces$gallery[1]) |> 
  plot()
img
```

```{r echo=FALSE, eval=FALSE}
save(img, file = "../data/img.Rdata")
```

![](./images/pushkin1.png)

В пакете `imager` есть функция `map_il()`, которая похожа на свою родню из `purrr`, но возвращает список изображений. 

```{r eval=FALSE}
img_gallery <- map_il(gallery, ~load.image(.x))
```

```{r echo=FALSE, eval=FALSE}
save(img_gallery, file = "../data/img_gallery.Rdata")
```

Функция `walk()` из пакета `purrr` -- это аналог `map()` для тех случаев, когда нас интересует только вывод, т.е.не надо ничего сохранять в окружение.

```{r eval=FALSE}
par(mfrow = c(10, 10), mar = rep(0,4))
walk(img_gallery, plot, axes = FALSE)
```

![](./images/pushkin2.png)

:::{.callout-warning icon=false}
Попробуйте самостоятельно узнать, когда приобретена большая часть шедевров и из каких регионов они происходят.
:::

## XML

XML (от англ. eXtensible Markup Language) --- расширяемый язык разметки. Слово "расширяемый" означает, что список тегов не зафиксирован раз и навсегда: пользователи могут вводить свои собственные теги и создавать так называемые _настраиваемые языки разметки_ [@xml2004, 29]. Один из таких настраиваемых языков -- это TEI (Text Encoding Initiative), о котором будет сказано дальше.

Назначение языков разметки заключается в описании структурированных документов. Структура документа представляется в виде набора вложенных в друг друга элементов (дерева XML). У элементов есть открывающие и закрывающие теги. 

Все составляющие части документа обобщаются в пролог и корневой элемент. Корневой элемент — обязательная часть документа, в которую вложены все остальные элементы. Пролог может включать объявления, инструкции обработки, комментарии.

В правильно сформированном XML открывающий и закрывающий тег вложенного элемента всегда находятся внутри одного родительского элемента.

Создадим простой XML из строки. Сначала идет инструкция по обработке XML (со знаком вопроса), за ней следует объявление типа документа (с восклицательным знаком) и открывающий тег корневого элемента. В этот корневой элемент вложены все остальные элементы.

```{r}
string_xml <- '<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE recipe>
<recipe name="хлеб" preptime="5min" cooktime="180min">
   <title>
      Простой хлеб
   </title>
   <composition>
      <ingredient amount="3" unit="стакан">Мука</ingredient>
      <ingredient amount="0.25" unit="грамм">Дрожжи</ingredient>
      <ingredient amount="1.5" unit="стакан">Тёплая вода</ingredient>
   </composition>
   <instructions>
     <step>
        Смешать все ингредиенты и тщательно замесить. 
     </step>
     <step>
        Закрыть тканью и оставить на один час в тёплом помещении. 
     </step>
     <step>
        Замесить ещё раз, положить на противень и поставить в духовку.
     </step>
   </instructions>
</recipe>'
```

### Библиотека `XML`

Для работы с xml понадобится установить одноименную библиотеку. Функция `xmlTreeParse()` создаст R-структуру, представляющую дерево XML.

```{r}
library(XML)
doc <- xmlTreeParse(string_xml)
class(doc)
```

Функция `xmlRoot()` позволяет извлечь корневой элемент вместе со всеми детьми. 

```{r}
rootnode <- xmlRoot(doc)
rootnode
```
 
Если документ большой, бывает удобнее не распечатывать все дерево, а вывести имена дочерних элементов.

```{r}
names(xmlChildren(rootnode))
```

Размер узла -- это число вложенных в него "детей". Его можно узнать, применив к узлу функцию `xmlSize()` -- или посчитав число "детей".

```{r}
xmlSize(rootnode) == length(xmlChildren(rootnode))
```

### Выбор элементов

Работать с xml можно как с обычным списком, то есть индексировать узлы по имени или по номеру элемента при помощи квадратных скобок. Так мы достаем узел по имени:

```{r}
rootnode[["composition"]]
```

А так -- по индексу:

```{r}
rootnode[[2]]
```

Как и с обычными списками, мы можем использовать последовательности квадратных скобок:

```{r}
ingr_node <- rootnode[[2]][["ingredient"]]
ingr_node
```
### Значения узлов и атрибутов

Но обычно нам нужен не элемент как таковой, а его содержание (значение). Чтобы добраться до него, используем функцию `xmlValue()`:

```{r}
xmlValue(ingr_node)
```

Можно уточнить атрибуты узла при помощи `xmlAttrs()`:

```{r}
xmlAttrs(ingr_node)
```

Чтобы извлечь значение атрибута, используем функцию `xmlGetAttr()`. Первым аргументом функции передаем xml-узел, вторым -- имя атрибута.

```{r}
xmlGetAttr(ingr_node, "unit")
```

### Обход дерева узлов

Как насчет того, чтобы применить функцию к набору узлов -- например, ко всем инредиентам? Вспоминаем функции для работы со списками -- `sapply()` из базового R или `map()` из пакета `purrr`: 

```{r}
ingr_nodes <- xmlChildren(rootnode[[2]])

sapply(ingr_nodes, xmlValue)
```


```{r}
sapply(ingr_nodes, xmlGetAttr, "unit")
```

### Синтаксис XPath

Добраться до узлов определенного уровня можно также при помощи синтаксиса [XPath](https://ru.wikipedia.org/wiki/XPath). XPath -- это язык запросов к элементам XML-документа. С его помощью можно описать "путь" до нужного узла: **абсолютный** (начиная с корневого элемента) или **относительный**. В пакете `XML` синтаксис XPath поддерживает функция `getNodeSet()`.

```{r}
# абсолютный путь
ingr_nodes <- getNodeSet(rootnode, "/recipe//composition//ingredient")

ingr_nodes
```

```{r}
# относительный путь
ingr_nodes <- getNodeSet(rootnode, "//composition//ingredient")

ingr_nodes
```

</br>

:::{.callout-note icon=false}
В большинстве случаев функция `getNodeSet()` требует задать **пространство имен** (namespace), но в нашем случае оно не определено, поэтому пока передаем только дерево и путь до узла. С пространством имен встретимся чуть позже!
:::

</br>

Синтаксис XPath позволяет отбирать узлы с определенными атрибутами. Допустим, нам нужны только те узлы, где значение атрибута unit = "стакан":

```{r}
getNodeSet(rootnode, "//composition//ingredient[@unit='стакан']")
```

### От дерева к таблице 

При работе с xml в большинстве случаев наша задача -- извлечь значения определеннных узлов или их атрибутов и сохранить их в прямоугольном формате.
Один из способов выглядит так.

```{r}
tibble(title = xmlValue(rootnode[["title"]]), 
       ingredients = map_chr(xmlChildren(rootnode[["composition"]]), xmlValue),
       unit = map_chr(xmlChildren(rootnode[["composition"]]), xmlGetAttr, "unit"),
       amount = map_chr(xmlChildren(rootnode[["composition"]]), xmlGetAttr, "amount"))
       
```

### Разметка TEI

Большая часть размеченных литературных корпусов хранится именно в формате XML. Это очень удобно, и вот почему: документы в формате XML, как и документы в формате HTML, содержат данные, заключенные в теги, но если в формате HTML теги определяют оформление данных, то в формате XML теги нередко определяют структуру и смысл данных. С их помощью мы можем достать из документа именно то, что нам интересно: определенную главу, речи конкретных персонажей, слова на иностранных языках и т.п. 

Добавлять и удалять разметку может любой пользователь в редакторе XML кода или даже в простом текстовом редакторе. При этом в качестве универсального языка разметки в гуманитарных дисциплинах используется язык TEI [@skorinkin2016]. Корневой элемент в документах TEI называется TEI, внутри него располагается элемент teiHeader с метаинформацией о документе и элемент text. Последний содержит текст документа с элементами, определяющими его структурное членение. 

```{}
<TEI>
  <teiHeader></teiHeader>
  <text></text>
</TEI>
```

Пример оформления документа можно посмотреть [по ссылке](https://github.com/dracor-org/rusdracor/blob/main/tei/fonvizin-nedorosl.xml).

У teiHeader есть четыре главных дочерних элемента:

- `fileDesc` (описание документа c библиографической информацией)
- `encodingDesc` (описание способа кодирование первоисточника)
- `profileDesc` ("досье" на текст, например отправитель и получатель для писем, жанр, используемые языки, обстоятельства создания, место написания и т.п.)
- `revisionDesc` (история изменений документа).

В самом тексте язык TEI дает возможность представлять разные варианты (авторские, редакторские, корректорские и др.) Основным средством параллельного представления является элемент `choice`. Например, в [тексте Лукреция](https://github.com/PerseusDL/canonical-latinLit/blob/master/data/phi0550/phi001/phi0550.phi001.perseus-lat1.xml) вы можете увидеть такое:

```{}
sic calor atque <choice><reg>aer</reg><orig>aër</orig></choice> et venti caeca potestas
```

Здесь reg указывает на нормализованное написание, а orig -- на оригинальное.

### Датасет: "Война и мир"

В качестве примера загрузим датасет "Пушкинского дома", подготовленный Д.А. Скоринкиным: ["Персонажи «Войны и мира» Л. Н. Толстого: вхождения в тексте, прямая речь и семантические роли"](https://dataverse.pushdom.ru/dataset.xhtml?persistentId=doi:10.31860/openlit-2022.1-C005). 


```{r}
filename = "../files/War_and_Peace.xml"
doc <- xmlTreeParse(filename, useInternalNodes = T)
rootnode <- xmlRoot(doc)
```

Теперь можно внимательнее взглянуть на структуру xml. Корневой элемент расходится на две ветви. Полностью они нам пока не нужны, узнаем только имена:

```{r}
names(xmlChildren(rootnode)) 
```

Очевидно, что что-то для нас интересное будет спрятано в ветке text, глядим на нее:

```{r}
names(xmlChildren(rootnode[["text"]])) 
```

Итак, текст делится на какие-то пять частей. Функция `xmlGetAttr()` позволяет узнать значение атрибута `type`: как выясняется, это четыре тома и эпилог.

```{r}
# это список
divs <-  rootnode[["text"]]["div"]

sapply(divs, xmlGetAttr, "type")
```


Как мы уже знаем, добраться до определенного узла можно не только путем индексирования, но и -- гораздо удобнее -- при помощи синтаксиса XPath. Для этого просто указываем путь до узла. Попробуем спуститься на два уровня ниже: там тоже будет тег div, но с другим атрибутом. Как легко убедиться, теперь это главы, всего их 358.

```{r}
divs <- getNodeSet(doc, "/tei:TEI//tei:text//tei:div//tei:div//tei:div",
                     namespaces = c(tei = "http://www.tei-c.org/ns/1.0")) 

length(divs)
unique(sapply(divs, xmlGetAttr, "type"))
```

Обратите внимание, что в данном случае надо прямо прописать пространство имен (namespaces). Это можно посмотреть в самом xml, а можно воспользоваться специальной функцией:

```{r}
xmlNamespace(rootnode)
```

Забрать конкретную главу можно путем индексации, но лучше -- по значению соответствующего атрибута.

```{r}
idx <- which(map(divs, xmlGetAttr, "xml:id") == "chapter1part1Volume1")
ch1 <- divs[[idx]]
```


Чтобы извлечь текст, понадобится функция `xmlValue`.

```{r}
chapter_1 <- xmlValue(ch1)
```

Распечатывать весь текст первой главы не будем (это очень длинный вектор); разобъем текст на параграфы и выведем первый и последний:

```{r}
library(stringr)
chapter_lines <- str_split(chapter_1, pattern = "\n")

chapter_lines[[1]][[5]]
chapter_lines[[1]][[838]]
```

Первая и последняя реплика по-французски: все правильно! 


:::{.callout-warning icon=false}
Скачайте по [ссылке](https://raw.githubusercontent.com/dracor-org/rusdracor/main/tei/griboyedov-gore-ot-uma.xml) "Горе от ума" Грибоедова и преобразуйте xml в прямоугольный формат таким образом, чтобы для каждой реплики был указан акт, сцена и действующее лицо.
:::


Подбробнее о структуре XML документов и способах работы с ними вы можете прочитать в книгах: [@nolan2014] и [@xml2004]. 