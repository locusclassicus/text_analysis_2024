# Импорт 

Ранее мы научились импортировать табличные данные с расширениями .csv и .tsv. Подробнее об импорте таблиц, текстов и изображений можно посмотреть [предыдущую версию](https://locusclassicus.github.io/text_analysis_2023/%D0%B8%D0%BC%D0%BF%D0%BE%D1%80%D1%82-%D0%B8-%D1%8D%D0%BA%D1%81%D0%BF%D0%BE%D1%80%D1%82-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85.html) курса. В этом уроке речь пойдет главным образом о работе со структурированными данными. 

## JSON

Формат JSON (JavaScript Object Notation) предназначен для представления структурированных данных. JSON имеет шесть основных [типов данных](https://r4ds.hadley.nz/rectangling#json). Четыре из них - скаляры:

-   cамый простой тип - `null` (нуль), который играет ту же роль, что и `NA` в R. Он представляет собой отсутствие данных;
-   cтрока (string) похожа на строку в R, но в ней всегда должны использоваться двойные кавычки;
-   число аналогично числам в R, при этом поддерживается целочисленная (например, 123), десятичная (например, 123.45) или научная (например, 1,23e3) нотация. JSON не поддерживает `Inf`, `-Inf` или `NaN`;
-   логическое значение аналогично `TRUE` и `FALSE` в R, но использует строчные буквы `true` и `false`.

Строки, числа и булевы значения в JSON очень похожи на символьные, числовые и логические векторы в R. Основное отличие заключается в том, что скаляры JSON могут представлять только одно значение. Для представления нескольких значений необходимо использовать один из двух оставшихся типов: массивы и объекты.

И массивы, и объекты похожи на списки в R, разница заключается в том, именованы они или нет. _Массив_ подобен безымянному списку и записывается через `[]`. Например, `[1, 2, 3]` - это массив, содержащий 3 числа, а `[null, 1, "string", false]` - массив, содержащий ноль, число, строку и булево значение. 

_Объект_ подобен именованному списку и записывается через `{}`. Имена (ключи в терминологии JSON) являются строками, поэтому должны быть заключены в кавычки. Например, {"x": 1, "y": 2} - это объект, который сопоставляет x с 1, а y -- с 2.

Загрузим небольшой файл `TBBT.json`, хранящий данные о сериале "Теория большого взрыва" ([источник](https://gist.github.com/sahithyandev/540c82170a19f97deef9e23796083f01)). Скачать лучше из репозитория курса [ссылка](https://github.com/locusclassicus/text_analysis_2024/raw/main/files/TBBT.json). 

```{r message=FALSE}
library(jsonlite)

path <- "../files/TBBT.json"
tbbt <- fromJSON(txt =  path,
                 simplifyVector = T)
```

Функция `fromJSON()` вернула нам список, в предпросмотре он выглядит так.

![](./images/tbbt.png)
Выборочно преобразуем список в тиббл:

```{r message=FALSE}
library(tidyverse)

cast_tbl <- tbbt$casting |> 
  transpose() |> 
  map(as.character) |> 
  as_tibble()

cast_tbl
```

Проделаем то же самое для списка эпизодов, но немного другим способом. 

```{r}
episodes_tbl <- tibble(
  episode_id = map_chr(tbbt$episode_list, pluck, "episode_id"),
  title = map_chr(tbbt$episode_list, pluck, "title"))

episodes_tbl
```

:::{.callout-warning icon=false}
Самостоятельно создайте тиббл, в котором будет храниться количество серий для каждого сезона.
:::


## XML

**XML** (от англ. eXtensible Markup Language) --- расширяемый язык разметки. Слово "расширяемый" означает, что список тегов не зафиксирован раз и навсегда: пользователи могут вводить свои собственные теги и создавать так называемые **настраиваемые языки разметки** [@xml2004, 29]. Один из таких настраиваемых языков -- это **TEI** (Text Encoding Initiative), о котором будет сказано дальше.

Назначение языков разметки заключается в описании структурированных документов. Структура документа представляется в виде набора вложенных в друг друга элементов (**дерева XML**). У элементов есть открывающие и закрывающие теги. 

Все составляющие части документа обобщаются в пролог и корневой элемент. **Корневой элемент** — обязательная часть документа, в которую вложены все остальные элементы. **Пролог** может включать объявления, инструкции обработки, комментарии.

В правильно сформированном XML открывающий и закрывающий тег вложенного элемента всегда находятся внутри одного родительского элемента.

Создадим простой XML из строки. Сначала идет инструкция по обработке XML (со знаком вопроса), за ней следует объявление типа документа (с восклицательным знаком) и открывающий тег корневого элемента. В этот корневой элемент вложены все остальные элементы.

```{r}
string_xml <- '<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE recipe>
<recipe name="хлеб" preptime="5min" cooktime="180min">
   <title>
      Простой хлеб
   </title>
   <composition>
      <ingredient amount="3" unit="стакан">Мука</ingredient>
      <ingredient amount="0.25" unit="грамм">Дрожжи</ingredient>
      <ingredient amount="1.5" unit="стакан">Тёплая вода</ingredient>
   </composition>
   <instructions>
     <step>
        Смешать все ингредиенты и тщательно замесить. 
     </step>
     <step>
        Закрыть тканью и оставить на один час в тёплом помещении. 
     </step>
     <step>
        Замесить ещё раз, положить на противень и поставить в духовку.
     </step>
   </instructions>
</recipe>'
```

Для работы с xml понадобится установить одноименную библиотеку. Функция `xmlTreeParse()` создаст R-структуру, представляющую дерево XML.

```{r}
library(XML)
doc <- xmlTreeParse(string_xml)
class(doc)
```

Функция xmlRoot позволяет извлечь корневой элемент вместе со всеми детьми. 

```{r}
rootnode <- xmlRoot(doc)
rootnode
```
 
Если документ большой, бывает удобнее не распечатывать все дерево, а вывести имена дочерних элементов.

```{r}
names(xmlChildren(rootnode))
```

Размер узла -- это число вложенных в него "детей". Его можно узнать, применив к узлу функцию `xmlSize()` -- или подсчитав число "детей".

```{r}
xmlSize(rootnode) == length(xmlChildren(rootnode))
```


Работать с xml можно как с обычным списком, то есть индексировать узлы по имени или по номеру элемента при помощи квадратных скобок. Так мы достаем узел по имени:

```{r}
rootnode[["composition"]]
```

А так -- по индексу:

```{r}
rootnode[[2]]
```

Как и с обычными списками, мы можем использовать последовательности квадратных скобок:

```{r}
ingr_node <- rootnode[[2]][["ingredient"]]
ingr_node
```
Но обычно нам нужен не элемент как таковой, а его содержание (значение). Чтобы добраться до него, используем функцию `xmlValue()`:

```{r}
xmlValue(ingr_node)
```

Можно уточнить атрибуты узла при помощи `xmlAttrs()`:

```{r}
xmlAttrs(ingr_node)
```

Чтобы извлечь значение атрибута, используем функцию `xmlGetAttr()`. Первым аргументом функции передаем xml-узел, вторым -- имя атрибута.

```{r}
xmlGetAttr(ingr_node, "unit")
```

Как насчет того, чтобы применить функцию к набору узлов -- например, ко всем инредиентам? Вспоминаем функции для работы со списками -- `sapply()` из базового R или `map()` из пакета `purrr`: 

```{r}
ingr_nodes <- xmlChildren(rootnode[[2]])

sapply(ingr_nodes, xmlValue)
```


```{r}
sapply(ingr_nodes, xmlGetAttr, "unit")
```

Добраться до узлов определенного уровня можно также при помощи синтаксиса [XPath](https://ru.wikipedia.org/wiki/XPath). XPath -- это язык запросов к элементам XML-документа. С его помощью можно описать "путь" до нужного узла: **абсолютный** (начиная с корневого элемента) или **относительный**. В пакете `XML` синтаксис XPath поддерживает функция `getNodeSet()`.

```{r}
# абсолютный путь
ingr_nodes <- getNodeSet(rootnode, "/recipe//composition//ingredient")

ingr_nodes
```

```{r}
# относительный путь
ingr_nodes <- getNodeSet(rootnode, "//composition//ingredient")

ingr_nodes
```

</br>

:::{.callout-note icon=false}
В большинстве случаев функция `getNodeSet()` требует задать **пространство имен** (namespace), но в нашем случае оно не определено, поэтому пока передаем только дерево и путь до узла. С пространством имен встретимся чуть позже!
:::

</br>

Синтаксис XPath позволяет отбирать узлы с определенными атрибутами. Допустим, нам нужны только те узлы, где значение атрибута unit = "стакан":

```{r}
getNodeSet(rootnode, "//composition//ingredient[@unit='стакан']")
```

При работе с xml в большинстве случаев наша задача -- извлечь значения определеннных узлов или их атрибутов и сохранить их в прямоугольном формате. 

В нашем простом примере это можно сделать несколькими способами. Первый: просто связать воедино несколько векторов. 

```{r}
title <- xmlValue(rootnode[["title"]])
ingredients <- map_chr(xmlChildren(rootnode[["composition"]]), xmlValue)
unit <- map_chr(xmlChildren(rootnode[["composition"]]), xmlGetAttr, "unit")
amount <- map_chr(xmlChildren(rootnode[["composition"]]), xmlGetAttr, "amount")


tibble(title, ingredients, unit, amount)
```

В некоторых случаях бывает удобно также воспользоваться функциями из пакета `xml2` в сочетании с функциями семейства `unnest_` из `tidyr`.


```{r}
library(xml2)

doc <- as_list(read_xml(string_xml))

# попробуем достать атрибуты
doc |> 
  as_tibble() |> 
  unnest_longer(recipe) |> 
  filter(recipe_id == "ingredient") |> 
  mutate(unit = map_chr(recipe, attr, "unit")) |> 
  mutate(amount = map_chr(recipe, attr, "amount")) |> 
  select(-recipe_id) |> 
  unnest_longer(recipe)
```

## TEI

Большая часть размеченных литературных корпусов хранится именно в формате XML. Это очень удобно, и вот почему: документы в формате XML, как и документы в формате HTML, содержат данные, заключенные в теги, но если в формате HTML теги определяют оформление данных, то в формате XML теги нередко *определяют структуру и смысл данных*. С их помощью мы можем достать из документа именно то, что нам интересно: определенную главу, речи конкретных персонажей, слова на иностранных языках и т.п. 

Добавлять и удалять разметку может любой пользователь в редакторе XML кода или даже в простом текстовом редакторе. При этом в качестве универсального языка разметки в гуманитарных дисциплинах используется язык TEI [@skorinkin2016]. Корневой элемент в документах TEI называется TEI, внутри него располагается элемент teiHeader с метаинформацией о документе и элемент text. Последний содержит текст документа с элементами, определяющими его структурное членение. 

```{}
<TEI>
  <teiHeader></teiHeader>
  <text></text>
</TEI>
```

Пример оформления документа можно посмотреть [по ссылке](https://github.com/dracor-org/rusdracor/blob/main/tei/fonvizin-nedorosl.xml).

У teiHeader есть четыре главных дочерних элемента:

- fileDesc (описание документа c библиографической информацией)
- encodingDesc (описание способа кодирование первоисточника)
- profileDesc ("досье" на текст, например отправитель и получатель для писем, жанр, используемые языки, обстоятельства создания, место написания и т.п.)
- revisionDesc (история изменений документа)

В самом тексте язык TEI дает возможность представлять разные варианты (авторские, редакторские, корректорские и др.) Основным средством параллельного представления является элемент choice. Например, в [тексте Лукреция](https://github.com/PerseusDL/canonical-latinLit/blob/master/data/phi0550/phi001/phi0550.phi001.perseus-lat1.xml) вы можете увидеть такое:

```{}
sic calor atque <choice><reg>aer</reg><orig>aër</orig></choice> et venti caeca potestas
```

Здесь reg указывает на нормализованное написание, а orig -- на оригинальное. 

В качестве примера загрузим датасет "Пушкинского дома", подготовленный Д.А. Скоринкиным: ["Персонажи «Войны и мира» Л. Н. Толстого: вхождения в тексте, прямая речь и семантические роли"](https://dataverse.pushdom.ru/dataset.xhtml?persistentId=doi:10.31860/openlit-2022.1-C005). 


```{r}
filename = "../files/War_and_Peace.xml"
doc <- xmlTreeParse(filename, useInternalNodes = T)
rootnode <- xmlRoot(doc)
```

Теперь можно внимательнее взглянуть на структуру xml. Корневой элемент расходится на две ветви. Полностью они нам пока не нужны, узнаем только имена:

```{r}
names(xmlChildren(rootnode)) 
```

Очевидно, что что-то для нас интересное будет спрятано в ветке text, глядим на нее:

```{r}
names(xmlChildren(rootnode[["text"]])) 
```

Итак, текст делится на какие-то пять частей. Функция `xmlGetAttr()` позволяет узнать значение атрибута `type`: как выясняется, это четыре тома и эпилог.

```{r}
# это список
divs <-  rootnode[["text"]]["div"]

sapply(divs, xmlGetAttr, "type")
```


Как мы уже знаем, добраться до определенного узла можно не только путем индексирования, но и -- гораздо удобнее -- при помощи синтаксиса XPath. Для этого просто указываем путь до узла. Попробуем спуститься на два уровня ниже: там тоже будет тег div, но с другим атрибутом. Как легко убедиться, теперь это главы, всего их 358.

```{r}
divs <- getNodeSet(doc, "/tei:TEI//tei:text//tei:div//tei:div//tei:div",
                     namespaces = c(tei = "http://www.tei-c.org/ns/1.0")) 

length(divs)
unique(sapply(divs, xmlGetAttr, "type"))
```

Обратите внимание, что в данном случае надо прямо прописать пространство имен (namespaces). Это можно посмотреть в самом xml, а можно воспользоваться специальной функцией:

```{r}
xmlNamespace(rootnode)
```

Забрать конкретную главу можно путем индексации, но лучше -- по значению соответствующего атрибута.

```{r}
idx <- which(map(divs, xmlGetAttr, "xml:id") == "chapter1part1Volume1")
ch1 <- divs[[idx]]
```


Чтобы извлечь текст, понадобится функция `xmlValue`.

```{r}
chapter_1 <- xmlValue(ch1)
```

Распечатывать весь текст первой главы не будем (это очень длинный вектор); разобъем текст на параграфы и выведем первый и последний:

```{r}
library(stringr)
chapter_lines <- str_split(chapter_1, pattern = "\n")

chapter_lines[[1]][[5]]
chapter_lines[[1]][[838]]
```

Первая и последняя реплика по-французски: все правильно! 


:::{.callout-warning icon=false}
Скачайте по [ссылке](https://raw.githubusercontent.com/dracor-org/rusdracor/main/tei/griboyedov-gore-ot-uma.xml) "Горе от ума" Грибоедова и преобразуйте xml в прямоугольный формат таким образом, чтобы для каждой реплики был указан акт, сцена и действующее лицо.
:::


Подбробнее о структуре XML документов и способах работы с ними вы можете прочитать в книгах: [@nolan2014] и [@xml2004]. 


## Бонус: GutenbergR

Пакет `GutenbergR` поможет достать тексты из библиотеки [Gutenberg](https://www.gutenberg.org/ebooks/), но будьте осторожны: распознаны они не всегда хорошо и порой содержат много разного шума, например примечания редактора, номера страниц и т.п. В билингвах источник и перевод могут идти вперемешку. И если в XML подобные элементы будут окружены соответствующими тегами, которые позволят их легко отбросить при анализе, то Gutenberg дает вам сырой текст. Часто его надо хорошенько чистить при помощи регулярных выражений или даже вручную. 

Работать с метаданными GutenbergR вы уже научились, теперь можете пользоваться пакетом и для скачивания текстов. Сначала узнаем id нужных текстов^
[https://cran.r-project.org/web/packages/gutenbergr/vignettes/intro.html]

```{r}
library(gutenbergr)

caesar <- gutenberg_works(author == "Caesar, Julius", languages = "la") 

caesar 
```

Чтобы извлечь отдельный текст (тексты):

```{r}
de_bello_gallico <- gutenberg_download(218, meta_fields = "title", mirror = "ftp://mirrors.xmission.com/gutenberg/")
de_bello_gallico
```

:::{.callout-note icon=false}
Существует несколько зеркал библиотеки Gutenberg, и, если при выполнении функции `gutenberg_download()` возникает ошибка "could not download a book at <http://aleph.gutenberg.org/>", то следует использовать аргумент mirror. Список зеркал доступен по ссылке: <https://www.gutenberg.org/MIRRORS.ALL>
:::

