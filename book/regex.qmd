# Регулярные выражения 


Есть старая шутка, ее приписывают программисту Джейми Завински: если у вас есть проблема, и вы собираетесь ее решать при помощи регулярных выражений, то у вас две проблемы. Регулярные выражения -- это формальный язык, который используется для того, чтобы находить, извлекать и заменять части текста. 

Регулярные выражения (regex, regexp) объединяют _буквальные символы_ (литералы) и _метасимволы_ (символы-джокеры, англ. wildcard characters). 

Для поиска используется строка-образец (англ. pattern, по-русски её часто называют "шаблоном", "маской"), которая задает правило поиска. Строка замены также может содержать в себе специальные символы. 

Отличный путеводитель по миру регулярных выражений можно найти [здесь](https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html).

## Regex в базовом R

В базовом R за работу со строками отвечают, среди прочего, такие функции, как `grep()` и `grepl()`. При этом `grepl()` возвращает TRUE, если шаблон найден в соответствующей символьной строке, а `grep()` возвращает вектор индексов символьных строк, содержащих паттерн. 

Обеим функциям необходим аргумент `pattern` и аргумент `x`, где `pattern` - регулярное выражение, по которому производится поиск, а аргумент `x` - вектор символов, по которым следует искать совпадения.

Функция `gsub()` позволяет производить замену и требует также аргумента `replacement`.

## Литералы и классы

Буквальные символы -- это то, что вы ожидаете увидеть (или не увидеть -- для управляющих и пробельных символов); можно сказать, что это символы, которые ничего не "имеют в виду". Их можно объединять в классы при помощи квадратных скобок, например, так: `[abc]`.

```{r}
vec <- c("a", "d", "c")
grepl("[abc]", vec)
grep("[abc]", vec)
```

Для некоторых классов есть специальные обозначения.

|Класс | Эквивалент | Значение|
|----- | ------- | -----|
| [:upper:] |	[A-Z] |	Символы верхнего регистра |
| [:lower:] |	[a-z] |	Символы нижнего регистра |
| [:alpha:] |	[[:upper:][:lower:]] |	Буквы |
| [:digit:] |	[0-9], т. е. \\d  |	Цифры |
| [:alnum:] |	[[:alpha:][:digit:]] |	Буквы и цифры |
| [:word:] 	| [[:alnum:]_], т. е. \\w |	Символы, образующие «слово» |
| [:punct:] |	[-!"#$%&'()*+,./:;<=>?@[\\\]_`{\|}~] |	Знаки пунктуации |
| [:blank:] |	[\\s\\t] |	Пробел и табуляция |
| [:space:] |	[[:blank:]\\v\\r\\n\\f], т. е. \\s |	Пробельные символы |
|[:cntrl:] |	 |	Управляющие символы (перевод строки, табуляция и т.п.) |
| [:graph:] |	 |	Печатные символы |
| [:print:] |	 |	Печатные символы с пробелом |

Эти классы тоже можно задавать в качестве паттерна.

```{r}
vec <- c("жираф", "верблюд1", "0зебра")
gsub( "[[:digit:]]",  "", vec)
```

</br>

:::{.callout-warning icon=false}
В пакете `stringr` есть небольшой датасет `words`. Найдите все слова с последовательностью символов wh.  Сколько слов содержат два гласных после w?
:::

</br>


В качестве классов можно рассматривать и следующие обозначения:

| Представление |	Эквивалент | 	Значение |
|-------------- | ---------- | ----------|
| \\d |	[0-9] |	Цифра |
| \\D |	[^\\d] |	Любой символ, кроме цифры |
| \\w |	[A-Za-zА-Яа-я0-9_] |	Символы, образующие «слово» (буквы, цифры и символ подчёркивания) |
| \\W |	[^\\w] |	Символы, не образующие «слово» |
| \\s |	[ \\t\\v\\r\\n\\f] |	Пробельный символ |
| \\S |	[^\\s] |	Непробельный символ |

```{r}
gsub( "\\d",  "", vec) # вторая косая черта "экранирует" первую
```

Внутри квадратных скобор знак `^` означает отрицание:

```{r}
gsub( "[^[:digit:]]",  "", vec) 
```

</br>

:::{.callout-warning icon=false}
Найдите все слова в `words`, в которых за w следует согласный. Замените всю пунктуацию в строке "tomorrow?and-tomorrow_and!tomorrow" на пробелы.
:::

</br>



## Якоря

Якоря позволяют искать последовательности символов в начале или в конце строки. Знак `^` (вне квадратных скобок!) означает начало строки, а знак `$` -- конец. Мнемоническое правило: First you get the power (^) and then you get the money ($).

```{r}
vec <- c("The spring is a lovely time", 
         "Fall is a time of peace")
grepl("time$", vec)
```

</br>

:::{.callout-warning icon=false}
Найдите все слова в `words`, которые заканчиваются на x. Найдите все слова, которые начинаются на b или на g.
:::

</br>


## Метасимволы

Все метасимволы представлены в таблице ниже.

| Описание |	Символ |
| ---------| --------| 
|открывающая квадратная скобка |	[ |
|закрывающая квадратная скобка |	] |
|обратная косая черта |	\\ |
|карет |	^ |
|знак доллара |	$ |
|точка |	. |
|вертикальная черта |	\| |
|знак вопроса |	? |
|астериск |	* |
|плюс |	+ |
|открывающая фигурная скобка |	\{ |
|закрывающая фигурная скобка |	\} |
|открывающая круглая скобка |	( |
|закрывающая круглая скобка	| ) |

Квадратные скобки используются для создания классов, карет и знак доллара -- это якоря, но карет внутри квадратных скобок может также быть отрицанием. Точка -- это любой знак. 

```{r}
vec <- c("жираф", "верблюд1", "0зебра")
grep(".б", vec) 
```


</br>

:::{.callout-warning icon=false}
Найдите все слова в `words`, в которых есть любые два символа между b и k.
:::

</br>


## Экранирование

Если необходимо найти буквальную точку, буквальный знак вопроса и т.п., то используется экранирование: перед знаком ставится косая черта. Но так как сама косая черта -- это метасимвол, но нужно две косые черты, первая из которых экранирует вторую.

```{r}
vec <- c("жираф?", "верблюд.", "зебра")
grep("\\?", vec) 
grepl("\\.", vec)
```

</br>

:::{.callout-warning icon=false}
Узнайте, все ли предложения в sentences (входит в stringr) кончаются на точку.
:::

</br>

## Квантификация

Квантификатор после символа, символьного класса или группы определяет, сколько раз предшествующее выражение может встречаться. Квантификатор может относиться более чем к одному символу в регулярном выражении, только если это символьный класс или группа.

| Представление |	Число повторений |	Эквивалент |	
| --------------| -----------------| ------------| 
| ? 	| Ноль или одно |	{0,1} 	|
| * 	| Ноль или более |	{0,} 	|
| + 	| Одно или более |	{1,} 	|

Пример:

```{r}
vec <- c("color", "colour", "colouur")
grepl("ou?r", vec) # ноль или одно 
grepl("ou+r", vec) # одно или больше
grepl("ou*r", vec) # ноль или больше
```
Точное число повторений (интервал) можно задать в фигурных скобках:

| Представление |	Число повторений 	|
| ------------- | ----------------  |
| {n} |	Ровно n раз 	|
| {m,n} |	От m до n включительно 	|
| {m,} |	Не менее m 	|
| {,n} |	Не более n |

```{r}
vec <- c("color", "colour", "colouur", "colouuuur")
grepl("ou{1}r", vec)
grepl("ou{1,2}r", vec)
grepl("ou{,2}r", vec) # это включает и ноль!
```

Часто используется последовательность `.*` для обозначения любого количества любых символов между двумя частями регулярного выражения. 


:::{.callout-warning icon=false}
Узнайте, в каких предложениях в sentences за пробелом следует ровно три согласных.
:::

## Жадная и ленивая квантификация

В регулярных выражениях квантификаторам соответствует максимально длинная строка из возможных (квантификаторы являются жадными, англ. greedy). Это может оказаться значительной проблемой. Например, часто ожидают, что выражение `<.*>` найдёт в тексте теги HTML. Однако если в тексте есть более одного HTML-тега, то этому выражению соответствует _целиком строка, содержащая множество тегов_.

```{r}
vec <- c("<p><b>Википедия</b> — свободная энциклопедия, в которой <i>каждый</i> может изменить или дополнить любую статью.</p>")
gsub("<.*>", "", vec) # все исчезло!
```

Чтобы этого избежать, надо поставить после квантификатора знак вопроса. Это сделает его ленивым.

| regex |	значение |
| ------ | -------- |
| ?? |	0 или 1, лучше 0 |
| *? | 	0 или больше, как можно меньше |
| +? |  1 или больше, как можно меньше |
| {n,m}? |	от n до m, как можно меньше |

Пример:

```{r}
gsub("<.*?>", "", vec) # все получилось!
```

:::{.callout-warning icon=false}
Дана строка "tomorrow (and) tomorrow (and) tomorrow". Необходимо удалить первые скобки с их содержанием. 
:::


## Regex в stringr: основы 

Пакет `stringr` не является частью `tidyverse`, хотя и разделяет его принципы^[https://r4ds.had.co.nz/strings.html]. Его надо загружать отдельно:

```{r}
library(stringr)
```

Это очень удобный инструмент для работы со строками. Вот так можно узнать длину строки или объединить ее с другими строками:

```{r}
vec <- c("жираф", "верблюд")
str_length(vec)
str_c("красивый_", vec)
```
Элементы вектора можно объединить в одну строку:

```{r}
str_c(vec, collapse = ", ") # теперь у них общие кавычки
```

С помощью `str_sub()` и `str_sub_all()` можно выбрать часть строки^[https://stringr.tidyverse.org/reference/str_sub.html].

```{r}
vec <- c("жираф", "верблюд")
str_sub(vec, 1, 3)
str_sub(vec, 1, -2)
```

Функции ниже меняют начертание с прописного на строчное или наоборот:

```{r}
VEC <- str_to_upper(vec)
VEC

str_to_lower(VEC)
str_to_title(vec)
```
Одна из полезнейших функций в этом пакете -- `str_view()`; она помогает увидеть, что поймало регулярное выражение -- до того, как вы внесете какие-то изменения в строку.

```{r}
str_view(c("abc", "a.c", "bef"), "a\\.c")
```
Например, с помощью этой функции можно убедиться, что вертикальная черта выступает как логический оператор "или": 

```{r}
str_view(c("grey", "gray"), "gr(e|a)y")
```

</br>

:::{.callout-warning icon=false}
Создайте тиббл с двумя столбцами: letters и numbers (1:26). Преобразуйте, чтобы в третьем столбце появился результат соединения первых двух через подчеркивание, например a_1. Отфильтруйте, чтобы остались только ряды, где есть цифра 3 или буква x.
:::

</br>

## str_detect() и str_count()

Аналогом `grepl()` в `stringr` является функция `str_detect()`

```{r}
library(rcorpora)
data("fruit")
head(fruit)

str_detect(head(fruit), "[aeiou]$")

# какая доля слов заканчивается на гласный?
mean(str_detect(fruit, "[aeiou]$"))

# сколько всего слов заканчивается на гласный?
sum(str_detect(fruit, "[aeiou]$"))
```

Отрицание можно задать двумя способами:

```{r}
data("words")

no_vowels1 <- !str_detect(words, "[aeiou]") # слова без гласных

no_vowels2 <- str_detect(words, "^[^aeiou]+$") # слова без гласных

sum(no_vowels1 != no_vowels2)
```

Логический вектор можно использовать для индексирования:

```{r}
words[!str_detect(words, "[aeiou]")]
```

Эту функцию можно применять вместе с функцией filter() из пакета dplyr:

```{r message=FALSE}
library(dplyr)
gods <- corpora(which = "mythology/greek_gods")

df <- tibble(god = as.character(gods$greek_gods), 
             i = seq_along(god)
             )

df |> 
  filter(str_detect(god, "s$"))
```

Вариацией этой функции является `str_count()`:

```{r}
str_count(as.character(gods$greek_gods), "[Aa]")
```

Эту функцию удобно использовать вместе с `mutate()` из `dplyr`:

```{r}
df |> 
  mutate(
    vowels = str_count(god, "[AEIOYaeiou]"),
    consonants = str_count(god, "[^AEIOYaeiou]")
  )
```

:::{.callout-warning icon=false}
Преобразуйте sentences из пакета `stringr` в тиббл; в новом столбце сохраните количество пробелов в каждом предложении.
:::


## str_extract(), str_subset() и str_match()

Функция `str_extract()` извлекает совпадения^[https://r4ds.had.co.nz/strings.html#extract-matches]. 

Сначала зададим паттерн для поиска.

```{r}
colours <- c(" red", "orange", "yellow", "green", "blue", "purple")
colour_match <- str_c(colours, collapse = "|")
colour_match
```

И применим к предложениями. Используем `str_extract_all()`, т.к. `str_extract()` возвращает только первое вхождение.

```{r}
has_colour <- str_subset(sentences, colour_match)
matches <- str_extract_all(has_colour, colour_match)
head(unlist(matches))
```


Круглые скобки используются для группировки. Например, мы можем задать шаблон для поиска существительного или прилагательного с артиклем.

```{r}
noun <- "(a|the) ([^ ]+)" # как минимум один непробельный символ после пробела

has_noun <- sentences |>
  str_subset(noun) |>
  head(10)
has_noun
```

Дальше можно воспользоваться уже известной функцией `str_extract()` или применить `str_match`. Результат будет немного отличаться: вторая функция вернет матрицу, в которой хранится не только сочетание слов, но и каждый компонент отдельно.

```{r}
has_noun |> 
  str_extract(noun)

has_noun |> 
  str_match(noun)
```

Функция `tidyr::extract()` работает похожим образом, но требует дать имена для каждого элемента группы. Этим удобно пользоваться, если ваши данные хранятся в виде тиббла.

```{r}
tibble(sentence = sentences) |> 
  tidyr::extract(
    sentence, c("article", "noun"), "(a|the) ([^ ]+)", 
    remove = FALSE
  )
```

</br>

:::{.callout-warning icon=false}
Найдите в sentences все предложения, где есть to, и выберите следующее за этим слово. Переведите в нижний регистр. Узнайте, сколько всего уникальных сочетаний.
:::

</br>


## str_replace 

Функции `str_replace()` и `str_replace_all()` позволяют заменять совпадения на новые символы. 

```{r}
x <- c("apple", "pear", "banana")
str_replace(x, "[aeiou]", "-")

str_replace_all(x, "[aeiou]", "-")
```

Этим можно воспользоваться, если вы хотите, например, удалить из текста все греческие символы. Для стандартного греческого алфавита хватит `[Α-Ωα-ω]`, но для древнегреческого этого, например, не хватит. Попробуем на отрывке из письма Цицерона Аттику, которое содержит греческий текст.

```{r}
cicero <- "nihil hāc sōlitūdine iūcundius, nisi paulum interpellāsset Amyntae fīlius. ὢ ἀπεραντολογίας ἀηδοῦς! "

str_replace_all(cicero, "[Α-Ωα-ω]", "")

```
ὢ ἀί ἀῦ! Не все у нас получилось гладко. Попробуем иначе:

```{r}
str_replace_all(cicero, "[\u0370-\u03FF]", "")
```
Удалилась (буквально была заменена на пустое место) та диакритика, которая есть в новогреческом (ί). Но остались еще буквы со сложной диакритикой, которой современные греки не пользуются.

```{r}
no_greek <- str_replace_all(cicero, "[[\u0370-\u03FF][\U1F00-\U1FFF]]", "")
no_greek
```
! Мы молодцы. Избавились от этого непонятного греческого. 

На самом деле, конечно, `str_replace` хорош тем, что он позволяет производить осмысленные замены. Например, мы можем в оставшемся латинском текст заменить гласные с макроном (черточка, означающая долготу) на обычные гласные. 
```{r}
str_replace_all(no_greek, c("ā" = "a", "ū" = "u", "ī" = "i", "ō" = "o"))
```

Красота. О более сложных заменах с перемещением групп можно посмотреть видео [здесь](https://vk.com/video-211800158_456239296) и [здесь](https://vk.com/video-211800158_456239297). Это помогает даже в таком скорбном деле, как переоформление библиографии.

:::{.callout-warning icon=false}
Дана библиографическая запись:

Ast, Friedrich. 1816. Platon’s Leben und Schriften. Leipzig, Weidmann.

Используя регулярные выражения, замените полное имя на инициал. Запятую перед инициалом удалите.  Уберите название издательства. Год поставьте в круглые скобки.
:::

## str_split

Функция `str_split()` помогает разбить текст на предложения, слова или просто на бессмысленные наборы символов. Это важный этап подготовки текста для анализа, и проводится он нередко именно с применением регулярных выражений. 

```{r}
sentences |>
  head(2) |> 
  str_split(" ")
```

Но можно обойтись и без регулярных выражений. 

```{r warning=FALSE}
x <- "This is a sentence.  This is another sentence."
str_view_all(x, boundary("word"))
str_view_all(x, boundary("sentence"))
```
Очень удобно, но убедитесь, что в вашем языке границы слов и предложения выглядят как у людей. С древнегреческим эта штука не справится (как делить на предложения греческие и латинские тексты, я рассказывала [здесь](https://vk.com/video-211800158_456239226)):

```{r}
apology <- c("νῦν δ' ἐπειδὴ ἀνθρώπω ἐστόν, τίνα αὐτοῖν ἐν νῷ ἔχεις ἐπιστάτην λαβεῖν; τίς τῆς τοιαύτης ἀρετῆς, τῆς ἀνθρωπίνης τε καὶ πολιτικῆς, ἐπιστήμων ἐστίν; οἶμαι γάρ σε ἐσκέφθαι διὰ τὴν τῶν ὑέων κτῆσιν. ἔστιν τις,” ἔφην ἐγώ, “ἢ οὔ;” “Πάνυ γε,” ἦ δ' ὅς. “Τίς,” ἦν δ' ἐγώ, “καὶ ποδαπός, καὶ πόσου διδάσκει;")

str_view_all(apology, boundary("sentence"))
```

Полный крах `r emo::ji("poop")`

