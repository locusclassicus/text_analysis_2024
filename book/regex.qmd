# Регулярные выражения 

Есть старая шутка, ее приписывают программисту Джейми Завински: если у вас есть проблема, и вы собираетесь ее решать при помощи регулярных выражений, то у вас две проблемы. Регулярные выражения -- это формальный язык, который используется для того, чтобы находить, извлекать и заменять части текста. 

Регулярные выражения (regex, regexp) объединяют _литералы_ (буквальные символы) и _метасимволы_ (специальные символы, задающие правила поиска). Для поиска используется строка-шаблон (англ. pattern), которая определяет правило сопоставления и поиска нужного фрагмента текста.

Для работы нам понадобится пакет `{stringr}` из библиотеки `tidyverse`. Также установите библиотеку `{tokenizers}`.

```{r message=FALSE}
library(tidyverse)
library(tokenizers)
```

:::{.callout-note icon=false}
Отличный путеводитель по миру регулярных выражений можно найти [здесь](https://cran.r-project.org/web/packages/stringr/vignettes/regular-expressions.html).
:::

Загрузим текст романа "Гордость и предубеждение". 

```{r}
library(janeaustenr)
pp <- prideprejudice 
head(pp, 12)
```

## `str_c()`, `str_trunc()`, `str_squish()`

Для объединения строк используется функция `str_c()`:

```{r}
names <- c("Jane", "Elizabeth")

str_c(names, "Bennet", sep = " ")
str_c(names, collapse = " and ")
```

Объединим текст романа в единый вектор и воспользуемся функцией `str_trunc()`, чтобы распечатать самое начало.

```{r}
pp <- str_c(pp, collapse = " ")
str_trunc(pp, 120)
```

Избавимся от лишних пробелов.

```{r}
pp <- str_squish(pp)
str_trunc(pp, 120)
```

## `str_sub()`, `str_count()`, `str_length()`

Функция `str_sub()` извлекает подстроку из строки.  

```{r}
opening <- str_sub(pp, 46, 162)
opening
```

Ее также можно использовать для замены. Удалим название и автора.

```{r}
str_sub(pp, 1, 35) <- ""
str_trunc(pp, 35)
```

Узнаем длину первого предложения в символах.

```{r}
str_length(opening) # или: nchar(pp)
```

Узнать длину в словах можно, посчитав число пробелов и добавив 1 (лишние пробелы мы уже удалили).

```{r}
str_count(opening, " ") + 1
```

## Классы символов

В  таблице показаны наиболее часто используемые специальные обозначения, которые применяются в регулярных выражениях для удобного поиска разных типов символов. (Пишем две косые черты, т.к. вторая косая черта "экранирует" первую, см. далее).

| Представление |	Эквивалент | 	Значение |
|-------------- | ---------- | ----------|
| `\\d` |	`[0-9]` |	Цифра |
| `\\D` |	`[^\\d]` |	Любой символ, кроме цифры |
| `\\w` |	`[A-Za-zА-Яа-я0-9_]` |	Символы, образующие «слово» (буквы, цифры и символ подчёркивания) |
| `\\W` |	`[^\\w]` |	Символы, не образующие «слово» |
| `\\s` |	`[ \\t\\v\\r\\n\\f]` |	Пробельный символ |
| `\\S` |	`[^\\s]` |	Непробельный символ |


Так называемые символьные классы (или по-другому — POSIX-классы) также используются в регулярных выражениях для обозначения различных групп символов.

|Класс | Эквивалент | Значение|
|----- | ------- | -----|
| `[:upper:]` |	`[A-Z]` |	Символы верхнего регистра |
| `[:lower:]` |	`[a-z]` |	Символы нижнего регистра |
| `[:alpha:]` |	`[[:upper:][:lower:]]` |	Буквы |
| `[:digit:]` |	`[0-9]`, т. е. `\\d`  |	Цифры |
| `[:alnum:]` |	`[[:alpha:][:digit:]]` |	Буквы и цифры |
| `[:word:]` 	| `[[:alnum:]_]`, т. е. `\\w` |	Символы, образующие "слово" |
| `[:punct:]` |	`[!"#$%&'()*+,\-./:;<=>?@[\]^_{|}~]` |	Знаки пунктуации |
| `[:blank:]` |	`[\\s\\t]` |	Пробел и табуляция |
| `[:space:]` |	`[[:blank:]\\v\\r\\n\\f]`, т. е. `\\s` |	Пробельные символы |
|`[:cntrl:]` |	 |	Управляющие символы (перевод строки, табуляция и т.п.) |
| `[:graph:]` |	 |	Печатные символы |
| `[:print:]` |	 |	Печатные символы с пробелом |


## `str_split()`, `boundary()`, классы

Функция `str_split()` разбивает одну строку на несколько и возвращает список. Чтобы получить вектор, используйте ее с  `unlist()` или замените на `str_split_1()`:

```{r}
str_split_1(pp, pattern = "Chapter \\d+") |> 
  length()
```

Всего в романе 61 глава, но у нас получилось 62 элемента вместе с названием. В качестве шаблона мы использовали сочетание `"Chapter \\d+"`, где `\\d+` - это класс цифр (`\\d`) и квантификатор (`+`). Все вместе означает "одна или больше цифр". Это можно записать иначе:

```{r}
str_split_1(pp, pattern = "Chapter [0-9]+") |> 
  length()
```

Разобьем первое предложение на слова, используя предопределенный класс пробельных символов.

```{r}
str_split_1(opening, "[[:space:]]") 
```

Классы можно комбинировать и сочетать с квантификаторами. 

```{r}
str_split_1(opening, "[[:space:][:punct:]]+") 
```
Делить на слова можно и без регулярных выражений. 

```{r}
str_split_1(opening, boundary("word"))
```
С предложениями так просто разобраться не получиться из-за сокращений Mr. и Mrs.

```{r}
str_split_1(pp, boundary("sentence")) |> 
  head()
```
Попробуем решить эту проблему при помощи замены. Но сначала узнаем кое-что о точке, которую нам предстоит заменить.

## Метасимволы и экранирование

Все метасимволы представлены в таблице ниже.

| Описание |	Символ |
| ---------| --------| 
|открывающая квадратная скобка |	`[` |
|закрывающая квадратная скобка |	`]` |
|обратная косая черта |	`\` |
|карет |	`^` |
|знак доллара |	`$` |
|точка |	`.` |
|вертикальная черта |	`|` |
|знак вопроса |	`?` |
|астериск |	`*` |
|плюс |	`+` |
|открывающая фигурная скобка |	`{` |
|закрывающая фигурная скобка |	`}` |
|открывающая круглая скобка |	`(` |
|закрывающая круглая скобка	| `)` |

Квадратные скобки используются для создания классов, карет и знак доллара -- это _якоря_ (см. далее), но карет внутри квадратных скобок может также быть отрицанием. Точка -- это любой знак, "джокер". 

Если необходимо найти буквальную точку, буквальный знак вопроса и т.п., то используется экранирование: перед знаком ставится косая черта. Но так как сама косая черта -- это метасимвол, но нужно две косые черты, первая из которых экранирует вторую.


## `str_replace()`, `str_replace_all()`

Испытаем функции `str_replace()` и `str_replace_all()` на одном предложении. Обратите внимание на кавычки: двойные можно использовать внутри одинарных (и наоборот).

```{r}
dialogue <- c('"My dear Mr. Bennet," said his lady to him one day, "have you heard that Netherfield Park is let at last?" Mr. Bennet replied that he had not. "But it is," returned she; "for Mrs. Long has just been here, and she told me all about it."')

str_replace_all(dialogue, "Mr\\.", "Mr") |> 
  str_split_1(boundary("sentence"))
```
Мы не убрали точку после сокращения Mrs, поэтому последнее предложение разделилось на два. Используем круглые скобки для группировки и оператор "или". Третий аргумент означает, что мы оставляем первую группу, остальное отбрасываем.

```{r}
str_replace_all(dialogue, "(Mr|Mrs)\\.", "\\1") 
```
Прежде чем проделать такую замену для всего текста, проверим, нет ли там других подобных сокращений. Нам надо найти все последовательности символов, образующих слово, до точки, и посчитать частотность. Для этого понадобятся квантификаторы.

## Квантификаторы

Квантификатор после символа, символьного класса или группы определяет, сколько раз предшествующее выражение может встречаться. Квантификатор может относиться более чем к одному символу в регулярном выражении, только если это символьный класс или группа.

| Представление |	Число повторений |	Эквивалент |	
| --------------| -----------------| ------------| 
| `?` 	| ноль или одно |	`{0,1}` 	|
| `*` 	| ноль или более |	`{0,}` 	|
| `+` 	| одно или более |	`{1,}` 	|


Точное число повторений (интервал) можно задать в фигурных скобках:

| Представление |	Число повторений 	|
| ------------- | ----------------  |
| `{n}` |	ровно n раз 	|
| `{m,n}` |	от m до n включительно 	|
| `{m,}` |	не менее m 	|
| `{,n}` |	не более n |

Часто используется последовательность `.*` для обозначения любого количества любых символов между двумя частями регулярного выражения. Попробуем найти символы между прописной буквой и знаком препинания.

```{r}
str_view(dialogue, "[A-Z].+[[:punct:]]")
```

По умолчанию квантификаторам соответствует максимально длинная строка из возможных: квантификаторы являются жадными (greedy). Чтобы этого избежать, надо поставить после квантификатора знак вопроса. Это сделает его ленивым.

| regex |	значение |
| ------ | -------- |
| `??` |	0 или 1, лучше 0 |
| `*?` | 	0 или больше, как можно меньше |
| `+?` |  1 или больше, как можно меньше |
| `{n,m}?` |	от n до m, как можно меньше |


```{r}
str_view(dialogue, "[A-Z].+?[[:punct:]]")
```
Сокращения больше трех букв вряд ли встретятся, поэтому можем уточнить код.

```{r}
pattern <- "[A-Z].{1,2}?\\."
str_view(dialogue, pattern)
```

## Наблюдающие конструкции

В нашем тексте иногда встречается написание имен прописными буквами, в первую очередь в письмах. 

```{r}
letter <- "I shall write again as soon as anything more is determined on. Yours, etc., EDW. GARDINER."

str_view(letter, pattern)
```


Исключим те случаи, когда перед паттерном нет пробела. 

| regex           | значение                                                                       |
|-----------------|--------------------------------------------------------------------------------|
| `(?=...)`       | Положительный просмотр вперёд: далее должно идти ...                       |
| `(?!...)`       | Отрицательный просмотр вперёд: далее не должно идти ...                    |
| `(?<=...)`      | Положительный просмотр назад: перед этим должно быть ...                   |
| `(?<!...)`      | Отрицательный просмотр назад: перед этим не должно быть ...                |


Внутри скобок вместо троеточий (`...`) пишется нужное регулярное выражение.

```{r}
pattern <- "(?<![A-Z])[A-Z].{1,2}?\\."
str_view(letter, pattern)
```

Снова поправим: вместо любого символа после прописной ищем только строчные.

```{r}
pattern <- "(?<![A-Z])[A-Z][a-z]{1,2}?\\."
str_view(letter, pattern)
```

```{r}
str_view(dialogue, pattern)
```

## `str_extract()`, `str_match()`

Функция `str_extract()` ищет совпадения и возвращает только первое вхождение,  `str_extract_all()` возвращает все. Функция `str_match()` работает похожим образом, но возвращает матрицу.


```{r}
abbreviations <- str_extract_all(pp, pattern) |> 
  unlist() |> 
  table() |> 
  sort(decreasing = TRUE)

abbreviations
```

Теперь можно удалить точки из подобных сокращений.

```{r}
pattern <- abbreviations[-5] |> 
  names() |> 
  str_remove("\\.") |> 
  str_c(collapse = "|")

pattern <- str_c("(", pattern, ")\\.")
pattern
```

```{r}
pp_new <- str_replace_all(pp, pattern, "\\1")
```

Теперь разделим текст на предложения и сохраним их в тиббл. 

```{r}
pp_tbl <- tibble(text = str_split_1(pp_new, boundary("sentence")))
pp_tbl
```

Немного приберемся в таблице: удалим подчеркивания (они соответствуют курсиву) и кавычки. 

```{r}
pp_tbl <- pp_tbl |> 
  mutate(text = str_remove_all(text, "_"),
         text = str_remove_all(text, '\\"'))
```

## `str_detect()`, `str_which()`, `str_subset()`

Для поиска совпадений используются три функции: `str_detect()`, `str_which()` и `str_subset()`. Первая возвращает логический вектор (то есть вектор значений `TRUE` / `FALSE`); вторая - индексы элементов, а третья - сами эти элементы. 

Добавим столбец с номером главы и удалим  "Chapter ..." из текста.

```{r}
pp_tbl <- pp_tbl |> 
  mutate(chapter_nr = cumsum(str_detect(text, "Chapter \\d+"))) |> 
  mutate(text = str_remove(text, "Chapter \\d+"))

pp_tbl
```

## Раз Дарси, два Дарси...

Сколько раз в каждой главе упоминается мистер Дарси?

```{r}
darcy_tbl <- pp_tbl |> 
  mutate(n = str_count(text, "(Mr )?Darcy")) |> 
  group_by(chapter_nr) |> 
  summarise(Darcy = sum(n))

darcy_tbl
```

Посчитаем то же для Элизабет ("мисс Беннет" не считаем, их слишком много).

```{r}
liz_tbl <- pp_tbl |> 
  mutate(n = str_count(text, "Elizabeth")) |> 
  group_by(chapter_nr) |> 
  summarise(Elizabeth = sum(n))

liz_tbl
```

Построим импровизированный таймлайн.

```{r message=FALSE}
darcy_tbl |> 
  left_join(liz_tbl) |> 
  pivot_longer(-chapter_nr, values_to = "n") |> 
  ggplot(aes(chapter_nr, n, color = name)) +
  geom_step(linewidth = 1.2, alpha = 0.7) +
  theme_light() + 
  scale_color_manual(values = c("royalblue", "pink"))
```

Симметрия - признак мастерства!

## `str_to_upper()` и `str_to_lower()`

Функции `str_to_upper()` и `str_to_lower()` меняют начертание с прописного на строчное или наоборот.

```{r}
pp_tbl |> 
  mutate(text = str_to_lower(text)) |> 
  mutate(n = str_count(text, "married")) |> 
  group_by(chapter_nr) |> 
  summarise(married = sum(n)) |> 
  arrange(-married)
```

Больше всего шума из-за замужества Лидии в главе 49!

## Якоря и отрицания

Якоря позволяют искать последовательности символов в начале или в конце строки. Знак `^` (вне квадратных скобок!) означает начало строки, а знак `$` -- конец. Мнемоническое правило: First you get the power (^) and then you get the money ($).

Какие предложения начинаются с Dear...?

```{r}
pp_tbl |> 
  filter(str_detect(text, "^Dear"))
```

Какие предложения _не_ заканчиваются точкой? 

```{r}
pp_tbl |> 
  mutate(text = str_squish(text)) |> 
  filter(!str_detect(text, "\\.$"))
```


## Упражнения

- [ ] В пакете `stringr` есть небольшой датасет `words`. Найдите все слова с последовательностью символов wh.  Сколько слов содержат два гласных после w?

- [ ] Найдите все слова в `words`, которые заканчиваются на x. Найдите все слова, которые начинаются на b или на g.

- [ ] Найдите все слова в `words`, в которых за w следует согласный. 

- [ ] Замените всю пунктуацию в строке "tomorrow?and-tomorrow_and!tomorrow" на пробелы.

- [ ] Найдите все слова в `words`, в которых есть любые два символа между b и k.

- [ ] Дана строка "tomorrow (and) tomorrow (and) tomorrow". Необходимо удалить первые скобки с их содержанием. 

- [ ] Найдите в "Гордости и предубеждении" все предложения, где есть to, и выберите следующее за этим слово. Узнайте, сколько всего уникальных сочетаний.

- [ ] Создайте тиббл с двумя столбцами: `letters` и `numbers` (1-26). Преобразуйте, чтобы в третьем столбце появился результат соединения первых двух через подчеркивание, например `a_1`. Отфильтруйте, чтобы остались только ряды, где есть цифра `3` или буква `x`.

- [ ] Дана библиографическая запись: Ast, Friedrich. 1816. Platon’s Leben und Schriften. Leipzig, Weidmann. Используя регулярные выражения, замените полное имя на инициал. Запятую перед инициалом удалите.  Уберите название издательства. Год поставьте в круглые скобки.















