# Начало работы

```{r}
#| include: false

library(tidyverse)
library(checkdown)
```

## Установка R и RStudio

Мы будем использовать R, так что для занятий понадобятся:

- R
    - [на Windows](https://cran.r-project.org/bin/windows/base/)
    - [на Mac](https://cran.r-project.org/bin/macosx/)
    - [на Linux](https://cran.rstudio.com/bin/linux/).

- RStudio --- IDE для R ([можно скачать здесь](https://www.rstudio.com/products/rstudio/download/))

Мы будем использовать следующую версию R:

```{r}
#| echo: false

sessionInfo()$R.version$version.string |> cat()
```

Некоторые люди не любят устанавливать лишние программы себе на компьютер, несколько вариантов есть и для них:

- [RStudio cloud](https://posit.cloud/) --- полная функциональность RStudio с некоторыми ограничениями;
- [webR REPL](https://webr.r-wasm.org/latest/) --- ограниченная версия компилятора R, которая работает в вашем браузере и не требует никаких установок на компьютер
- [Jupyter](https://jupyter.org/) ноутбуки;
- [Google Colab](https://colab.research.google.com) (нужно в настройках переключить ядро);
- [VS Code](https://code.visualstudio.com/) --- другое IDE, которое также позволяет работать с R;
- в принципе, в IDE нет нужды, можно работать из терминала, после установки, нужно всего лишь набрать `R`.

## Знакомство с RStudio

`RStudio` --- основная среда разработки (IDE) для R. После установки R и RStudio можно открыть RStudio и перед вами предстанет что-то похожее на изображение ниже:

![RStudio при первом открытии](./images/01_rstudio_initial_view.png) 

После нажатия на двойное окошко чуть левее надписи Environment откроется окно скрипта.

![Подокна RStudio](./images/02_rstudio_initial_view.png)

Все следующие команды можно: 

- вводить в окне консоли, и тогда для исполнения следует нажимать клавишу `Enter`.
- вводить в окне скрипта, и тогда для исполнения следует нажимать клавиши `Ctrl/Cmd + Enter` или на команду Run на панели окна скрипта. Все, что введено в окне скрипта можно редактировать как в любом текстовом редакторе, в том числе сохранять `Ctrl/Cmd + S`.

Для начала попробуйте получить информацию о сессии, введя в консоли такую команду:

```{r eval=FALSE}
sessionInfo()
```

`sessionInfo()` -- это функция. О функциях можно думать как о глаголах ("сделай то-то!"). За названием функции всегда следуют круглые скобки, внутри которых могут находиться аргументы функции. Аргументы -- это что-то вроде дополнений и обстоятельств. Аргументы могут быть обязательные и необязательные. Чтобы узнать, каких аргументов требует функция, надо вызывать help: `?mean()`. В правой нижней панели появится техническая документация. Но также можно воспользоваться функцией `args()`. Попробуйте набрать в консоли `args(round)`.


:::{.callout-tip icon=false}
Сколько аргументов функции `round()` имеют значения по умолчанию?
:::

```{r results='asis', echo=F}
check_question(answer = 1, right = "Все верно!", wrong = "Не совсем. Значения по умолчанию стоят после знака `=`", button_label = "Проверить")
```


## Пакеты

После установки R вы получите доступ к уже готовым методам статистического анализа и инструментам для визуализации. Если в базовой инсталляции R нет нужного решения -- надо поискать в библиотеке пакетов. Пакет -- это набор функций и иногда датасетов, созданный пользователями. На 1 июля 2023 г. в репозитории [CRAN](https://cran.r-project.org/web/packages/) доступно 19789 пакетов. И это далеко не все: многие пакеты доступны только на GitHub.

:::{.callout-note icon=false}
Некоторые функции, которые вы найдете в пакетах, частично дублируют друг друга -- это нормально, как и в естественном языке, "сказать" что-то можно разными способами.
:::

По технической документации и так называемым "виньеткам" можно понять, какой пакет вам нужен. Например, вот так выглядит [виньетка](https://docs.ropensci.org/rperseus/articles/rperseus-vignette.html) пакета `RPerseus`, при помощи которого можно получить доступ к корпусу греческой и латинской литературы.

Бывают еще "пакеты пакетов", то есть очень большие семейства функций, своего рода "диалекты" R. Таково семейство `tidyverse`, объединяемое идеологией "опрятных" данных. Про него мы еще будем говорить.

Пакеты для работы устанавливаются один раз, однако подключать их надо во время каждой сессии. Чтобы установить новый пакет, можно воспользоваться меню `Tools > Install Packages`. Также можно устанавливать пакеты из консоли. Установим пакет с интерактивными уроками программирования на языке R:

```{r eval=FALSE}
install.packages("swirl")
```

Для подключения используем функцию `library()`, которой передаем в качестве аргумента название пакета без кавычек:

```{r eval=FALSE}
library(swirl)
```

## Рабочая директория

Перед началом работы проверьте свою рабочую директорию при помощи `getwd()`. Для смены можно использовать как **абсолютный**, так и **относительный** путь:

```{r eval=FALSE}
setwd("/Users/name/folder")

# искать в текущей директории
setwd("./folder")

# перейти на уровень вверх
setwd("../")
```

Также для выбора рабочей директории можно использовать меню R `Session > Set Working Directory`. А теперь -- первое задание. 

:::{.callout-warning icon=false}
Установите курс программирования на R: `install_course("R Programming")`. После этого привяжите пакет командой `library(swirl)` и наберите: `swirl()`. Укажите ваше имя. Пройдите урок  2 `Workspace and Files`.
:::

</br>
После выполнения ответьте на несколько вопросов на закрепление материала. 

::::{.callout-tip icon=false}
Какие действия в рабочей директории можно совершать из консоли?
::::

```{r results='asis', echo=F}
check_question(answer = c("создать директорию", "удалить директорию", "создать файл", "переименовать файл", "копировать файл", "удалить файл"), 
options = c("создать директорию", "удалить директорию", "создать файл", "переименовать файл", "копировать файл", "удалить файл"), 
type = "checkbox", 
right = "Все возможно в дивном мире R!", 
wrong = "Чего-то не хватает...",
button = "Проверить")
```

::::{.callout-tip icon=false}
Чтобы создать вложенную директорию при помощи функции `dir.create()`, аргументу `recursive` следует задать значение...
::::

```{r results='asis', echo=F}
check_question("TRUE", options = c("TRUE", "FALSE"), right = "Гениально!", wrong = "Подсказка: рекурсия — это определение, описание, изображение какого-либо объекта или процесса внутри самого этого объекта или процесса", type = "select", button = "Проверить")
```

Если все получилось, двигаемся дальше.

## R как калькулятор

Можно использовать R как калькулятор. Для этого вводим данные рядом с символом приглашения `>`, который называется prompt.

```{r}
sqrt(4) # квадратный корень
2^3 # степень
log10(100) #логарифм
```

Если в начале консольной строки стоит `+`, значит предыдущий код не завершен. Например, вы забыли закрыть скобку функции. Ее можно дописать на следующей строке. Попробуйте набрать `sqrt(2` в консоли.

## Операторы присваивания

Чтобы в окружении появился новый объект, надо присвоить результат вычислений какой-нибудь переменной при помощи оператора присваивания `<-` (`Alt` + `-` (Windows) или `Option` + `-` (Mac)). Знак `=` также работает как оператор присваивания, но не во всех контекстах, поэтому им лучше не пользоваться.

```{r}
x <- 2 + 2 # создаем переменную
y <- 0.1 # создаем еще одну переменную
x <- y # переназначаем  
x + y
```

Сочетание клавиш для оператора присваивания: `Option/Alt + -`. Имя переменной, как и имя функции, может содержать прописные и строчные буквы, точку и знак подчеркивания.

Теперь небольшое упражнение.

:::{.callout-warning icon=false}
Запустите `swirl()`. Укажите ваше имя. Пройдите урок 1 `Basic Building Blocks`. 
:::

Если все получилось, можно двигаться дальше! Но сначала зафиксируем несколько новых функций из этих первого урока. 

:::{.callout-tip icon=false}
Что вычисляет функция `abs()`?
:::

```{r results='asis', echo=F}
check_question("модуль", options = c("среднее", "модуль", "квадратный корень"), type = "radio", right = "Все верно!", wrong = "Не совсем", button = "Проверить")
```

:::{.callout-tip icon=false}
Сколько значений вернет функция, если разделить `c(2, 4, 6)` на `2`?
:::

```{r results='asis', echo=F}
check_question(answer = 3, right = "Все верно!", wrong = "Не совсем", button = "Проверить")
```

:::{.callout-tip icon=false}
Буква "c" в названии функции `c()` означает...
:::

```{r results='asis', echo=F}
check_question("concatenate", options = c("cover", "collapse", "concatenate"), type = "radio", right = "Все верно!", wrong = "Не совсем", button = "Проверить")
```

## Пайпы (конвееры)

В нашем коде мы часто будем использовать знаки конвеера (или пайпы): `|>` (в вашей версии он может выглядить иначе: `%>%`; переключить оператор можно в `Global Options`). Они призваны показывать последовательность действий. Сочетание клавиш: `Ctrl/Cmd + M`.

```{r}
mean(sqrt(abs(sin(1:100))))

1:100 |> 
  sin() |> 
  abs() |> 
  sqrt() |> 
  mean()
```

## Векторы 

Вектор -- это объект, предназначенный для хранения данных. К таким же объектам относятся также матрицы, списки, таблицы данных и др. Заметим, что в языке R нет скаляров (отдельных чисел). Числа считаются векторами из одного элемента.

```{r}
x <- 2
class(x) # числовой вектор
length(x) # длина вектора
```

Как вы уже поняли, функция `c()` позволяет собрать несколько элементов в единый вектор:

```{r}
x <- c(3, 5, 7)
x_mean <- mean(x) 
x_mean
```


</br>
Над векторами можно совершать арифметические операции, но будьте внимательны, применяя операции к векторам разной длины: в этом случае более короткий вектор будет переработан, то есть повторен до тех пор, пока его длина не сравняется с длиной вектора большей длины.

```{r}
x <- 2
y <- c(10, 20, 30)
y / x 
x + y 
```

Векторы можно индексировать, то есть забирать из них какие-то элементы:

```{r}
x <- seq(1, 5, 0.5)
x[4:5] # индексы начинаются с 1 (в отличие от Python)
```


Вектор может хранить данные разных типов:

-   целое число (integer);
-   число с плавающей точкой (numeric, также называются double, то есть число двойной точности);
-   строку (character);
-   логическую переменную (logical);
-   категориальную переменную, или фактор (factor).

```{r}
# проверить тип данных 
x <- sqrt(2)
class(x)
is.integer(x)
is.numeric(x)
```

Создавать векторы можно не только при помощи `c()`. Вот еще два способа.

```{r}
seq(1, 5, 0.5)
rep("foo", 5)
```

Научиться генерировать векторы поможет небольшое упражнение.

::::{.callout-warning icon=false}
Запустите `swirl()` и пройдите урок 3 `Sequences of Numbers`.
::::

Проверьте свои знания, прежде чем двигаться дальше.

:::{.callout-tip icon=false}
Какие числа вернет команда `pi:10`?
:::

```{r results='asis', echo=F}
check_question("вещественные", options = c("натуральные", "целые", "рациональные", "вещественные", "комплексные"), type = "radio", right = "Все верно!", wrong = "Не совсем", button = "Проверить")
```


:::{.callout-tip icon=false}
Какие функции могут использоваться для создания _символьных_ векторов?
:::

```{r results='asis', echo=F}
check_question(c("c()", "rep()"), options = c("seq()", "rep()", "c()"), type = "checkbox", right = "Ну это же просто фантастика!", wrong = "Не совсем", button = "Проверить")
```

::::{.callout-tip icon=false}
Сколько значений вернет команда `rep(c(0, 1, 2), times = 10)`? Посчитайте в уме, не выполняя код.
::::

```{r results='asis', echo=F}
check_question(answer =  30, right = "Ах, красота!", wrong = "Надо бы пересчитать", button = "Проверить")
```

</br>
Факторы внешне похожи на строки, но в отличие от них хранят информацию об *уровнях* категориальных переменных. Уровень может обозначаться как числом (например, 1 и 0), так и строкой.

```{r}
t <- factor(c("A", "B", "C"), levels = c("A", "B", "C"))
t
```

Важно: вектор может хранить данные только одного типа. При попытке объединить в единый вектор данные разных типов они будут принудительно _приведены_ к одному типу:

```{r}
x <- c(TRUE, 1, 3, FALSE)
x # логические значения приведены к числовым

y <- c(1, "a", 2, "лукоморье") 
y # числа превратились в строки
```

::::{.callout-warning icon=false}
Запустите `swirl()` и пройдите урок  4 `Vectors`. Это позволит больше узнать про логические и символьные векторы.
::::

Несколько вопросов для самопроверки.

::::{.callout-tip icon=false}
Какие значение вернет команда `(3 > 5) & (4 == 4)`?
::::

```{r results='asis', echo=F}
check_question("FALSE", options = c("TRUE", "FALSE", "NA"), type = "select", right = "Железная логика!", wrong = "Одно из условий невыполнимо", button = "Проверить")
```

::::{.callout-tip icon=false}
Какие значения вернет команда `(TRUE == TRUE) | (TRUE == FALSE)`?
::::

```{r results='asis', echo=F}
check_question("TRUE", type = "select", options = c("TRUE", "FALSE", "NA"), right = "Восхищаемся вами", wrong = "Это дизъюнкция...", button = "Проверить")
```

::::{.callout-tip icon=false}
Команда `paste(LETTERS, 1:4, sep = "-")` вернет...
::::

```{r results='asis', echo=F}
check_question("символьный вектор длиной 26", 
               options = c("числовой вектор длиной 26", "символьный вектор длиной 26", "числовой вектор длиной 4", "символьный вектор длиной 4", "ошибку"),
               right = "Гениально💡", 
               wrong = "Не совсем",
               type = "radio", 
button = "Проверить")
```


</br>
Логические векторы можно получить в результате применения логических операторов (`==` "равно", `!=` "не равно", `<=` "меньше или равно") к данным других типов:

```{r}
x <- c(1:10) # числа от 1 до 10
y <- x > 5
y # значения TRUE соответствуют единице, поэтому их можно складывать
sum(y)
```

</br>

::::{.callout-warning icon=false}
Здесь можно запустить `swirl()` и пройти урок  8 `Logic`. Это не обязательно, но очень полезно, если хотите разобраться в операторах! 
::::

</br>

::::{.callout-tip icon=false}
Попробуйте посчитать в уме: какое из выражений ниже вернет значение `TRUE`?
::::

```{r results='asis', echo=F}
check_question(answer = "-6 > -7", type = "radio", right = "Восторг!", wrong = "Посмотрите внимательнее.", options = c("7 == 9", "!(57 != 8)", "9 >= 10", "-6 > -7"), button = "Проверить")
```

Функции `all()` и `any()` также возвращают логические значения:

```{r}
x <- 10:20 
any(x == 15)
all(x > 9)
```

Отсутствие данных любого типа в R передается двумя способами. `NULL` означает, что значение не существует. Например, если мы создадим пустой вектор, то при попытке распечатать его получим `NULL`. А вот длина пустого вектора равна нулю! 

```{r}
y <- c() 
y 
length(y) 
```

`NA` (not available) указывает на то, что значение существует, но оно неизвестно. Любые операции с `NA` приводят к появлению новых `NA`! Сравните:

```{r}
x <- c(1, NA, 2)
mean(x)

y <- c(1, NULL, 2)
mean(y)
```

Как проверить, есть ли в данных `NA` или `NULL`? Знак `==` здесь не подойдет. 

```{r}
x <- NA
x == NA

y <- NULL
y == NULL
```

Для этого есть специальные функции. 

```{r}
is.na(x)
is.null(y)
```


> When some people first get to R, they spend a lot of time trying to get rid of NAs. People probably did the same sort of thing when zero was invented. NA is a wonderful thing to have available to you. It is seldom pleasant when your data have missing values, but life if much better with NA than without.
>
> @burns2012r

Как избавиться от NA? В некоторых случаях достаточно аргумента функции.

```{r}
mean(c(1, NA, 2), na.rm=T) 
```

Чуть более сложные способы вы узнаете из урока `swirl` ниже.

::::{.callout-warning icon=false}
Запустите `swirl()` и пройдите урок 5 `Missing Values`.
::::

Готово? Тогда попробуйте ответить на вопрос ниже, не выполняя вычислений в R.

::::{.callout-tip icon=false}
Дан вектор `x <- c(44, NA, 5, NA)`.  Сколько `NA` вернет команда `x == NA`?
::::

```{r echo=F, results='asis'}
check_question(answer =  4, right = "Красота!", wrong = "Надо еще подумать", button = "Проверить")
```

</br> 


::::{.callout-warning icon=false}
Запустите `swirl()` и пройдите урок 6 `Subsetting Vectors`.
::::

Проверьте, все ли вы поняли из этого урока. 

::::{.callout-tip icon=false}
Если вектор `x` содержит числовые значения и некоторое количество NA, то что вернет команда `x[is.na(x)]`?
::::

```{r results='asis', echo=F}
check_question("вектор всех NA", 
               options = c("вектор длиной 0", "вектор всех NA", "логический вектор", "вектор без NA", "ошибку"),
               right = "Зажигаете! 🔥", 
               wrong = "Надо еще подумать",
               type = "radio", 
button = "Проверить")
```

Что надо изменить в этом коде, чтобы получить все, _кроме_ NA?

## Списки

В отличие от атомарных векторов, списки, или рекурсивные векторы, могут хранить данные разных типов.

```{r}
list = list(a = c("a", "b", "c"), b = c(1, 2, 3), c = c(T, F, T))
list
```

Можно получить доступ как к элементам списка целиком, так и к их содержимому.

```{r}
list$a # обращение к поименованным элементам 

list[2] # одинарные квадратные скобки извлекают элемент списка целиком
class(list[2])

list[[2]] #  элементы второго элемента 
class(list[[2]])

list$c[1]# первый элемент второго элемента
```

Обратите внимание, что `list[2]` и `list[[2]]` возвращают объекты разных классов. Нам это еще понадобится при работе с XML.

![_Индексирование списка в R_. [Источник 🧂](https://r4ds.had.co.nz/vectors.html#subsetting-1)](https://d33wubrfki0l68.cloudfront.net/2f3f752cae25018554d484464f117e600ff365a2/37627/diagrams/lists-subsetting.png){width="60%"}

</br>

::::{.callout-warning icon=false}
Установите библиотеку `rcorpora` и загрузите список с названиями хлеба и сладкой выпечки. 
```{}
library(rcorpora)
my_list <-  corpora("foods/breads_and_pastries")
```
::::

</br>

::::{.callout-tip icon=false}
Узнайте длину `my_list` и введите ее в поле ниже.
::::

```{r echo=FALSE, results='asis'}
check_question(answer =  3, right = "Список вкусняшек в вашей власти!", wrong = "Нет, еще не все вкусняшки вы учли", button = "Проверить")
```

::::{.callout-tip icon=false}
Достаньте из `my_list` элемент `pastries` и узнайте его длину.
::::

```{r echo=FALSE, results='asis'}
check_question(answer =  20, right = "Вот вам пончик в награду 🍩", wrong = "Нет, не все вкусняшки вы учли", button = "Проверить")
```

::::{.callout-tip icon=false}
А теперь извлеките пятый элемент из `pastries` и введите ниже его название.
::::

```{r echo=FALSE, results='asis'}
check_question(answer =  "croissant", right = "Все 🥐🥐🥐 ваши!", wrong = "Это я не ем", button = "Проверить")
```

Со списками покончено. Теперь можно пойти выпить кофе с `my_list$pastries[13]`.  Дальше будет сложнее, но интереснее. 
