# Начало работы

```{r}
#| include: false

library(tidyverse)
library(checkdown)
```

## Установка R и RStudio

Мы будем использовать R, так что для занятий понадобятся:

- R
    - [на Windows](https://cran.r-project.org/bin/windows/base/)
    - [на Mac](https://cran.r-project.org/bin/macosx/)
    - [на Linux](https://cran.rstudio.com/bin/linux/).

- RStudio --- IDE для R ([можно скачать здесь](https://www.rstudio.com/products/rstudio/download/))

Мы будем использовать следующую версию R:

```{r}
#| echo: false

sessionInfo()$R.version$version.string |> cat()
```

Некоторые люди не любят устанавливать лишние программы себе на компьютер, несколько вариантов есть и для них:

- [RStudio cloud](https://posit.cloud/) --- полная функциональность RStudio с некоторыми ограничениями;
- [webR REPL](https://webr.r-wasm.org/latest/) --- ограниченная версия компилятора R, которая работает в вашем браузере и не требует никаких установок на компьютер
- [Jupyter](https://jupyter.org/) ноутбуки;
- [Google Colab](https://colab.research.google.com) (нужно в настройках переключить ядро);
- [VS Code](https://code.visualstudio.com/) --- другое IDE, которое также позволяет работать с R;
- в принципе, в IDE нет нужды, можно работать из терминала, после установки, нужно всего лишь набрать `R`.

## Знакомство с RStudio

`RStudio` --- основная среда разработки (IDE) для R. После установки R и RStudio можно открыть RStudio и перед вами предстанет что-то похожее на изображение ниже:

![RStudio при первом открытии](./images/01_rstudio_initial_view.png) 

После нажатия на двойное окошко чуть левее надписи Environment откроется окно скрипта.

![Подокна RStudio](./images/02_rstudio_initial_view.png)

Все следующие команды можно: 

- вводить в окне консоли, и тогда для исполнения следует нажимать клавишу `Enter`.
- вводить в окне скрипта, и тогда для исполнения следует нажимать клавиши `Ctrl/Cmd + Enter` или на команду Run на панели окна скрипта. Все, что введено в окне скрипта можно редактировать как в любом текстовом редакторе, в том числе сохранять `Ctrl/Cmd + S`.

Для начала попробуйте получить информацию о сессии, введя в консоли такую команду:

```{r eval=FALSE}
sessionInfo()
```

`sessionInfo()` -- это функция. За названием функции всегда следуют круглые скобки, внутри которых могут находиться аргументы функции. О функциях можно думать как о глаголах ("сделай то-то!"). Аргументы -- это что-то вроде дополнений и обстоятельств. Аргументы могут быть обязательные и необязательные.

Чтобы узнать, каких аргументов требует функция, надо вызывать help: `?mean()`. Также можно (и нужно) читать техническую документацию к пакетам.

:::{.callout-tip icon=false}
Сколько аргументов функции `round()` имеют значения по умолчанию?
:::

```{r results='asis', echo=F}
check_question(answer = 1, right = "Все верно!", wrong = "Не совсем. Значения по умолчанию стоят после знака `=`", button_label = "Проверить")
```


## Пакеты

После установки R вы получите доступ к уже готовым методам статистического анализа и инструментам для визуализации. Если в базовой инсталляции R нет нужного решения -- надо поискать в библиотеке пакетов. Пакет -- это набор функций и иногда датасетов, созданный пользователями. На 1 июля 2023 г. в репозитории [CRAN](https://cran.r-project.org/web/packages/) доступно 19789 пакетов. И это далеко не все: многие пакеты доступны только на GitHub.

:::{.callout-note icon=false}
Некоторые функции, которые вы найдете в пакетах, частично дублируют друг друга -- это нормально, как и в естественном языке, "сказать" что-то можно разными способами.
:::

По технической документации и так называемым "виньеткам" можно понять, какой пакет вам нужен. Например, вот так выглядит [виньетка](https://docs.ropensci.org/rperseus/articles/rperseus-vignette.html) пакета `RPerseus`, при помощи которого можно получить доступ к корпусу греческой и латинской литературы.

Бывают еще "пакеты пакетов", то есть очень большие семейства функций, своего рода "диалекты" R. Таково, например, семейство `tidyverse`, объединяемое идеологией "опрятных" данных. Про него мы еще будем говорить.

Уточнить свою рабочую директорию (в которой R будет искать и сохранять файлы) можно при помощи функции `getwd()` без аргументов. Установить рабочую директорию можно при помощи функции `setwd()`, указав в качестве аргумента путь к рабочей директории на вашем компьютере (в кавычках, так как это символьный вектор). 

```{r eval=FALSE}
setwd("/Users/Joe/R_Workflow/")
```


Пакеты для работы устанавливаются один раз, однако подключать их надо во время каждой сессии. Чтобы установить новый пакет, можно воспользоваться меню `Tools > Install Packages`. Также можно устанавливать пакеты из консоли. Установим пакет с интерактивными уроками программирования на языке R:

```{r eval=FALSE}
install.packages("swirl")
```

Для подключения используем функцию `library()`, которой передаем в качестве аргумента название пакета без кавычек:

```{r eval=FALSE}
library(swirl)
```


А теперь -- первое задание. 

::::{.сallout-warning icon=false}
Установите курс программирования на R: `install_course("R Programming")`.  После этого привяжите пакет командой `library(swirl)` и выполните следующую команду: `swirl()`. Укажите ваше имя. Пройдите урок  2 `Workspace and Files`.
::::

</br>
После выполнения ответьте на несколько вопросов на закрепление материала. 

::::{.callout-tip icon=false}
Какие действия в рабочей директории можно совершать из консоли?
::::

```{r results='asis', echo=F}
check_question(answer = c("создать директорию", "удалить директорию", "создать файл", "переименовать файл", "копировать файл", "удалить файл"), 
options = c("создать директорию", "удалить директорию", "создать файл", "переименовать файл", "копировать файл", "удалить файл"), 
type = "checkbox", 
right = "Все возможно в дивном мире R!", 
wrong = "Чего-то не хватает...",
button = "Проверить")
```

::::{.callout-tip icon=false}
Чтобы создать вложенную директорию при помощи функции `dir.create()`, аргументу `recursive` следует задать значение...
::::

```{r results='asis', echo=F}
check_question("TRUE", options = c("TRUE", "FALSE"), right = "Гениально!", wrong = "Подсказка: рекурсия — это определение, описание, изображение какого-либо объекта или процесса внутри самого этого объекта или процесса", type = "select", button = "Проверить")
```

Если все получилось, двигаемся дальше.

## R как калькулятор

Можно использовать R как калькулятор. Для этого вводим данные рядом с символом приглашения `>`, который называется prompt.

```{r}
sqrt(4) # квадратный корень
2^3 # степень
log10(100) #логарифм
```

Если в начале консольной строки стоит `+`, значит предыдущий код не завершен. Например, вы забыли закрыть скобку функции. Ее можно дописать на следующей строке. Попробуйте набрать `sqrt(2` в консоли.

## Операторы присваивания

Чтобы в окружении появился новый объект, надо присвоить результат вычислений какой-нибудь переменной при помощи оператора присваивания `<-` (`Alt` + `-` (Windows) или `Option` + `-` (Mac)). Знак `=` также работает как оператор присваивания, но не во всех контекстах, поэтому им лучше не пользоваться.

```{r}
x <- 2 + 2 # создаем переменную
y <- 0.1 # создаем еще одну переменную
x <- y # переназначаем  
x + y
```

Сочетание клавиш для оператора присваивания: `Option/Alt + -`. Имя переменной, как и имя функции, может содержать прописные и строчные буквы, точку и знак подчеркивания.

Теперь небольшое упражнение.

:::{.callout-warning icon=false}
Запустите `swirl()`. Укажите ваше имя. Пройдите урок 1 `Basic Building Blocks`. 
:::

Если все получилось, можно двигаться дальше! Но сначала зафиксируем несколько новых функций из этих первого урока. 

:::{.callout-tip icon=false}
Что вычисляет функция `abs()`?
:::

```{r results='asis', echo=F}
check_question("модуль", options = c("среднее", "модуль", "квадратный корень"), type = "radio", right = "Все верно!", wrong = "Не совсем", button = "Проверить")
```

:::{.callout-tip icon=false}
Сколько значений вернет функция, если разделить `c(2, 4, 6)` на `2`?
:::

```{r results='asis', echo=F}
check_question(answer = 3, right = "Все верно!", wrong = "Не совсем", button = "Проверить")
```

:::{.callout-tip icon=false}
Буква "c" в названии функции `c()` означает...
:::

```{r results='asis', echo=F}
check_question("concatenate", options = c("cover", "collapse", "concatenate"), type = "radio", right = "Все верно!", wrong = "Не совсем", button = "Проверить")
```


## Векторы и матрицы

Вектор -- это объект, предназначенный для хранения данных. К таким же объектам относятся также матрицы, списки, таблицы данных и др. Заметим, что в языке R нет скаляров (отдельных чисел). Числа считаются векторами из одного элемента.

```{r}
x <- 2
class(x) # числовой вектор
length(x) # длина вектора
```

Как вы уже поняли, функция `c()` позволяет собрать несколько элементов в единый вектор:

```{r}
x <- c(3, 5, 7)
x_mean <- mean(x) 
x_mean
```


</br>
Над векторами можно совершать арифметические операции, но будьте внимательны, применяя операции к векторам разной длины: в этом случае более короткий вектор будет переработан, то есть повторен до тех пор, пока его длина не сравняется с длиной вектора большей длины.

```{r}
x <- 2
y <- c(10, 20, 30)
y / x 
x + y 
```

Векторы можно индексировать, то есть забирать из них какие-то элементы:

```{r}
x <- seq(1, 5, 0.5)
x[4:5] # индексы начинаются с 1 (в отличие от Python)
```


::::{.callout-warning icon=false}
Запустите `swirl()` и пройдите урок 6 `Subsetting Vectors`.
::::

Проверьте, все ли вы поняли из этого урока. 

::::{.callout-tip icon=false}
Если вектор `x` содержит числовые значения и некоторое количество NA, то что вернет команда `x[is.na(x)]`?
::::

```{r results='asis', echo=F}
check_question("вектор всех NA", 
               options = c("вектор длиной 0", "вектор всех NA", "логический вектор", "вектор без NA", "ошибку"),
               right = "Зажигаете! 🔥", 
               wrong = "Надо еще подумать",
               type = "radio", 
button = "Проверить")
```

Что надо изменить в этом коде, чтобы получить все, _кроме_ NA?

Матрица -- это вектор, который имеет два дополнительных атрибута: количество строк и количество столбцов. Из этого следует, что матрица, как и вектор, может хранить данные одного типа. Проверим.

```{r}
M = matrix(c(1, 2, 3, 4), nrow = 2)
M # все ок

M = matrix(c(1, 2, 3, "a"), nrow = 2)
M # все превратилось в строку! 
```

В матрице есть ряды и столбцы. Их количество определяет размер (порядок) матрицы. Выше мы создали матрицу 2 x 2. Элементы матрицы, как и элементы вектора, можно извлекать по индексу. Сначала указывается номер ряда (строки), потом номер столбца.

```{r}
M = matrix(c(1, 2, 3, 4), nrow = 2)
M
```

```{r}
M[1, ] # первая строка полностью
M[,2] # второй столбец полностью
M[1,1] # одно значение
```

Обратите внимание, как меняется размерность при индексировании.

```{r}
M = matrix(c(1, 2, 3, 4), nrow = 2)
dim(M) # функция для извлечения измерений

dim(M[1, ]) 
```

Попытка узнать измерения вектора возвращает `NULL`, потому что, с точки зрения R, векторы не являются матрицами из одного столбца или одной строки и потому не имеют измерений. 

И векторы, и матрицы могут хранить данные одного типа -- в отличие от списков и датафреймов. Поэтому, прежде чем к ним перейти, следует сказать о типах данных в R.

## Типы данных

Основные типы данных, с которыми мы будем работать, следующие:

-   целое число (integer)
-   число с плавающей точкой (numeric, также называются double, то есть число двойной точности)
-   строка (character)
-   логическая переменная (logical)
-   категориальная переменная, или фактор (factor)

```{r}
# проверить тип данных 
x <- sqrt(2)
class(x)
is.integer(x)
is.numeric(x)
```

Для начала мы научимся генерировать векторы. Например, так.

```{r}
seq(1, 5, 0.5)
rep("foo", 5)
```

::::{.callout-warning icon=false}
Запустите `swirl()` и пройдите урок 3 `Sequences of Numbers`.
::::

Проверьте свои знания, прежде чем двигаться дальше.

:::{.callout-tip icon=false}
Какие числа вернет команда `pi:10`?
:::

```{r results='asis', echo=F}
check_question("вещественные", options = c("натуральные", "целые", "рациональные", "вещественные", "комплексные"), type = "radio", right = "Все верно!", wrong = "Не совсем", button = "Проверить")
```


:::{.callout-tip icon=false}
Какие функции могут использоваться для создания _символьных_ векторов?
:::

```{r results='asis', echo=F}
check_question(c("c()", "rep()"), options = c("seq()", "rep()", "c()"), type = "checkbox", right = "Ну это же просто фантастика!", wrong = "Не совсем", button = "Проверить")
```

::::{.callout-tip icon=false}
Сколько значений вернет команда `rep(c(0, 1, 2), times = 10)`? Посчитайте в уме, не выполняя код.
::::

```{r results='asis', echo=F}
check_question(answer =  30, right = "Ах, красота!", wrong = "Надо бы пересчитать", button = "Проверить")
```

</br>
Факторы внешне похожи на строки, но в отличие от них хранят информацию об *уровнях* категориальных переменных. Уровень может обозначаться как числом (например, 1 и 0), так и строкой.

```{r}
t <- factor(c("A", "B", "C"), levels = c("A", "B", "C"))
t
```

При попытке объединить в единый вектор данные разных типов они будут принудительно приведены к одному типу:

```{r}
x <- c(TRUE, 1, 3, FALSE)
x # логические значения переработаны в числовые

y <- c(1, "a", 2, "лукоморье") # строки всегда в кавычках
y # числа превратились в строки
```


</br>
Логические векторы можно получить в результате применения логических операторов (`==` "равно", `!=` "не равно", `<=` "меньше или равно") к данным других типов:

```{r}
x <- c(1:10) # числа от 1 до 10
y <- x > 5
y # значения TRUE соответствуют единице, поэтому их можно складывать
sum(y)
```

</br>

::::{.callout-warning icon=false}
Здесь можно запустить `swirl()` и пройти урок  8 `Logic`. Это не обязательно, но очень полезно, если хотите разобраться в операторах! 
::::

</br>

::::{.callout-tip icon=false}
Попробуйте посчитать в уме: какое из выражений ниже вернет значение `TRUE`?
::::

```{r results='asis', echo=F}
check_question(answer = "-6 > -7", type = "radio", right = "Восторг!", wrong = "Посмотрите внимательнее.", options = c("7 == 9", "!(57 != 8)", "9 >= 10", "-6 > -7"), button = "Проверить")
```

Функции `all()` и `any()` также возвращают логические значения:

```{r}
x <- 10:20 
any(x == 15)
all(x > 9)
```

::::{.callout-warning icon=false}
Запустите `swirl()` и пройдите урок  4 `Vectors`. Это позволит больше узнать про логические и символьные векторы.
::::

Несколько вопросов для самопроверки.

::::{.callout-tip icon=false}
Какие значение вернет команда `(3 > 5) & (4 == 4)`?
::::

```{r results='asis', echo=F}
check_question("FALSE", options = c("TRUE", "FALSE", "NA"), type = "select", right = "Железная логика!", wrong = "Одно из условий невыполнимо", button = "Проверить")
```

::::{.callout-tip icon=false}
Какие значения вернет команда `(TRUE == TRUE) | (TRUE == FALSE)`?
::::

```{r results='asis', echo=F}
check_question("TRUE", type = "select", options = c("TRUE", "FALSE", "NA"), right = "Восхищаемся вами", wrong = "Это дизъюнкция...", button = "Проверить")
```

::::{.callout-tip icon=false}
Команда `paste(LETTERS, 1:4, sep = "-")` вернет...
::::

```{r results='asis', echo=F}
check_question("символьный вектор длиной 26", 
               options = c("числовой вектор длиной 26", "символьный вектор длиной 26", "числовой вектор длиной 4", "символьный вектор длиной 4", "ошибку"),
               right = "Гениально💡", 
               wrong = "Не совсем",
               type = "radio", 
button = "Проверить")
```

## Отсутствующие значения

`NULL` означает, что значение не существует. Например, если мы создадим пустой вектор, то при попытке распечатать его получим `NULL`. А вот длина пустого вектора равна нулю! 

```{r}
y <- c() 
y 
length(y) 
```


`NA` (not available) указывает на то, что значение существует, но оно неизвестно. Любые операции с `NA` приводят к появлению новых `NA`! Сравните:

```{r}
x <- c(1, NA, 2)
mean(x)

y <- c(1, NULL, 2)
mean(y)
```
Как проверить, есть ли в данных `NA` или `NULL`? Знак `==`, который вы встречали в уроке `swirl`, здесь не подойдет. 

```{r}
x <- NA
x == NA

y <- NULL
y == NULL
```
Для этого есть специальные функции. 

```{r}
is.na(x)
is.null(y)
```


> When some people first get to R, they spend a lot of time trying to get rid of NAs. People probably did the same sort of thing when zero was invented. NA is a wonderful thing to have available to you. It is seldom pleasant when your data have missing values, but life if much better with NA than without.
>
> @burns2012r

Как избавиться от NA? В некоторых случаях достаточно аргумента функции.

```{r}
mean(c(1, NA, 2), na.rm=T) 
```

Чуть более сложные способы вы узнаете из урока `swirl` ниже.

::::{.callout-warning icon=false}
Запустите `swirl()` и пройдите урок 5 `Missing Values`.
::::

Готово? Тогда попробуйте ответить на вопрос ниже, не выполняя вычислений в R.

::::{.callout-tip icon=false}
Дан вектор `x <- c(44, NA, 5, NA)`.  Сколько `NA` вернет команда `x == NA`?
::::

```{r echo=F, results='asis'}
check_question(answer =  4, right = "Красота!", wrong = "Надо еще подумать", button = "Проверить")
```

</br> 

Теперь мы знакомы с основными типами данных и готовы вернуться к объектам, которые их хранят. После векторов и матриц рассмотрим списки и датафреймы, или таблицы.

## Списки и таблицы

Как уже было сказано, списки, или рекурсивные векторы (в отличие от атомарных векторов), могут хранить данные разных типов.

```{r}
list = list(a = c("a", "b", "c"), b = c(1, 2, 3), c = c(T, F, T))
list
```

Можно получить доступ как к элементам списка целиком, так и к их содержимому.

```{r}
list$a # обращение к поименованным элементам 

list[2] # одинарные квадратные скобки извлекают элемент списка целиком
class(list[2])

list[[2]] #  элементы второго элемента 
class(list[[2]])

list$c[1]# первый элемент второго элемента
```

Обратите внимание, что `list[2]` и `list[[2]]` возвращают объекты разных классов. Нам это еще понадобится при работе с XML.

![_Индексирование списка в R_. [Источник 🧂](https://r4ds.had.co.nz/vectors.html#subsetting-1)](https://d33wubrfki0l68.cloudfront.net/2f3f752cae25018554d484464f117e600ff365a2/37627/diagrams/lists-subsetting.png){width="60%"}

</br>

::::{.callout-warning icon=false}
Установите библиотеку `rcorpora` и загрузите список с названиями хлеба и сладкой выпечки. 
```{}
library(rcorpora)
my_list <-  corpora("foods/breads_and_pastries")
```
::::

</br>

::::{.callout-tip icon=false}
Узнайте длину `my_list` и введите ее в поле ниже.
::::

```{r echo=FALSE, results='asis'}
check_question(answer =  3, right = "Список вкусняшек в вашей власти!", wrong = "Нет, еще не все вкусняшки вы учли", button = "Проверить")
```

::::{.callout-tip icon=false}
Достаньте из `my_list` элемент `pastries` и узнайте его длину.
::::

```{r echo=FALSE, results='asis'}
check_question(answer =  20, right = "Вот вам пончик в награду 🍩", wrong = "Нет, не все вкусняшки вы учли", button = "Проверить")
```


::::{.callout-tip icon=false}
А теперь извлеките пятый элемент из `pastries` и введите ниже его название.
::::

```{r echo=FALSE, results='asis'}
check_question(answer =  "croissant", right = "Все 🥐🥐🥐 ваши!", wrong = "Это я не ем", button = "Проверить")
```

Со списками покончено. Теперь можно пойти выпить кофе с `my_list$pastries[13]`. 

Таблицы (кадры данных, data frames) -- это двумерные объекты (как и матрицы). Датафреймы отличаются от матриц тем, что их столбцы могут хранить данные разного типа.

::::{.callout-note icon=false}
Если списки являются разнородными аналогами векторов в одном измерении, кадры данных являются разнородными аналогами матриц для двумерных данных [@мэтлофф2019, 134].
:::

</br>

```{r}
# создание датафрейма
df <- data.frame(names = c("A", "B"), age = c(10, 11))
df

# извлечение элементов
df$names # забирает весь столбец
df[,"names"] # то же самое, другой способ
df[1, ] # забирает ряд
```

Потренируемся на датасете с данными о гапаксах^[Гапакс -- это слово, которое встречается один раз в корпусе или тексте.] в диалогах Платона. Датасет можно скачать по [ссылке](https://github.com/locusclassicus/text_analysis_2024/raw/main/data/hapax_plato.Rdata). Файл имеет расширение `.Rdata`; щелкнув на него правой кнопкой мыши, можете открыть его сразу в RStudio и потренироваться.

Этот датасет позволяет перепроверить выводы Льюиса Кэмпбелла, профессора Сент-Эндрюсского университета в Шотландии. Еще 1867 г., впервые применив количественный метод для датировки диалогов Платона, он пришел к выводу, что для "позднего" стиля Платона, среди прочего, характерно обилие редкой лексики.

В корпус подлинных диалогов Кэмпбелл включал 26 текстов, которые делил на три хронологические группы. Свои вычисления он делал вручную, а мы можем попробовать все пересчитать в R.

```{r echo = F}
load(file = "../data/hapax_plato.Rdata")
```

```{r}
head(hapax_plato)
```

Вот так выглядят наши данные. Функция `class()` позволяет убедиться, что это датафрейм.

```{r}
class(hapax_plato)
```

Потренируемся работать с данными в таблицах.

```{r}
# узнать имена столбцов
colnames(hapax_plato) 
```
```{r}
# извлечь ряд(ы) по значению
hapax_plato[hapax_plato$dialogue == "Parmenides", ]
```

```{r}
# узнать тип данных в столбцах
str(hapax_plato) 
```

```{r}
# преобразовать тип данных в столбцах
hapax_plato$group <- as.factor(hapax_plato$group)
```


```{r}
# отобрать ряды по количеству слов
hapax_plato[hapax_plato$words > 10000, ]
```


И еще с датафреймами полезна функция `summary()`:

```{r}
summary(hapax_plato)
```

Последнее упражнение на кодинг в этой главе!

::::{.callout-warning icon=false}
Запустите `swirl()` и пройдите урок 7 `Matrices and Data Frames`.
::::


## Пайпы (конвееры)

В нашем коде мы часто будем использовать знаки конвеера (или пайпы): `|>` (в вашей версии он может выглядить иначе: `%>%`; переключить оператор можно в `Global Options`). Они призваны показывать последовательность действий. Сочетание клавиш: `Ctrl/Cmd + M`.

```{r}
mean(sqrt(abs(sin(1:100))))

1:100 |> 
  sin() |> 
  abs() |> 
  sqrt() |> 
  mean()
```

## Практическое задание

Напоследок небольшое практическое задание. Код для его выполнения сохраните в виде файла с расширением `.R`. Его надо будет отправить преподавателю.

</br>

::::{.callout-warning icon=false}
ПРАКТИЧЕСКОЕ ЗАДАНИЕ 1: ИСПАНСКИЕ ПИСАТЕЛИ
::::

</br>

```{r eval=FALSE}
# устанавливаем и загружаем нужный пакет
install.packages("languageR")
library(languageR)

# загружаем датасет
meta <- spanishMeta

# допишите ваш код ниже
# посчитайте средний год публикации романов Камило Хосе Селы


# вычислите суммарное число слов в романах Эдуардо Мендосы


# извлеките ряды с текстами, опубликованными до 1980 г.
```


Поздравляем! С этой главой вы справились. Дальше будет сложнее, но интереснее. 


![](https://media3.giphy.com/media/v1.Y2lkPTc5MGI3NjExMnVtcXF6anpvMnhicXl3a2IzYjNlMm5xcmV1M3B0cXY5ZzdrY24wNyZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/JxzxnP9Bqi532/giphy.webp){width="50%"}
