# Начало работы

```{r}
#| include: false

library(tidyverse)
library(webexercises)
```

```{r eval=FALSE, echo=FALSE}
add_to_quarto(
  quarto_dir = ".",
  include_dir = "include",
  output_format = c("html")
)
```

## Установка R и RStudio

Мы будем использовать R, так что для занятий понадобятся:

- R
    - [на Windows](https://cran.r-project.org/bin/windows/base/)
    - [на Mac](https://cran.r-project.org/bin/macosx/)
    - [на Linux](https://cran.rstudio.com/bin/linux/).

- RStudio --- IDE для R ([можно скачать здесь](https://www.rstudio.com/products/rstudio/download/))

Вместо RStudio можно поставить [VS Code](https://code.visualstudio.com/) или [Positron](https://positron.posit.co/install.html). По сути, Positron -- это тот же VS Code, но без необходимости устанавливать расширения.

Мы будем использовать следующую версию R:

```{r}
#| echo: false

sessionInfo()$R.version$version.string |> cat()
```

Для работы в облаке `r emo::ji("cloud")`  можно использовать [RStudio Cloud](https://posit.cloud/), но в бесплатной версии есть ограничения. 


## Знакомство с RStudio

`RStudio` --- основная среда разработки (IDE) для R. После установки R и RStudio можно открыть RStudio и перед вами предстанет что-то похожее на изображение ниже:

![RStudio при первом открытии](./images/01_rstudio_initial_view.png) 

После нажатия на двойное окошко чуть левее надписи Environment откроется окно скрипта.

![Подокна RStudio](./images/02_rstudio_initial_view.png)

Все следующие команды можно: 

- вводить в окне консоли, и тогда для исполнения следует нажимать клавишу `Enter`.
- вводить в окне скрипта, и тогда для исполнения следует нажимать клавиши `Ctrl/Cmd + Enter` или на команду Run на панели окна скрипта. Все, что введено в окне скрипта можно редактировать как в любом текстовом редакторе, в том числе сохранять `Ctrl/Cmd + S`.

Для начала попробуйте получить информацию о сессии, введя в консоли такую команду:

```{r eval=FALSE}
sessionInfo()
```

`sessionInfo()` -- это функция. О функциях можно думать как о глаголах ("сделай то-то!"). За названием функции всегда следуют круглые скобки, внутри которых могут находиться аргументы функции. Аргументы -- это что-то вроде дополнений и обстоятельств. Аргументы могут быть обязательные и необязательные. Чтобы узнать, каких аргументов требует функция, надо вызывать help: `?mean()`. В правой нижней панели появится техническая документация. Но также можно воспользоваться функцией `args()`. Попробуйте набрать в консоли `args(round)`.


:::{.callout-tip icon=false}
Сколько аргументов функции `round()` имеют значения по умолчанию?
:::

Ответ: `r fitb(1)`


## Пакеты

После установки R вы получите доступ к уже готовым методам статистического анализа и инструментам для визуализации. Если в базовой инсталляции R нет нужного решения -- надо поискать в библиотеке пакетов. Пакет -- это набор функций и иногда датасетов, созданный пользователями. На 1 июля 2023 г. в репозитории [CRAN](https://cran.r-project.org/web/packages/) доступно 19789 пакетов. И это далеко не все: многие пакеты доступны только на GitHub.

:::{.callout-note icon=false}
Некоторые функции, которые вы найдете в пакетах, частично дублируют друг друга -- это нормально, как и в естественном языке, "сказать" что-то можно разными способами.
:::

По технической документации и так называемым "виньеткам" можно понять, какой пакет вам нужен. Например, вот так выглядит [виньетка](https://docs.ropensci.org/rperseus/articles/rperseus-vignette.html) пакета `RPerseus`, при помощи которого можно получить доступ к корпусу греческой и латинской литературы.

Бывают еще "пакеты пакетов", то есть очень большие семейства функций, своего рода "диалекты" R. Таково семейство `tidyverse`, объединяемое идеологией "опрятных" данных. Про него мы еще будем говорить.

Пакеты для работы устанавливаются один раз, однако подключать их надо во время каждой сессии. Чтобы установить новый пакет, можно воспользоваться меню `Tools > Install Packages`. Также можно устанавливать пакеты из консоли. Установим пакет с интерактивными уроками программирования на языке R:

```{r eval=FALSE}
install.packages("swirl")
```

Для подключения используем функцию `library()`, которой передаем в качестве аргумента название пакета без кавычек:

```{r eval=FALSE}
library(swirl)
```

## Рабочая директория

Перед началом работы проверьте свою рабочую директорию при помощи `getwd()`. Для смены можно использовать как **абсолютный**, так и **относительный** путь:

```{r eval=FALSE}
setwd("/Users/name/folder")

# искать в текущей директории
setwd("./folder")

# перейти на уровень вверх
setwd("../")
```

Также для выбора рабочей директории можно использовать меню R `Session > Set Working Directory`.

## R как калькулятор

Можно использовать R как калькулятор. Для этого вводим данные рядом с символом приглашения `>`, который называется prompt.

```{r}
sqrt(4) # квадратный корень
2^3 # степень
log10(100) #логарифм
```

Если в начале консольной строки стоит `+`, значит предыдущий код не завершен. Например, вы забыли закрыть скобку функции. Ее можно дописать на следующей строке. Попробуйте набрать `sqrt(2` в консоли.

## Операторы присваивания

Чтобы в окружении появился новый объект, надо присвоить результат вычислений какой-нибудь переменной при помощи оператора присваивания `<-` (`Alt` + `-` (Windows) или `Option` + `-` (Mac)). Знак `=` также работает как оператор присваивания, но не во всех контекстах, поэтому им лучше не пользоваться.

```{r}
x <- 2 + 2 # создаем переменную
y <- 0.1 # создаем еще одну переменную
x <- y # переназначаем  
x + y
```

Сочетание клавиш для оператора присваивания: `Option/Alt + -`. Имя переменной, как и имя функции, может содержать прописные и строчные буквы, точку и знак подчеркивания.

Теперь небольшое упражнение.

:::{.callout-warning icon=false}
Установите курс программирования на R: `install_course("R Programming")`. После этого привяжите пакет командой `library(swirl)` и наберите: `swirl()`. Укажите ваше имя. Пройдите урок 1 `Basic Building Blocks`. 
:::

Если все получилось, можно двигаться дальше! Но сначала зафиксируем несколько новых функций из этих первого урока. 

:::{.callout-tip icon=false}
Что вычисляет функция `abs()`?
:::

Ответ: `r mcq(c("среднее", answer = "модуль", "квадратный корень"))`


:::{.callout-tip icon=false}
Сколько значений вернет функция, если разделить `c(2, 4, 6)` на `2`?
:::

Ответ: `r fitb(3)`

:::{.callout-tip icon=false}
Буква "c" в названии функции `c()` означает...
:::

Ответ: `r mcq(c("cover", "collapse", answer = "concatenate"))`

## Пайпы (конвееры)

В нашем коде мы часто будем использовать знаки конвеера (или пайпы): `|>` (в вашей версии он может выглядить иначе: `%>%`; переключить оператор можно в `Global Options`). Они призваны показывать последовательность действий. Сочетание клавиш: `Ctrl/Cmd + Shift + M`.

```{r}
mean(sqrt(abs(sin(1:100)))) 

1:100 |> 
  sin() |> 
  abs() |> 
  sqrt() |> 
  mean()
```

## Векторы 

Вектор -- это объект, предназначенный для хранения данных. К таким же объектам относятся также матрицы, списки, датафреймы и др. Заметим, что в языке R нет скаляров (отдельных чисел). Числа считаются векторами из одного элемента.

```{r}
x <- 2
class(x) # числовой вектор
length(x) # длина вектора
```

Как вы уже поняли, функция `c()` позволяет собрать несколько элементов в единый вектор:

```{r}
x <- c(3, 5, 7)
x_mean <- mean(x) 
x_mean
```


</br>
Над векторами можно совершать арифметические операции, но будьте внимательны, применяя операции к векторам разной длины: в этом случае более короткий вектор будет _переработан_, то есть повторен до тех пор, пока его длина не сравняется с длиной вектора большей длины.

```{r}
x <- 2
y <- c(10, 20, 30)
y / x 
x + y 
```

Векторы можно индексировать, то есть забирать из них какие-то элементы:

```{r}
x <- seq(1, 5, 0.5)
x[4:5] # индексы начинаются с 1 (в отличие от Python)
```


Вектор может хранить данные разных типов:

-   целое число (integer);
-   число с плавающей точкой (numeric, также называются double, то есть число двойной точности);
-   строку (character);
-   логическую переменную (logical);
-   категориальную переменную, или фактор (factor).

```{r}
# проверить тип данных 
x <- sqrt(2)
class(x)
is.integer(x)
is.numeric(x)
```

Создавать векторы можно не только при помощи `c()`. Вот еще два способа.

```{r}
seq(1, 5, 0.5)
rep("foo", 5)
```


</br>

Факторы внешне похожи на строки, но в отличие от них хранят информацию об *уровнях* категориальных переменных. Уровень может обозначаться как числом (например, 1 и 0), так и строкой.

```{r}
t <- factor(c("A", "B", "C"), levels = c("A", "B", "C"))
t
```

Важно: вектор может хранить данные только одного типа. При попытке объединить в единый вектор данные разных типов они будут принудительно _приведены_ к одному типу:

```{r}
x <- c(TRUE, 1, 3, FALSE)
x # логические значения приведены к числовым

y <- c(1, "a", 2, "лукоморье") 
y # числа превратились в строки
```


Логические векторы можно получить в результате применения логических операторов (`==` "равно", `!=` "не равно", `<=` "меньше или равно") к данным других типов:

```{r}
x <- 1:10 # числа от 1 до 10
y <- x > 5
y # значения TRUE соответствуют единице, поэтому их можно складывать
sum(y)
```


Функции `all()` и `any()` также возвращают логические значения:

```{r}
x <- 10:20 
any(x == 15)
all(x > 9)
```

## Отсутствие данных

Отсутствие данных любого типа в R передается двумя способами. `NULL` означает, что значение не существует. Например, если мы создадим пустой вектор, то при попытке распечатать его получим `NULL`. А вот длина пустого вектора равна нулю! 

```{r}
y <- c() 
y 
length(y) 
```

`NA` (not available) указывает на то, что значение существует, но оно неизвестно. Любые операции с `NA` приводят к появлению новых `NA`! Сравните:

```{r}
x <- c(1, NA, 2)
mean(x)

y <- c(1, NULL, 2)
mean(y)
```

Как проверить, есть ли в данных `NA` или `NULL`? Знак `==` здесь не подойдет. 

```{r}
x <- NA
x == NA

y <- NULL
y == NULL
```

Для этого есть специальные функции. 

```{r}
is.na(x)
is.null(y)
```


> When some people first get to R, they spend a lot of time trying to get rid of NAs. People probably did the same sort of thing when zero was invented. NA is a wonderful thing to have available to you. It is seldom pleasant when your data have missing values, but life if much better with NA than without.
>
> @burns2012r

Как избавиться от NA? В некоторых случаях достаточно аргумента функции.

```{r}
mean(c(1, NA, 2), na.rm=T) 
```

## Списки

В отличие от векторов списки могут хранить данные разных типов.

```{r}
my_list <-  list(
  a = c("a", "b", "c"), 
  b = c(1, 2, 3), 
  c = c(TRUE, FALSE, TRUE)
  )

my_list
```

Можно получить доступ как к элементам списка целиком, так и к их содержимому.

```{r}
my_list$a # обращение к поименованным элементам 

my_list[2] # одинарные квадратные скобки извлекают элемент списка целиком
class(my_list[2])

my_list[[2]] #  элементы второго элемента 
class(my_list[[2]])

my_list$c[1]# первый элемент второго элемента
```

Обратите внимание, что `my_list[2]` и `my_list[[2]]` возвращают объекты разных классов. Нам это еще понадобится при работе с XML.

</br>

::::{.callout-warning icon=false}
Установите библиотеку `rcorpora` и загрузите список с названиями хлеба и сладкой выпечки. 
```{}
library(rcorpora)
my_list <-  corpora("foods/breads_and_pastries")
```
::::

</br>

::::{.callout-tip icon=false}
Узнайте длину `my_list` и введите ее в поле ниже.
::::

Ответ: `r fitb(3)`

::::{.callout-tip icon=false}
Достаньте из `my_list` элемент `pastries` и узнайте его длину.
::::

Ответ: `r fitb(20)`

::::{.callout-tip icon=false}
А теперь извлеките пятый элемент из `pastries` и введите ниже его название.
::::

Ответ: `r fitb("croissant")` 

Со списками покончено. Теперь можно пойти выпить кофе с `my_list$pastries[13]`.  Дальше будет сложнее, но интереснее. 


## Матрицы

Матрица -- это вектор, который имеет два дополнительных атрибута: количество строк и количество столбцов. Из этого следует, что матрица, как и вектор, может хранить данные одного типа. Проверим.

```{r}
M = matrix(c(1, 2, 3, 4), nrow = 2)
M # все ок

M = matrix(c(1, 2, 3, "a"), nrow = 2)
M # все превратилось в строку! 
```

В матрице есть ряды и столбцы. Их количество определяет размер (порядок) матрицы. Выше мы создали матрицу 2 x 2. Элементы матрицы, как и элементы вектора, можно извлекать по индексу. Сначала указывается номер ряда (строки), потом номер столбца.

```{r}
M = matrix(c(1, 2, 3, 4), nrow = 2)
M
```

```{r}
M[1, ] # первая строка полностью
M[,2] # второй столбец полностью
M[1,1] # одно значение
```

Обратите внимание, как меняется размерность при индексировании.

```{r}
M = matrix(c(1, 2, 3, 4), nrow = 2)
dim(M) # функция для извлечения измерений

dim(M[1, ]) 
```

Попытка узнать измерения вектора возвращает `NULL`, потому что, с точки зрения R, векторы не являются матрицами из одного столбца или одной строки и потому не имеют измерений. 


## Таблицы (датафреймы)

Если матрица -- это двумерный аналог вектора, то таблица (кадр данных, data frame) -- это двумерный аналог списка. Как и список, датафрейм может хранить данные разного типа. 

```{r}
# создание датафрейма
df <- data.frame(
  names = c("John", "Mary"), 
  age = c(18, 25), 
  sport = c("basketball", "tennis")
  )

df |> 
  print()
```

Для извлечения данных можем использовать индексы или имена переменных. 

```{r}
df$names # или df[,"names"] 
df[1, ]  |> 
  print()
```

Вот так мы можем узнать имена столбцов, извлечь ряды по значению переменной или узнать тип данных в столбцах.

```{r}
colnames(df) 

df[df$name == "John", ] |> 
  print()

# узнать тип данных в столбцах
str(df) 
```

Преобразовать тип данных:

```{r warning=FALSE}
df$age <- as.character(df$age)
```

::::{.callout-warning icon=false}
Для закрепления навыка в `swirl` пройдите  урок 7 `Matrices and Data Frames`. После этого можете  выполнить практическое задание ниже. 
::::


## Практическое задание


```{r eval=FALSE}
# устанавливаем и загружаем нужный пакет
install.packages("languageR")
library(languageR)

# загружаем датасет
meta <- spanishMeta

# допишите ваш код ниже
# посчитайте средний год публикации романов Камило Хосе Селы


# вычислите суммарное число слов в романах Эдуардо Мендосы


# извлеките ряды с текстами, опубликованными до 1980 г.
```


## Видео к уроку

- [Видео](https://vkvideo.ru/video91786643_456239039) 2024 г.
- [Видео](https://vk.com/video91786643_456239070) 2025 г.

##  Домашнее задание ✍️

К следующему разу задание будет очень простым, почти даже символическим (будем считать, что у нас адаптационный период). Оценка 0/1.

- Пройдите любые два из оставшихся уроков `swirl` (на выбор). 

- Когда `swirl` сообщит о 100% выполнении, введите свое имя в консоли или в окне скрипта, сделайте скриншот и отправьте скан ассистенту курса личным сообщением в Telegram (контакты в рабочем чате).

Дедлайн строго: до 21:00 мск четверга **11 сентября** 2025 (это самая сложная часть дз).