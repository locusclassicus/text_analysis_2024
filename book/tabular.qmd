# Таблицы

В этом уроке речь пойдет о прямоугольных данных, т.е. таких данных, которые имеют форму таблицы. Для начала вспомним, что мы уже знаем о векторах и списках: вектор может хранить данные одного типа (например, числовые или строки), а список -- разного типа. Двумерным аналогом вектора в R является матрица, а двумерным аналогом списка -- датафрейм. 

## Матрицы

Матрица -- это вектор, который имеет два дополнительных атрибута: количество строк и количество столбцов. Из этого следует, что матрица, как и вектор, может хранить данные одного типа. Проверим.

```{r}
M = matrix(c(1, 2, 3, 4), nrow = 2)
M # все ок

M = matrix(c(1, 2, 3, "a"), nrow = 2)
M # все превратилось в строку! 
```

В матрице есть ряды и столбцы. Их количество определяет размер (порядок) матрицы. Выше мы создали матрицу 2 x 2. Элементы матрицы, как и элементы вектора, можно извлекать по индексу. Сначала указывается номер ряда (строки), потом номер столбца.

```{r}
M = matrix(c(1, 2, 3, 4), nrow = 2)
M
```

```{r}
M[1, ] # первая строка полностью
M[,2] # второй столбец полностью
M[1,1] # одно значение
```

Обратите внимание, как меняется размерность при индексировании.

```{r}
M = matrix(c(1, 2, 3, 4), nrow = 2)
dim(M) # функция для извлечения измерений

dim(M[1, ]) 
```

Попытка узнать измерения вектора возвращает `NULL`, потому что, с точки зрения R, векторы не являются матрицами из одного столбца или одной строки и потому не имеют измерений. 

В этом уроке мы не будем много работать с матрицами, но полезно помнить, что они существуют: матрицы и алгебраические операции с ними задействованы при латентно-семантическом анализе и построении эмбеддингов (см. ниже).

## Таблицы (датафреймы)

Если матрица -- это двумерный аналог вектора, то таблица (кадр данных, data frame) -- это двумерный аналог списка. Как и список, датафрейм может хранить данные разного типа. 

```{r}
# создание датафрейма
df <- data.frame(names = c("John", "Mary"), age = c(18, 25), sport = c("basketball", "tennis"))
df
```

Извлечение данных тоже напоминает работу со списком. 

```{r}
df$names # забирает весь столбец
df[,"names"] # то же самое, другой способ
df[1, ] # забирает ряд
```

## Импорт табличных данных

В этом уроке мы будем работать с датасетом из [Репозитория открытых данных по русской литературе и фольклору](https://dataverse.pushdom.ru/dataset.xhtml?persistentId=doi:10.31860/openlit-2022.9-B006) под названием "Программы по литературе для средней школы с 1919 по 1991 гг." Этот датасет был использован при подготовке [интерактивной карты](https://litra.sociolit.ru/timeline) российского школьного литературного канона (1852-2023). Карта была представлена в 2023 г. Лабораторией проектирования содержания образования ВШЭ. Подробнее о проекте можно посмотреть [материал](https://sysblok.ru/uncategorized/ot-avvakuma-do-jeshila-analiz-shkolnyh-programm-po-literature-v-proekte-spisok-chtenija/) "Системного блока". 

Основная функция для скачивания файлов из Сети -- `download.file()`, которой необходимо задать в качестве аргументов url, название сохраняемого файла, иногда также метод.

```{r eval=FALSE}
url <- "https://dataverse.pushdom.ru/api/access/datafile/4229"

# скачивание в папку files в родительской директории
download.file(url, destfile = "../files/curricula.tsv") 
```

Основные функции для чтения табличных данных в базовом R - это `read.table()` и `read.csv()`. Файл, который мы скачали, имеет расширение `.tsv` (tab separated values). Чтобы его прочитать, используем `read.table()`, указав тип разделителя:

```{r}
curricula_df <- read.table("../files/curricula.tsv", sep = "\t", header = TRUE)

curricula_df
```

Функция `read.csv()` отличается лишь тем, что автоматически выставляет значения аргументов `sep = ","`, header = TRUE.

Функция `class()` позволяет убедиться, что перед нами датафрейм.

```{r}
class(curricula_df)
```

## Работа с датафреймами

```{r}
# узнать имена столбцов
colnames(curricula_df) 
```
```{r}
# извлечь ряд(ы) по значению
curricula_df[curricula_df$year == "1919", ]
```

```{r}
# извлечь столбец 
curricula_df$year |> head()
curricula_df[ , "year"] |> head()
curricula_df[ , 6] |>  head()
```


```{r}
# узнать тип данных в столбцах
str(curricula_df) 
```

```{r warning=FALSE}
# преобразовать тип данных в столбцах
curricula_df$year <- as.numeric(curricula_df$year)
```


```{r}
# вывести сводку
summary(curricula_df)
```

Небольшое упражнение на кодинг позволит закрепить навыки работы с матрицами и датафреймами. 

::::{.callout-warning icon=false}
Запустите `swirl()` и пройдите урок 7 `Matrices and Data Frames`.
::::

Все ли вы запомнили? 

::::{.callout-tip icon=false}
Для чего нужна функция `cbind()`?
::::

```{r echo=FALSE, results='asis'}
library(checkdown)
check_question("для добавления столбцов", options = c("для добавления рядов", "для добавления столбцов", "для извлечения имен столбцов", "для извлечения имен рядов"), type = "radio", button_label = "Проверить", right = "✅", wrong =  "❌")
```

::::{.callout-tip icon=false}
Функция `colnames()` позволяет как назначать новые имена таблице, так и извлекать существующие.
::::

```{r echo=FALSE, results='asis'}
check_question("Правда", options = c("Правда", "Ложь"), button_label = "Проверить", type = "select", right = "✅", wrong =  "❌")
```


::::{.callout-warning icon=false}
Практическое задание "Испанские писатели".
::::


```{r eval=FALSE}
# устанавливаем и загружаем нужный пакет
install.packages("languageR")
library(languageR)

# загружаем датасет
meta <- spanishMeta

# допишите ваш код ниже
# посчитайте средний год публикации романов Камило Хосе Селы


# вычислите суммарное число слов в романах Эдуардо Мендосы


# извлеките ряды с текстами, опубликованными до 1980 г.
```

## Tibble 

Существуют два основных "диалекта" R, один из которых опирается главным образом на функции и структуры данных базового R, а другой пользуется синтаксисом tidyverse. Tidyverse -- это семейство пакетов (**метапакет**), разработанных Хадли Уикхемом и др., которое включает в себя в том числе пакеты `dplyr`, `ggplot2` и многие другие.

```{r}
# загрузить все семейство
library(tidyverse)
```

Основная структура данных в tidyverse -- это [tibble](https://r4ds.had.co.nz/tibbles.html), современный вариант датафрейма. Тиббл, как говорят его разработчики, это [ленивые и недовольные](https://tibble.tidyverse.org/) датафреймы: они делают меньше и жалуются больше. Это позволяет решать проблемы на более ранних этапах, что, как правило, приводит к созданию более чистого и выразительного кода.

Основные отличия от обычного датафрейма:

-   усовершенствованный метод `print()`, не нужно постоянно вызывать `head()`;
-   нет имен рядов;
-   допускает синтаксически "неправильные" имена столбцов;
-   при индексировании не превращается в вектор.

Преобразуем наш датафрейм в тиббл для удобства работы с ним.

```{r}
curricula_tbl <- as_tibble(curricula_df)
```

Сравним поведение датафрейма и тиббла.

```{r}
# индексирование 
curricula_df[, 1] |> class()
curricula_tbl[,1]  |> class()
```

Пора тренироваться.

::::{.callout-warning icon=false}
Установите курс `swirl::install_course("Getting and Cleaning Data")`.  Загрузите библиотеку `library(swirl)`, запустите `swirl()`, выберите этот курс и пройдите из него урок 1 `Manipulating Data with dplyr`. При попытке загрузить урок 1 вы можете получить сообщение об ошибке. В таком случае установите версию курса из github, как указано [здесь](https://github.com/swirldev/swirl_courses/issues/260#issuecomment-192004132), или загрузите файл вручную, как указано [здесь](http://swirlstats.com/scn/getclean.html).
::::

Время вопросов! Обычный датафрейм или тиббл?

::::{.callout-tip icon=false}
По умолчанию распечатывает только первые 10 рядов в консоль.
::::

```{r echo=FALSE, results='asis'}
check_question("тиббл", options = c("датафрейм", "тиббл"), button_label = "Проверить", type = "radio", right = "✅", wrong =  "❌")
```
 
::::{.callout-tip icon=false}
Молчаливо исправляет некорректные названия столбцов.
::::
```{r echo=FALSE, results='asis'}
check_question("датафрейм", options = c("датафрейм", "тиббл"), type = "radio", button_label = "Проверить", right = "✅", wrong =  "❌")
```

::::{.callout-tip icon=false}
Не имеет названий рядов.
::::

```{r echo=FALSE, results='asis'}
check_question("тиббл", options = c("датафрейм", "тиббл"), button_label = "Проверить", type = "radio", right = "✅", wrong =  "❌")
```

Кстати, обратили внимание, как работает оператор `<=` с символьным вектором? 

## Dplyr

В уроке `swirl` выше вы уже немного познакомились с "грамматикой манипуляции данных", лежащей в основе [`dplyr`](https://dplyr.tidyverse.org/). Здесь об этом будет сказано подробнее. Эта грамматика предоставляет последовательный набор глаголов, которые помогают решать наиболее распространенные задачи манипулирования данными:

-   `mutate()` добавляет новые переменные, которые являются функциями существующих переменных;
-   `select()` выбирает переменные (столбцы) на основе их имен;
-   `filter()` выбирает наблюдения (ряды) на основе их значений;
-   `summarise()` обобщает значения;
-   `arrange()` изменяет порядок следования строк.

Все эти глаголы естественным образом сочетаются с функцией `group_by()`, которая позволяет выполнять любые операции "по группам", и с оператором **pipe** `|>` из пакета `magrittr`.

В итоге получается более лаконичный и читаемый код. Узнаем, за какие года у нас есть программы по литературе.

```{r}
curricula_tbl |> 
  count(curriculum, year) 
```


Отберем две программы для 8 класса и выясним, какие авторы в них представлены лучше всего.

```{r}
curricula_tbl |> 
  filter(year %in% c(1919, 1922), grade == 8) |> 
  count(author, year) |> 
  arrange(-n)
```

Теперь упражнения в `swirl`. Вам придется редактировать код, который предложит программа, так что сгруппируйтесь.

::::{.callout-warning icon=false}
Запустите `swirl()`, выберите курс `Getting and Cleaning Data` и пройдите из него урок 2 `Grouping and Chaining with dplyr`.
::::

Правда или ложь?

::::{.callout-tip icon=false}
Функция `n_distinct()` возвращает все уникальные значения. 
::::

```{r echo=FALSE, results='asis'}
check_question("Ложь", type = "radio", button_label = "Проверить", options = c("Правда", "Ложь"), right = "✅", wrong =  "❌")
```


## Опрятные данные

> Tidy datasets are all alike, but every messy dataset is messy in its own way.
>
> --- Hadley Wickham

Tidyverse -- это не только особый синтаксис, но и отдельная идеология ["опрятных данных"](https://r4ds.had.co.nz/tidy-data.html). "Сырые" данные, с которыми мы работаем, редко бывают опрятны, и перед анализом их следует "почистить" и преобразовать.

Основные принципы опрятных данных:

-   отдельный столбец для каждой переменной;
-   отдельный ряд для каждого наблюдения;
-   у каждого значения отдельная ячейка;
-   один датасет -- одна таблица.

![_Принципы опрятных данных_. [Источник](https://r4ds.had.co.nz/tidy-data.html).](https://d33wubrfki0l68.cloudfront.net/6f1ddb544fc5c69a2478e444ab8112fb0eea23f8/91adc/images/tidy-1.png)

</br>

Посмотрите на учебные тибблы из пакета `tidyr` и подумайте, какое из этих правил нарушено в каждом случае. 

```{r}
data("table2")
table2
data("table3")
table3

data("table4a")
table4a
data("table4b")
table4b
```

Важные [функции](https://tidyr.tidyverse.org/reference/index.html) для преобразования данных из пакета `tidyr`:

- `separate()` делит один столбец на новые;
- `unite()` объединяет столбцы;
- `pivot_longer()` удлиняет таблицу;
- `pivot_wider()` расширяет таблицу;
- `drop_na()` и `replace_na()` указывают, что делать с NA и др.

Кроме того, в `dplyr` есть полезное семейство функций `_join`, позволяющих [объединять](https://r4ds.had.co.nz/relational-data.html) данные в различных таблицах. 

![](./images/joins.png)


Дальше мы потренируемся с ними работать, но сначала пройдем урок `swirl`. Это достаточно сложный урок (снова понадобится редактировать скрипт), но он нам дальше здорово поможет. 

::::{.callout-warning icon=false}
Запустите `swirl()`, выберите курс `Getting and Cleaning Data` и пройдите из него урок 3 `Tidying Data with tidyr`.
::::

Правда или ложь?

::::{.callout-tip icon=false}
Функция `separate()` обязательно требует указать разделитель.
::::

```{r echo=FALSE, results='asis'}
check_question("Ложь", button_label = "Проверить", options = c("Правда", "Ложь"), type = "select", right = "✅", wrong =  "❌")
```

::::{.callout-tip icon=false}
Принципы опрятных данных требуют, чтобы одному наблюдению соответствовал один столбец.
::::

```{r echo=FALSE, results='asis'}
check_question("Ложь", button_label = "Проверить", options = c("Правда", "Ложь"), type = "select", right = "✅", wrong =  "❌")
```

::::{.callout-tip icon=false}
Функция `contains()` используется вместе с `filter()` для выбора рядов.
::::

```{r echo=FALSE, results='asis'}
check_question("Ложь", button_label = "Проверить", options = c("Правда", "Ложь"), type= "select", right = "✅", wrong =  "❌")
```

</br>
Отличная работа! Прежде чем двигаться дальше, приведите в порядок table2, 3, 4a-4b, используя `dplyr` и `tidyr`.


::::{.callout-warning icon=false}
Практическое задание "Библиотека Gutenberg"
::::


```{r eval=FALSE}
devtools::install_github("ropensci/gutenbergr")
library(gutenbergr)
library(dplyr)
library(tidyr)

works <- gutenberg_works()

# Отберите ряды, в которых gutenberg_author_id равен 65;
# после этого выберите два столбца: author, title
my_data <- works |> 
  # ваш код здесь
  
# Загрузите данные об авторах и выберите столбцы: author, deathdate
authors <- gutenberg_authors |> 
  # ваш код здесь

# Соедините my_data с данными о смерти автора из authors, 
# так чтобы к my_data добавился новый столбец. 
# После этого используйте функцию separate, 
# чтобы разделить столбец с именем и фамилией на два новых: author, name. 
# Удалите столбец с именем автора, оставив только фамилию.
# Добавьте новый столбец century, 
# используя функцию mutate и данные из столбца deathdate. 
# Используйте оператор pipe, не сохраняйте промежуточные результаты!

my_data |> 
  # ваш код здесь
  
```

## Обобщение данных

Теперь вернемся к датасету curricula и попробуем частично воспроизвести результаты, полученные авторами проекта ["Список чтения"](https://litra.sociolit.ru/tops), упомянутого выше. 

У каких авторов больше всего произведений (во всех программах)?

```{r message=FALSE}
curricula_tbl |> 
  group_by(author, title) |> 
  summarise(n = n()) |> 
  arrange(-n)
```

Какие произведения упоминаются в программах чаще всего?

```{r}
curricula_tbl |> 
  count(author, title) |> 
  arrange(-n)
```

На принятые в каких годах программы приходится больше всего произведений? (Объяснение [здесь](https://litra.sociolit.ru/).)

```{r}
curricula_tbl |> 
  group_by(year) |> 
  distinct(author, title) |> 
  summarise(n = n()) |> 
  arrange(-n)
```

В заключение попробуйте сформулировать новые вопросы и ответить на них при помощи этого датасета. 