# Таблицы. Опрятные данные

## Tidyveryse

Существуют два основных "диалекта" R, один из которых опирается главным образом на функции и структуры данных базового R, а другой пользуется синтаксисом tidyverse. Tidyverse -- это семейство пакетов (**метапакет**), разработанных Хадли Уикхемом и др., которое включает в себя в том числе пакеты `dplyr`, `ggplot2` и многие другие.

```{r}
# загрузить все семейство
library(tidyverse)
```


## Импорт табличных данных

В этом уроке мы будем работать с датасетом из [Репозитория открытых данных по русской литературе и фольклору](https://dataverse.pushdom.ru/dataset.xhtml?persistentId=doi:10.31860/openlit-2022.9-B006) под названием "Программы по литературе для средней школы с 1919 по 1991 гг." Этот датасет был использован при подготовке [интерактивной карты](https://litra.sociolit.ru/timeline) российского школьного литературного канона (1852-2023). Карта была представлена в 2023 г. Лабораторией проектирования содержания образования ВШЭ. Подробнее о проекте можно посмотреть [материал](https://sysblok.ru/uncategorized/ot-avvakuma-do-jeshila-analiz-shkolnyh-programm-po-literature-v-proekte-spisok-chtenija/) "Системного блока". 

Основная функция для скачивания файлов из Сети -- `download.file()`, которой необходимо задать в качестве аргументов url, название сохраняемого файла, иногда также метод.

```{r eval=FALSE}
url <- "https://dataverse.pushdom.ru/api/access/datafile/4229"

# скачивание в папку files в родительской директории
download.file(url, destfile = "../files/curricula.tsv") 
```

Основные функции для чтения табличных данных в базовом R - это `read.table()` и `read.csv()`. Они вернут датафрейм. 

Файл, который мы скачали, имеет расширение `.tsv` (tab separated values). Чтобы его прочитать, используем `read.table()`, указав тип разделителя:

```{r}

curricula_df <- read.table("../files/curricula.tsv", sep = "\t", header = TRUE)

curricula_df
```

Функция `read.csv()` отличается лишь тем, что автоматически выставляет значения аргументов `sep = ","`, header = TRUE.

Функция `class()` позволяет убедиться, что перед нами датафрейм.

```{r}
class(curricula_df)
```


```{r}
# вывести сводку
summary(curricula_df)
```

## Tibble 


Основная структура данных в tidyverse -- это [tibble](https://r4ds.had.co.nz/tibbles.html), современный вариант датафрейма. Тиббл, как говорят его разработчики, это [ленивые и недовольные](https://tibble.tidyverse.org/) датафреймы: они делают меньше и жалуются больше. Это позволяет решать проблемы на более ранних этапах, что, как правило, приводит к созданию более чистого и выразительного кода.

Основные отличия от обычного датафрейма:

-   усовершенствованный метод `print()`, не нужно постоянно вызывать `head()`;
-   нет имен рядов;
-   допускает синтаксически "неправильные" имена столбцов;
-   при индексировании не превращается в вектор.

Преобразуем наш датафрейм в тиббл для удобства работы с ним.

```{r}
curricula_tbl <- as_tibble(curricula_df)
```

Чтобы избежать подобных преобразований, можно воспользоваться пакетом для импорта данных `readr`:

```{r}
curricula_tbl <- read_delim("../files/curricula.tsv", delim = "\t")
```

Воспользуйтесь любым способом, чтобы получить тиббл. 


::::{.callout-warning icon=false}
Установите курс `swirl::install_course("Getting and Cleaning Data")`.  Загрузите библиотеку `library(swirl)`, запустите `swirl()`, выберите этот курс и пройдите из него урок 1 `Manipulating Data with dplyr`. При попытке загрузить урок 1 вы можете получить сообщение об ошибке. В таком случае установите версию курса из github, как указано [здесь](https://github.com/swirldev/swirl_courses/issues/260#issuecomment-192004132), или загрузите файл вручную, как указано [здесь](http://swirlstats.com/scn/getclean.html).
::::

## Dplyr

В уроке `swirl` выше вы уже немного познакомились с "грамматикой манипуляции данных", лежащей в основе [`dplyr`](https://dplyr.tidyverse.org/). Здесь об этом будет сказано подробнее. Эта грамматика предоставляет последовательный набор глаголов, которые помогают решать наиболее распространенные задачи манипулирования данными:

-   `mutate()` добавляет новые переменные, которые являются функциями существующих переменных;
-   `select()` выбирает переменные (столбцы) на основе их имен;
-   `filter()` выбирает наблюдения (ряды) на основе их значений;
-   `summarise()` обобщает значения;
-   `arrange()` изменяет порядок следования строк.

Все эти глаголы естественным образом сочетаются с функцией `group_by()`, которая позволяет выполнять любые операции "по группам", и с оператором *pipe* `|>` из пакета `magrittr`.

В итоге получается более лаконичный и читаемый код. Узнаем, за какие года у нас есть программы по литературе.

```{r}
curricula_tbl |> 
  count(curriculum, year) |> 
  print()
```


Отберем две программы для 8 класса и выясним, какие авторы в них представлены лучше всего.

```{r}
curricula_tbl |> 
  filter(year %in% c(1919, 1922), grade == 8) |> 
  count(author, year) |> 
  arrange(-n)
```

Теперь упражнения в `swirl`. Вам придется редактировать код, который предложит программа, так что сгруппируйтесь.

::::{.callout-warning icon=false}
Запустите `swirl()`, выберите курс `Getting and Cleaning Data` и пройдите из него урок 2 `Grouping and Chaining with dplyr`.
::::



## Опрятные данные

> Tidy datasets are all alike, but every messy dataset is messy in its own way.
>
> --- Hadley Wickham

Tidyverse -- это не только особый синтаксис, но и отдельная идеология ["опрятных данных"](https://r4ds.had.co.nz/tidy-data.html). "Сырые" данные, с которыми мы работаем, редко бывают опрятны, и перед анализом их следует "почистить" и преобразовать.

Основные принципы опрятных данных:

-   отдельный столбец для каждой переменной;
-   отдельный ряд для каждого наблюдения;
-   у каждого значения отдельная ячейка;
-   один датасет -- одна таблица.

![_Принципы опрятных данных_. [Источник](https://r4ds.hadley.nz/data-tidy.html)](https://r4ds.hadley.nz/images/tidy-1.png)

</br>

Посмотрите на учебные тибблы из пакета `tidyr` и подумайте, какое из этих правил нарушено в каждом случае. 

```{r}
data("table2")
table2 |> 
  print()

data("table3")
table3 |> 
  print()

data("table4a")
table4a |> 
  print()
data("table4b")
table4b |> 
  print()
```

Важные [функции](https://tidyr.tidyverse.org/reference/index.html) для преобразования данных из пакета `tidyr`:

- `separate()` делит один столбец на новые;
- `unite()` объединяет столбцы;
- `pivot_longer()` удлиняет таблицу;
- `pivot_wider()` расширяет таблицу;
- `drop_na()` и `replace_na()` указывают, что делать с NA и др.

Кроме того, в `dplyr` есть полезное семейство функций `_join`, позволяющих [объединять](https://r4ds.had.co.nz/relational-data.html) данные в различных таблицах. 

![[_Источник_.](https://r4ds.had.co.nz/relational-data.html?q=join#inner-join)](./images/joins.png)

Дальше мы потренируемся с ними работать, но сначала пройдем урок `swirl`. Это достаточно сложный урок (снова понадобится редактировать скрипт), но он нам дальше здорово поможет. 

::::{.callout-warning icon=false}
Запустите `swirl()`, выберите курс `Getting and Cleaning Data` и пройдите из него урок 3 `Tidying Data with tidyr`.
::::


Прежде чем двигаться дальше, приведите в порядок table2, 3, 4a-4b, используя `dplyr` и `tidyr`.


## Обобщение данных

Теперь вернемся к датасету curricula и попробуем частично воспроизвести результаты, полученные авторами проекта ["Список чтения"](https://litra.sociolit.ru/tops), упомянутого выше. 

У каких авторов больше всего произведений (во всех программах)?

```{r message=FALSE}
curricula_tbl |> 
  group_by(author, title) |> 
  summarise(n = n()) |> 
  arrange(-n) |> 
  print()
```

Какие произведения упоминаются в программах чаще всего?

```{r}
curricula_tbl |> 
  count(author, title) |> 
  arrange(-n) |> 
  print()
```

На принятые в каких годах программы приходится больше всего произведений? (Объяснение [здесь](https://litra.sociolit.ru/).)

```{r}
curricula_tbl |> 
  group_by(year) |> 
  distinct(author, title) |> 
  summarise(n = n()) |> 
  arrange(-n) |> 
  print()
```

В заключение попробуйте сформулировать новые вопросы и ответить на них при помощи этого датасета. 

## Слияние таблиц

Файл с библиографией забираем с [сайта](https://dataverse.pushdom.ru/file.xhtml?fileId=4234&version=1.0), как было показано выше.

```{r message=FALSE}
bib_tbl <- read_tsv("../files/bibliography.tsv")
```

Используем уже знакомые функции для объединения данных.

```{r}
curricula_joined <- curricula_tbl |> 
  select(author, title, year, grade, curriculum) |> 
  left_join(bib_tbl, join_by(curriculum == abbreviation))

curricula_joined |> 
  print()
```

## Практическое задание

(1) Выполните практическое задание из [предыдущего урока](https://locusclassicus.github.io/text_analysis_2024/start.html), используя функции из библиотеки `tidyverse`.

(2) Скачайте и исследуйте датасет с [корпусом русских элегий](https://dataverse.pushdom.ru/dataset.xhtml?persistentId=doi:10.31860/openlit-2019.11-C001) 1815-1835 г.

## Видео к уроку

- [Видео](https://vkvideo.ru/video91786643_456239040) 2024 г.
- [Видео](https://vk.com/video91786643_456239072) 2025 г.


## Домашнее задание ✍️

- Создайте учетную запись GitHub, если у вас ее нет: <https://github.com/> 

- Примите задание по ссылке: <https://classroom.github.com/a/kZtVp96N>. Если вы не видите себя в списке студентов, напишите преподавателю. 

- После этого GitHub создаст репозиторий для сдачи домашнего задания. 

- Создайте на своем компьютере файл `hw1.R`, отредактируйте его, используя заготовку ниже. 

```{r eval=FALSE}
library(gutenbergr)
library(dplyr)
library(tidyr)

works <- gutenberg_works()

# Отберите ряды, в которых gutenberg_author_id равен 65;
# после этого выберите два столбца: author, title
my_data <- works |> 
  # ваш код здесь
  
# Загрузите данные об авторах и выберите столбцы: author, deathdate
authors <- gutenberg_authors |> 
  # ваш код здесь

# Соедините my_data с данными о смерти автора из authors, 
# так чтобы к my_data добавился новый столбец. 
# После этого используйте функцию separate, 
# чтобы разделить столбец с именем и фамилией на два новых: author, name. 
# Удалите столбец с именем автора, оставив только фамилию.
# Добавьте новый столбец century, 
# используя функцию mutate и данные из столбца deathdate. 
# Используйте оператор pipe, не сохраняйте промежуточные результаты!

my_data |> 
  # ваш код здесь
  
```

- После этого любым способом загрузите свой файл в репозиторий. Если умеете в git, хорошо. Если нет, используйте кнопку `Upload files`.

![](./images/classroom.png)

- Не меняйте имена переменных! Проверка будет **автоматической**. 

- Для пересчета года в век используйте следующую формулу: `(deathdate - 1) %/% 100 + 1`, где `%/%` -- целочисленное деление. 

- Дедлайн: 25/09/2025 21:00.

- Оценка: 0/1.
