# Циклы, условия, функции

В этом уроке мы познакомимся с итерационными конструкциями и функционалами, т.е. такими функциями, которые принимают в качестве аргумента другую функцию. Они нужны для того, чтобы можно было что-то сделать много раз: например, прочитать сразу 100 файлов из директории, построить и сохранить одной командой несколько графиков или сделать множество случайных выборок из большого текстового корпуса. 

Общее правило таково: если вы скопировали кусок кода больше трех раз, то самое время задуматься об итерации. Это позволит избежать ошибок при копировании и сделает код более легким и читаемым. 

## Датасет

В этом уроке мы исследуем датасет "Гарри Поттер", который представляет собой набор файлов `.csv`, содержащих метаданные о ресурсах из коллекций Британской библиотеки, связанных с Гарри Поттером. Первоначально он был выпущен к 20-летию публикации книги «Гарри Поттер и философский камень» 26 июня 2017 года и с тех пор ежегодно обновлялся. Всего в датасете пять файлов, каждый из которых содержит разное представление данных. 

Датасет до 2023 г. был доступен на сайте Британской библиотеки (<https://www.bl.uk/>); в репозитории курса сохранена его копия. Скачаем архив.

```{r eval=FALSE}
my_url <- "https://github.com/locusclassicus/text_analysis_2024/raw/main/files/HP.zip"
download.file(url = my_url, destfile = "../files/HP.zip")
```

После этого переходим в директорию с архивом и распаковываем его.

```{r eval=FALSE}
unzip("../files/HP.zip")
```

Сохраним список всех файлов с расширением .csv, используя подходящую функцию из base R.

```{r}
my_files <- list.files("../files/HP", pattern = ".csv", full.names = TRUE)
my_files
```

## Векторизованные вычисления

Хорошая новость: многие функции в R уже _векторизованы_, и если необходимо применить функцию к каждому элементу вектора,  в большинстве случаев достаточно просто вызвать функцию. Например, у нас есть символьный вектор, и мы хотим узнать количество символов в каждом слове.

```{r}
homer <- c("в", "мысли", "ему", "то", "вложила", "богиня", "державная", "гера")
```

Для каждого компонента вектора необходимо выполнить одну итерацию цикла, в нашем случае -- применить функцию `nchar()`. В некоторых языках программирования это делается как-то так:


```{r}
for(i in homer) print(nchar(i))
```

:::{.callout-note icon=false}
В циклах часто используется буква `i`. Но никакой особой магии в ней нет, имя переменной можно изменить.
:::

Мы написали цикл `for`, который считает количество букв для каждого слова в векторе. Как видно, все сработало. Но в R это избыточно, потому что `nchar()` уже векторизована:

```{r}
nchar(homer)
```

:::{.callout-note icon=false}
Это относится не только ко многим встроенным функциям R, но и к  операторам. `x + 4` в действительности представляет собой `+(x, 4)`. Ключевую роль здесь играет переработка данных, о которой мы говорили в первом уроке: короткий вектор повторяется до тех пор, пока его длина не сравняется с длиной более длинного вектора. 
:::


Лишний цикл может замедлить вычисления. Проверим. 
```{r eval=FALSE}

library(tictoc)

# способ первый
tic()
for(i in homer) print(nchar(i))
toc()
# 0.075 sec elapsed

# способ второй 
tic()
nchar(homer)
toc()
# 0.017 sec elapsed
```

> Один из главных принципов программирования на R гласит, что следует обходиться без циклов, а если это невозможно, то циклы должны быть простыми.
>
> --- Нормат Мэтлофф


Для работы со _списками_ циклы тоже чаще всего избыточны. Для случаев, когда надо применить какую-то функцию ко всем элементам списка, в базовом R для используются функционалы семейства `_apply()`, а в `tidyverse` их с успехом заменяет семейство `map_()` из пакета `{purrr}`. 


::: {.callout-warning icon=false}
Опционально: пройдите урок 10 `lapply and sapply` и урок 11 `vapply and tapply` из курса `R Programming` в `swirl`.
:::

## Пакет `{purrr}`

Разработчики предупреждают, что потребуется время, чтобы овладеть этим инструментом [@wickham2016].

> You should never feel bad about using a loop instead of a map function. The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work.
>
> --- Hadley Wickham & Garrett Grolemund

В семействе функций `map_` из этого пакета всего [23 вариации](https://adv-r.hadley.nz/functionals.html). Вот основные из них:

-   `map()`
-   `map_lgl()`
-   `map_int()`
-   `map_dbl()`
-   `map_chr()`

Все они принимают на входе данные и функцию (или формулу), которую следует к ним применить, и возвращают результат в том виде, который указан после подчеркивания. Просто `map()` вернет список, а `map_int()` -- целочисленный вектор, и т.д. 


## `map()` & `map_int()`

Для того, чтобы прочесть все файлы одним вызовом функции, используем `map()`. В качестве аргументов передаем список файлов, функцию `read_csv()` и аргумент этой функции `col_types`. 

```{r message=FALSE}
library(tidyverse)
# чтение файлов 
HP <- map(my_files, read_csv, show_col_types = FALSE)
```

Объект `HP` -- это список. В нем пять элементов, так как на входе у нас было пять файлов. Для удобства назначаем имена элементам списка. 

```{r}
names_short <- list.files("../files/HP", pattern = ".csv") |> 
  str_remove(".csv")
names_short
```

```{r}
# присваиваем имена элементам списка
names(HP) <- names_short
```


Для начала узнаем число рядов в каждой таблице. На выходе мы ожидаем целое число, поэтому используем `map_int()`. Функция вернет именованный вектор. Чтобы избавиться от имен, можно использовать `unname()`.

```{r}
map_int(HP, nrow)
```
## `pluck()` & `map_df()`

Каждую таблицу можно также рассматривать как _список_ (переменных) и применять функции (или их сочетания) к отдельным столбцам. Получить доступ к отдельным таблицам можно при помощи квадратных скобок (`HP[["titles"]]`) или при помощи функции `pluck()` из того же пакета `{purrr}`. Оба способа хороши, но второй удобнее при работе с вложенными списками, которая нас ждет в следующем уроке. 

```{r}
titles <- HP |> 
  pluck("titles")
```


Теперь узнаем сумму отсутствующих значений в каждом столбце таблицы `titles`. Здесь  `.x` — это текущий элемент из `titles`, который последовательно передаётся в функцию, а тильда ( `~` ) обозначает начало выражения-функции. Если вы явно передаёте именованную или анонимную функцию, то тильда не требуется.

```{r}
map_int(titles, ~sum(is.na(.x)))
```

Также узнаем число уникальных значений в каждом столбце и запросим результат в виде таблицы.


```{r}
map_df(
  titles,
  ~ tibble(
    n_unique = n_distinct(.x),
    nas = sum(is.na(.x)),
    prop_nas = round(nas / nrow(titles),2)
    ),
  .id = "variable"
  ) |> 
  arrange(prop_nas) |> 
  print()
```

:::{.callout-warning icon=false}
Установите курс `swirl::install_course("Advanced R Programming")` и пройдите из него урок 3 `Functional Programming with purrr`.
:::

## Разведывательный анализ

Выясним, на каких языках и когда выходили книги о Гарри Поттере. Но сначала приведем данные в опрятный вид. Там, где языков два, как правило интересен второй (первый - английский); поэтому делим столбец с языками на два и "сплавляем". Функция `coalesce(x, y`) возвращает первое не-NA между `x и `y`.

```{r warning=FALSE}
titles_tidy <- titles |> 
  select(Title, Name, `Date of publication`, Languages) |> 
  # избавимся от неправильных имен
  rename(
    Year = `Date of publication`) |>
  # избавимся от NA
  filter(!is.na(Year), !is.na(Languages)) |> 
  #  разделим кода с дефисом и преобразуем год  
  separate(Year, into = c("Year", NA)) |> 
  mutate(Year = as.integer(Year)) |> 
  # выбираем, где можно, второй язык
  separate(Languages, into = c("Language1", "Language2"), sep = ";") |> 
  mutate(Language = coalesce(Language2, Language1)) |> 
  select(-Language1, -Language2)

titles_tidy
```

Для графика выберем несколько языков. Кстати, ни одного перевода на русский в данных Британской библиотеки нет.


```{r warning=FALSE, message=FALSE}
titles_tidy |> 
  add_count(Language) |> 
  filter(n > 10) |> 
  select(-n) |> 
  ggplot(aes(Year, fill = Language)) + 
  geom_bar(position = "stack") + 
  xlab(NULL) +
  theme_light() +
  theme(axis.text.x = element_text(angle = 45)) +
  scale_x_continuous(breaks = seq(1997, 2023))
```


Теперь попробуем самостоятельно написать функцию и передать ее `map_*()`.

## Синтаксис функции

Функция и код -- не одно и то же. Чтобы стать функцией, кусок кода должен получить имя. Но зачем давать имя коду, который и так работает? Вот три причины, которые [приводит](https://r4ds.had.co.nz/functions.html) Хадли Уикхем:

-   у функции есть выразительное имя, которое облегчает понимание кода;
-   при изменении требований необходимо обновлять код только в одном месте, а не во многих;
-   меньше вероятность случайных ошибок при копировании (например, обновление имени переменной в одном месте, но не в другом)

> Writing good functions is a lifetime journey.
>
> --- Hadley Wickham

Машине все равно, как вы назовете функцию, но тем, кто будет читать код, не все равно. Имена должны быть информативы (поэтому функция `f()` -- плохая идея). Также не стоит переписывать уже существующие в R имена!

Далее следует определить _формальные аргументы_ и, при желании, _значения по умолчанию_. Тело функции пишется в фигурных скобках. В конце кода функции располагается команда `return()`; если ее нет, то функция возвращает последнее вычисленное значение (см. [здесь](https://r4ds.had.co.nz/functions.html) о том, когда что предпочесть).

Написание функций -- навык, который можно бесконечно совершенствовать. Начать проще всего с обычного кода. Убедившись, что он работает как надо, вы можете упаковать его в функцию. 

Напишем функцию, которая забирает все слова из столбца, считает частотности и строит облако слов. Сначала просто поймем, какой код нам нужен.


```{r message=FALSE}
library(tidytext)
count_data <- titles_tidy |> 
  filter(Language == "English") |> 
  select(Title) |> 
  unnest_tokens(output = "word", input = "Title") |> 
  anti_join(stop_words) |> 
  count(word, sort = TRUE) |> 
  filter(!str_detect(word, "[0-9]"),
         !word %in% c("harry", "potter", "book"))

count_data |> 
  print()
```


Также построим облако слов. 


```{r warning=FALSE}
pal <- c("#f1c40f", "#34495e", 
         "#8e44ad", "#3498db",
         "#2ecc71")

library(wordcloud)
par(mar = c(1, 1, 1, 1))
wordcloud(count_data$word, 
          count_data$n,
          min.freq = 3,
          #max.words = 50, 
          #scale = c(3, 0.8),
          colors = pal, 
          random.color = TRUE, 
          rot.per = .2,
          vfont=c("script","plain")
          )
```

Мы готовы упаковать наш код в функцию.

```{r}
column_to_wordcloud <- function(data, colname, ...) {
  # загружаем все пакеты
  library(tidytext)
  library(dplyr)
  library(stringr)
  library(wordcloud)
  
  # пишем код, подставляя имена переменных 
  count_data <- data |> 
  filter(str_detect(Languages, "English")) |> 
  select(any_of(colname)) |>  
  unnest_tokens(output = "word", input = colname) |> 
  anti_join(stop_words) |> 
  count(word, sort = TRUE) |> 
  filter(!str_detect(word, "[0-9]"),
         !word %in% c("harry", "potter", "book"))
  
  wordcloud(count_data$word, 
          count_data$n,
          ...
          )
}
```


Попробуем запусть нашу новую функцию.

```{r message=FALSE, warning=FALSE}
column_to_wordcloud(titles, "Topics")
```

Аргумент `...` позволяет обращаться к аргументам функции `wordcloud`, которые мы специально не прописывали. 

```{r message=FALSE, warning=FALSE}
column_to_wordcloud(titles, "Topics", colors=pal, vfont=c("gothic english","plain"))
```

Внутри нашей функции есть переменная `count_data`, которую не видно в глобальном окружении. Это _локальная переменная_. Область ее видимости -- тело функции. Когда функция возвращает управление, переменная исчезает. Обратное неверно: глобальные переменные доступны в теле функции.


::: {.callout-warning icon=false}
Загрузите библиотеку `swirl`, выберите курс `R Programming` и пройдите из него урок 9 `Functions`.
:::


## `map2()`, `walk2()` & `walk2()`

Чтобы несколько раз вызывать одну и ту же функцию с двумя аргументами, используется функция `map2_*()`. Вот простой пример: 

```{r}
var1 <- seq(10, 50, 10)
var2 <- seq(1, 5, 1)

# формула
map2_int(var1, var2, ~.x+.y)
```

:::{.callout-note icon=false}
Во всех случаеях, когда у функции больше двух аргументов, используется `pmap()`.
:::

Если сохранять ничего не надо (как в случае с нашим облаком слов), то используются `walk()` и `walk2()`. Попробуем. 

```{r warning=FALSE, message=FALSE}
#| layout-ncol: 2
par(mar = c(0,0,0,0), mfrow = c(2,2))
walk(HP[1:2], column_to_wordcloud, "Title", colors=pal)
```

В этом случае второй аргумент был одинаков для двух вызовов функции. Если второй аргумент отличается, вызываем `walk2()`.

```{r message=FALSE, warning=FALSE}
#| layout-ncol: 2
par(mar = c(0,0,0,0))
walk2(HP[1:2], c("Topics", "Publisher"), column_to_wordcloud, colors = c("navyblue", "magenta", "grey"), random.color = TRUE, scale = c(4,1))
```

## Условия

Иногда необходимо ограничить выполнение функции неким условием. Короткие условия можно писать в одну строку без фигурных скобок.

```{r}
word <-  "Эйяфьятлайокудль"

if(is.character(word)) toupper(word)
```

Более сложные и множественные условия требуют фигурных скобок. Можно сравнить это с условным периодом: протасис (всегда либо `TRUE`, либо `FALSE`) в круглых скобках, аподосис в фигурных.

```{r}
if(is.character(word)) {
  toupper(word)
} else {
  print("not a character")
}
```

Теперь добавим условие внутрь нашей функции. 

Вот исходный вариант. На этот раз обойдемся без облака, а только посчитаем статистику для столбца. 

```{r}
column_counts <- function(data, colname) {
  # загружаем пакеты
  library(dplyr)
  library(stringr)
  library(tidytext)

  # пишем код, подставляя имена переменных 
  count_data <- data |> 
  filter(str_detect(Languages, "English")) |> 
  select(any_of(colname)) |>  
  unnest_tokens(output = "word", input = colname) |> 
  anti_join(stop_words) |> 
  count(word, sort = TRUE)
  
  return(count_data)
}
```

```{r message=FALSE}
column_counts(titles, "Genre")
```

Дадим пользователю возможность выбрать, хочет ли он удалять стоп-слова.

```{r}
column_counts <- function(data, colname, remove_stopwords = TRUE) {
  library(dplyr)
  library(tidytext)
  library(stringr)
  
  # базовая обработка
  count_data <- data |> 
    select(any_of(colname)) |>  
    unnest_tokens(output = "word", input = colname) 
  
  # удаляем стоп-слова, если требуется
  if (remove_stopwords) {
    count_data <- count_data |> 
      anti_join(stop_words)
  }
  
  # частотности и сортировка
  count_data <- count_data |>
    count(word, sort = TRUE)
  
  return(count_data)
}
```

Применим.

```{r message=FALSE}
column_counts(titles, "Title", remove_stopwords = FALSE)
```


## Сообщения и остановка

Часто имеет смысл добавить условие остановки или сообщение, которое будет распечатано в консоль при выполнении.

```{r}
column_counts <- function(data, colname, remove_stopwords = TRUE) {
  library(dplyr)
  library(tidytext)
  library(stringr)
  
  # Условие остановки функции, если такого столбца нет
  if (!(colname %in% names(data))) {
    stop(paste("Столбец", colname, "не найден в данных!"))
  }
  
  # Сообщение о выбранном режиме стоп-слов
  if (remove_stopwords) {
    message("Стоп-слова будут удалены.")
  } else {
    message("Стоп-слова НЕ будут удалены.")
  }
  
  # базовая обработка
  count_data <- data |> 
    select(any_of(colname)) |>  
    unnest_tokens(output = "word", input = colname)
  
  # удаляем стоп-слова, если требуется
  if (remove_stopwords) {
    count_data <- count_data |> 
      anti_join(stop_words)
  }
  
  # частотности и сортировка
  count_data <- count_data |>
    count(word, sort = TRUE)
  
  return(count_data)
}
```

```{r error=TRUE, message=FALSE}
column_counts(titles, "Genre")
column_counts(titles, "Date")
```


## Бонус: Интерактивное облако

Интерактивное облако слов можно построить с использованием пакета `wordcloud2`. Сделаем облако в форме шляпы волшебника!

```{r message=FALSE}
title_counts <- titles |> 
  column_counts("Title") |> 
  rename(freq = n)

title_counts |> 
  print()
```

```{r eval=FALSE}
# devtools::install_github("lchiffon/wordcloud2")
library(wordcloud2)

wordcloud2(title_counts, 
           figPath = "./images/hat.png",
           size = 1.5,
           backgroundColor="black",
           color="random-light", 
           fontWeight = "normal"
)
```

![](./images/hat_wordcloud.jpg)

## Видео к уроку

- Видео [2024](https://vkvideo.ru/video91786643_456239042)
- Видео [2025](https://vk.com/video91786643_456239076)

## Домашнее задание 

Напишите функцию `count_words`, которая будет:

- принимать на входе токенизированный (разбитый на слова) текст (символьный вектор!),
- переводить все слова в нижний регистр,
- считать частотность для каждого слова,
- упорядочивать по убыванию,
- возвращать n наиболее частотных слов (без частотностей, только слова!) в виде вектора.


N.B. Эту задачу можно решить разными способами; подойдет любой, если на выходе будут нужные слова. Как вы назовете аргументы функции, неважно. У аргумента для числа возвращаемых слов значение по умолчанию поставьте 10.
Имя функции должно быть строго `count_words`.

Тренироваться можете на векторе `languageR::alice`, но в сдаваемом файле должна быть только функция.

Вам могут пригодиться функции `table`, `sort`, `tolower`, `names` -- посмотрите документацию, чтобы понять, как они работают.

Файл под названием `hw4.R` загрузите в GitHub Classroom по [ссылке](https://classroom.github.com/a/M2VQsiR_) до 11 октября 11:00 мск. 


