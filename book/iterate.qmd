# Циклы, условия, функции

В этом уроке мы познакомимся с итерационными конструкциями и функционалами, т.е. такими функциями, которые принимают в качестве аргумента другую функцию. Они нужны для того, чтобы можно было что-то сделать много раз: например, прочитать сразу 100 файлов из директории, построить и сохранить одной командой несколько графиков или сделать множество случайных выборок из большого текстового корпуса. 

Общее правило таково: если вы скопировали кусок кода больше трех раз, то самое время задуматься об итерации. Это позволит избежать ошибок при копировании и сделает код более легким и читаемым. 


## Циклы и их аналоги

Хорошая новость: многие функции в R уже векторизованы, и если необходимо применить функцию к каждому элементу вектора,  в большинстве случаев достаточно просто вызвать функцию. Это называется _векторизация_. 

Например, у нас есть символьный вектор, и мы хотим узнать количество символов в каждом слове.

```{r}
homer <- c("в", "мысли", "ему", "то", "вложила", "богиня", "державная", "гера")
```

Для каждого компонента вектора необходимо выполнить одну итерацию цикла, в нашем случае -- применить функцию `nchar()`. В некоторых языках программирования это делается как-то так:

```{r}
for(i in homer) print(nchar(i))
```

:::{.callout-note icon=false}
В циклах часто используется буква `i`. Но никакой особой магии в ней нет, имя переменной можно изменить.
:::

Мы написали цикл `for`, который считает количество букв для каждого слова в векторе. Как видно, все сработало. Но в R это избыточно, потому что `nchar()` уже векторизована:

```{r}
nchar(homer)
```

Это относится не только ко многим встроенным функциям R, но и к даже к операторам. `x + 4` в действительности представляет собой `+(x, 4)`:

```{r}
x <- c(1.2, 2.51, 3.8)

`+`(x, 4) 
```

Ключевую роль здесь играет переработка данных, о которой мы говорили в первом уроке: короткий вектор повторяется до тех пор, пока его длина не сравняется с длиной более длинного вектора. Как-то так:

$$ \left(
    \begin{array}{c}
      1.2 \\
      2.51 \\
      3.8
    \end{array}
  \right) + \left(
    \begin{array}{c}
      4 \\
      4 \\
      4
    \end{array}
  \right) $$


Лишний цикл может замедлить вычисления. Проверим. Дан вектор `x <- c(3, 5, 7, 13)`. Необходимо возвести в квадрат каждое число, а из результата вычесть 100. Выполним двумя способами. 

```{r}
library(tictoc)
x <- c(2, 3, 5, 7, 11, 13)

# способ первый
tic()
for (i in x) print(i^2 - 100)
toc()

# способ второй 
tic()
x^2 - 100
toc()
```

> Один из главных принципов программирования на R гласит, что следует обходиться без циклов, а если это невозможно, то циклы должны быть простыми.
>
> --- Нормат Мэтлофф

Для работы со списками циклы тоже чаще всего избыточны. Снова воспользуемся списком печенек из коллекции `rcorpora`.


```{r}
library(rcorpora)
my_list <-  corpora("foods/breads_and_pastries")
paste("Длина списка:", length(my_list))
names(my_list)
```
Как узнать длину каждого вложенного в список вектора? Попробуем цикл (снова заметим время):

```{r}
tic()
for (i in 1:length(my_list)) print(length(my_list[[i]]))
toc()
```

Но в базовом R для таких случаев существуют функционалы `lapply()` и `sapply()`. Они принимают на входе список и функцию и применяют функцию к каждому элементу списка. Получается быстрее:  

```{r}
tic()
lapply(my_list, length)
toc()
```
Функция `sapply()` упростит результат до вектора (s означает simplify):

```{r}
tic()
sapply(my_list, length)
toc()
```

Если в виде списка хранится корпус, то так можно сделать, например, случайную выборку. Заметьте, как переданы аргументы функции `sample()`.

```{r}
lapply(my_list[2:3], sample, 5, replace = TRUE)
```
Может быть, с датафреймами будут полезны циклы? Например, так.

```{r}
df <- data.frame(author=c("Joe","Jane"), year=c(1801,1901), reprints=c(TRUE,FALSE))
df
```

```{r}
tic()
for (i in seq_along(df)) {
 print(class(df[,i]))
}
toc()
```
Но и здесь можно ускориться. Второй аргумент `apply` означает, что мы работаем со столбцами (1 - строки).

```{r}
tic()
apply(df, 2, class)
toc()
```

Есть еще `vapply()`, `tapply()` и  `mapply()`, но и про них мы не будем много говорить, потому что все их с успехом заменяет семейство `map_()` из пакета `purrr` в `tidyverse`. 

::: {.callout-warning icon=false}
Пройдите урок 10 `lapply and sapply` и урок 11 `vapply and tapply` из курса `R Programming` в `swirl`.
:::

Тем не менее, перед освоением семейства `map_()` стоит потренироваться работать с обычными циклами, особенно если вам не приходилось иметь с ними дела (например, на Python). Несмотря на все недостатки, цикл `for` интуитивно понятен и часто проще начинать именно с него. Поэтому, прежде чем двинуться дальше, сделаем несколько упражнений из [@wickham2016, 316].


:::{.callout-warning icon=false}

(@) Посчитайте среднее для всех столбцов в `mtcars`.
(@) Определите тип данных во всех столбцах `nycflights13::flights`.
(@) Посчитайте число уникальных значений в каждом столбце `iris`.
(@) Сгенерируйте 10 случайных чисел из нормального распределения - это делает функция  `rnorm()` - со средним -10, 0, 10.

:::


:::{.callout-warning icon=false}
Попробуйте избавиться от цикла `r emo::ji("silly")`.
:::

```{r}
# стоит заглянуть в документацию к функции
out <- ""
for (x in letters) {
  out <- stringr::str_c(out, x)
}

# ответ - всего пять символов...
x <- sample(100)
sd <- 0
for (i in seq_along(x)) {
  sd <- sd + (x[i] - mean(x)) ^ 2
}
sd <- sqrt(sd / (length(x) - 1))

# надо понять, что тут происходит 
x <- runif(100)
out <- vector("numeric", length(x))
out[1] <- x[1]
for (i in 2:length(x)) {
  out[i] <- out[i - 1] + x[i]
}
```


## Условия

Иногда необходимо ограничить выполнение функции неким условием. Короткие условия можно писать в одну строку без фигурных скобок.

```{r}
y <-  "Эйяфьятлайокудль"

if(nchar(y) > 10) print("много букв")
```

Более сложные и множественные условия требуют фигурных скобок. Можно сравнить это с условным периодом: протасис (всегда либо TRUE, либо FALSE) в круглых скобках, аподосис в фигурных.

```{r}
if (nchar(y) > 10) {
  print("много букв")
} else if (nchar(y) < 5) {
  print("мало букв")
} else {
  print("норм букв")
}
```

Также в R можно использовать специальную функцию:

```{r}
ifelse(nchar(y) > 10, "много букв", "мало букв")
```

Прописывая условие, не забывайте, что применение булева оператора к вектору возвращает логический вектор:

```{r}
x <- c(1:10)
x >= 5
```

Такое условие вернет ошибку.

```{r error=TRUE}
if (x >= 5) print("все сломалось")
```

Можно скорректировать код так:

```{r}
if (any(x >= 5)) print("все сработало")
```

По той же причине внутри условия не надо использовать логические операторы `|` ("или") или `&` ("и"), потому что они векторизованы:

```{r}
x < 3 | x > 7
```

## Функции

Функция и код -- не одно и то же. Чтобы стать функцией, кусок кода должен получить имя. Но зачем давать имя коду, который и так работает?

Вот три причины, которые [приводит](https://r4ds.had.co.nz/functions.html) Хадли Уикхем:

-   у функции есть выразительное имя, которое облегчает понимание кода;
-   при изменении требований необходимо обновлять код только в одном месте, а не во многих;
-   меньше вероятность случайных ошибок при копировании (например, обновление имени переменной в одном месте, но не в другом)

> Writing good functions is a lifetime journey.
>
> --- Hadley Wickham

Машине все равно, как вы назовете функцию, но тем, кто будет читать код, не все равно. Имена должны быть информативы (поэтому функция `f()` -- плохая идея). Также не стоит переписывать уже существующие в R имена!

Далее следует определить _формальные аргументы_ и, при желании, _значения по умолчанию_. Тело функции пишется в фигурных скобках. В конце кода функции располагается команда `return()`; если ее нет, то функция возвращает последнее вычисленное значение (см. [здесь](https://r4ds.had.co.nz/functions.html) о том, когда что предпочесть).

Написание функций -- навык, который можно бесконечно совершенствовать. Начать проще всего с обычного кода. Убедившись, что он работает как надо, вы можете упаковать его в функцию.

Например, нам нужна функция, которая ищет совпадения в двух векторах и возвращает совпавшие элементы. Сначала решим задачу для двух векторов.

```{r}
line1 <- c("гнев", "богиня", "воспой")
line2 <- c("в", "мысли", "ему", "то", "вложила", "богиня", "державная", "гера")
idx <- which(line2 %in% line1) # 2
line2[idx]
```

Теперь заменяем фактические переменные на формальные.

```{r}
common_words <- function(x, y){
  idx <- which(x %in% y)
  x[idx]
}
```

И применяем к новым данным.

```{r}
line3 <- c("лишь", "явилась", "заря", "розоперстая", "вестница", "утра")
line4 <- c("вестница", "утра", "заря", "на", "великий", "олимп", "восходила")
common_words(line4, line3)
```

::: {.callout-warning icon=false}
Загрузите библиотеку `swirl`, выберите курс `R Programming` и пройдите из него урок 9 `Functions`.
:::

::: {.callout-tip icon=false}
Для просмотра исходного кода любой функции необходимо...
:::

```{r echo=FALSE}
library(checkdown)
check_question(
  answer = "набрать имя функции без аргументов и без скобок",
  options = c("набрать имя функции без аргументов и без скобок", "вызвать help к функции", "единственный способ — найти код функции в репозитории на GitHub", "использовать специальную функцию для просмотра кода"),
  right = "Все верно!", 
  wrong = "Не совсем...", 
  type = "radio",
  random_answer_order = TRUE)
```

</br>

Напишем функцию, которая будет центрировать данные, то есть вычитать среднее из каждого значения (забудем на время, что это уже делает базовая `scale()`):

```{r}
center <- function(x){ 
  n = x - mean(x)
  return(n) 
}

x <- c(5, 10, 15)
center(x) 
```

Внутри нашей функции есть переменная `n`, которую не видно в глобальном окружении. Это _локальная переменная_. Область ее видимости -- тело функции. Когда функция возвращает управление, переменная исчезает. Обратное неверно: глобальные переменные доступны в теле функции.

Функция может принимать произвольное число аргументов. Доработаем наш код:

```{r}
center <- function(x, na.rm = F){
  if(na.rm) { x <- x[!is.na(x)]} # добавим условие
  x - mean(x) # на этот раз без return()
}

x <- c(5, 10, NA)
center(x)
```

Что произошло? Почему следующий код выдает другой результат?

```{r}
center(x, na.rm = T)
```

Вычисления в R _ленивы_, то есть они откладываются до тех пор, пока не понадобится результат. Если вы зададите аргумент, который не нужен в теле функции, ошибки не будет.

```{r}
center <- function(x, na.rm = F, what_is_your_name){
  if(na.rm) { x <- x[!is.na(x)]} # добавим условие
  x - mean(x) # на этот раз без return()
}

center(x, na.rm = T)
center(x, na.rm = T, what_is_your_name = "Locusclassicus")
```

Часто имеет смысл добавить условие остановки или сообщение, которое будет распечатано в консоль при выполнении.

```{r eval=FALSE}
center <- function(x){
  if (length(x) == 1) {stop("Отстань, старушка, я в печали.")}
  x - mean(x) # на этот раз без return()
}

x <- 10
center(x) # вернет ошибку
```


:::{.callout-warning icon=false}
Напишите функцию `awesome_plot`, которая будет принимать в качестве аргументов два вектора, трансформировать их в тиббл и строить диаграмму рассеяния при помощи ggplot(). Задайте цвет и прозрачность точек, а в подзаголовке выведите коэффициент корреляции.
:::

:::{.callout-warning icon=false}

(@) Напишите код, который распечатает стихи детской песни ["Alice the Camel"](https://supersimple.com/song/alice-the-camel/). 

(@) Превратите детскую потешку ["Ted in the Bed"](https://supersimple.com/song/ten-in-the-bed/) в функцию. Обобщите до любого числа спящих. 

(@) Запишите в виде функции текст песни ["99 Bottles of Beer on the Wall"](https://www.99-bottles-of-beer.net/lyrics.html). Обобщите до любого числа любых напитков на любой поверхности.

:::

:::{.callout-warning icon=false}
Напишите функцию, которая будет говорить "доброе утро", "добрый день" или "добрый вечер" в зависимости от времени суток. Используйте `lubridate::now()` в качестве значения аргумента по умолчанию. 
:::


## Purrr

По-настоящему мощный инструмент для итераций -- это пакет `purrr` из семейства [`tidyverse`](https://purrr.tidyverse.org/). Разработчики предупреждают, что потребуется время, чтобы овладеть этим инструментом [@wickham2016].

> You should never feel bad about using a loop instead of a map function. The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work.
>
> --- Hadley Wickham & Garrett Grolemund

В семействе функций `map_` из этого пакета всего [23 вариации](https://adv-r.hadley.nz/functionals.html). Вот основные из них:

-   `map()`
-   `map_lgl()`
-   `map_int()`
-   `map_dbl()`
-   `map_chr()`

Все они принимают на входе данные и функцию (или формулу), которую следует к ним применить, и возвращают результат в том виде, который указан после подчеркивания. Просто `map()` вернет список, а `map_int()` -- целочисленный вектор, и т.д. 

Воспользуемся возможностями `purrr`, чтобы исследовать датасет `starwars` из пакета `dplyr`. Для начала узнаем число отсутствующих значений в каждом столбце. Косая черта (`\`) указывает на то, что мы используем анонимную функцию

```{r message=FALSE}
library(tidyverse)
starwars <- starwars
map_int(starwars, \(x) sum(is.na(x)))
```

Обратите внимание, что `map_int`, как и `map_dbl` возвращает именованный вектор. Чтобы избавиться от имен, можно использовать `unname()`:

```{r}
map_chr(starwars, class) |> 
  unname()
```

:::{.task .code}
Используйте `map_dbl` и `n_distinct`, чтобы узнать число уникальных наблюдений в каждом столбце.
:::


Если функция принимает дополнительные аргументы, их можно задать после названия функции. В таком случае для _каждого_ вызова функции будет использовано это значение аргумента. В примере ниже это аргумент `na.rm`.

```{r}
starwars |> 
  select(mass, height) |> 
  map(mean, na.rm = TRUE)
```
При вызове `map_df` есть дополнительная возможность сохранить названия столбцов, используя аргумент `.id`:

```{r}
starwars |> 
  map_df(~data.frame(unique_values = n_distinct(.x),
                     col_class = class(.x)),
         .id = "variable"
         )
```

Функции `map` можно передать пользовательскую функцию. 
Для примера создадим функцию `describe_vec()`, которая возвращает строку с длиной и классом вектора, и применим ее к хлебо-булочному списку из примеров выше.

```{r}
# пользовательская функция
describe_vec <- function(vec){
  l = paste("Длина вектора: ", length(vec))
  c = paste("Класс вектора: ", class(vec))
  result = paste(l, c, sep = " | ")
  return(result)
}

map_chr(my_list, describe_vec) |> 
  unname()
```

Кроме того, мы можем передать `map` анонимную функцию (вместо `function` можно поставить `\`):

```{r}
map_chr(my_list, 
        function(x) paste("Длина вектора: ", length(x))
        )
```


Если необходимо несколько раз вызывать одну и ту же функцию с двумя аргументами, используется функция [`map2()`](https://adv-r.hadley.nz/functionals.html). Аргументы, которые меняются при каждом вызове, пишутся до функции; аргументы, которые остаются неизменны, -- после.


```{r}
mean = list(5, 10, -3)
sd = list(1, 5, 50)
map2(mean, sd, rnorm, n = 5)
```

</br>

![_Как работает `map2()_`](https://d33wubrfki0l68.cloudfront.net/68a21c4a103426c3b311c9dcfad8fe379d4892f1/55c9d/diagrams/lists-map2.png){width="60%"}

</br>

Это можно обобщить следующим образом ([источник](https://adv-r.hadley.nz/functionals.html#map2){width="60%"}):

![](https://d33wubrfki0l68.cloudfront.net/7a545699ff7069a98329fcfbe6e42b734507eb16/211a5/diagrams/functionals/map2-arg.png)

Можно было бы предположить, что должны быть и map3(), map4() и т.д., но во всех случаеях, когда у функции больше двух аргументов, используется `pmap()`.


:::{.callout-warning icon=false}
Установите курс `swirl::install_course("Advanced R Programming")` и пройдите из него урок 3 `Functional Programming with purrr`.
:::

Несколько вопросов для самопроверки.

:::{.callout-tip icon=false}
Функции-предикаты (predicate functions) возвращают `TRUE` или `FALSE`. Выберите из списка все функции-предикаты.
:::

```{r echo=F, results='asis'}
check_question(options = c("every()", "some()", "none()", "has_element()", "is.factor()", "keep()", "discard()", "is.numeric()", "detect()"), 
               type = "checkbox",
               answer = c("every()", "some()", "none()", "has_element()", "is.factor()", "is.numeric()"), 
               right = "Правильно!",
               wrong = "Что-то тут лишнее 🤔")
```

</br>

:::{.callout-tip icon=false}
Какие из функций ниже принимают *в качестве аргумента* функции-предикаты?
:::

```{r echo=F, results='asis'}
check_question(options = c("every()", "some()", "none()", "has_element()", "is.factor()", "keep()", "discard()", "is.numeric()", "detect()"), 
               type = "checkbox",
               answer = c("keep()", "discard()", "detect()"), 
               right = "Верно!",
               wrong = "Не совсем 🤔")
```


## Гарри Поттер: цикл vs. `map_()`

Как вы уже поняли, одни и те же задачи можно решать при помощи циклов и при помощи `map_`. Мы потренируемся на датасете, который в 2023 г. был доступен на сайте Британской библиотеки (<https://www.bl.uk/>), но потом оттуда исчез (но у нас сохранилась копия). 

Датасет представляет собой набор файлов .csv, содержащих метаданные о ресурсах, связанных с Гарри Поттером, из коллекций Британской библиотеки. Первоначально он был выпущен к 20-летию публикации книги «Гарри Поттер и философский камень» 26 июня 2017 года и с тех пор ежегодно обновлялся. Всего в датасете пять файлов, каждый из которых содержит разное представление данных. 

Скачаем архив.

```{r eval=FALSE}
my_url <- "https://github.com/locusclassicus/text_analysis_2024/raw/main/files/HP.zip"
download.file(url = my_url, destfile = "../files/HP.zip")
```

После этого переходим в директорию с архивом и распаковываем его.

```{r eval=FALSE}
unzip("../files/HP.zip")
```

Сохраним список всех файлов с расширением .csv, используя подходящую функцию из base R.

```{r}
my_files <- list.files("../files/HP", pattern = ".csv", full.names = TRUE)
my_files
```
### Цикл

Теперь напишем цикл, который

(1) прочитает все файлы из my_files, используя для этого функцию read_csv() из пакета readr;
(2) для каждого датасета выяснит количество рядов _без_ NA в столбце BNB Number;
(3) разделит число таких рядов на общее число рядов;
(4) вернет таблицу c четырьми столбцами: 

    - название файла (id),
    - число рядов (total),
    - число рядов без NA (complete),
    - доля полных рядов (ratio).
  
Сначала создаем таблицу, в которую будем складывать результат. 

```{r}
my_files_short <- list.files("../files/HP", pattern = ".csv")

my_df <- data.frame(id = my_files_short, 
                    total = 0,
                    complete = 0,
                    ratio = 0)

my_df
```

Теперь тело цикла:

```{r}
for (i in 1:length(my_files)) {

  # читаем очередной файл из my_files
  current_file <- my_files[i]
  current_df <- readr::read_csv(current_file, show_col_types = FALSE) 

  # выявляем общее число рядов и число рядов без NA в BNB number
  # из-за пробела в названии столбца BNB number нужно использовать
  # с бэктиками ``, а не с "такими" или 'такими' кавычками 
  current_total <- nrow(current_df)
  current_complete <- sum(!is.na(current_df$`BNB number`))
    

  # помещаем значения в нужное место в заранее созданном my_df вместо нулей
  my_df$total[i] <- current_total  
  my_df$complete[i] <- current_complete
  my_df$ratio[i] <- current_complete / current_total
}
```

Смотрим на результат.

```{r}
my_df
```

### `map_()`

Теперь исследуем датасет при помощи функционалов. Прочитаем все файлы одним вызовом функции.

```{r}
# чтение файлов 
HP <- map(my_files, read_csv, col_types = cols())
```

Объект `HP` -- это список. В нем пять элементов, так как на входе у нас было пять файлов. Для удобства назначим имена элементам списка. 

```{r}
names(HP) <- my_files_short
```

![](images/HP.png)

Начнем с простого: при помощи `map` можно извлечь столбцы (по имени) или ряды (по условию) из всех пяти таблиц. Прежде чем выполнить код ниже, подумайте, как будет выглядеть результат. 

```{r eval=FALSE}
# извлечь столбцы
map(HP, select, `BNB number`)

# извлечь ряды
map(HP, filter, !(is.na(`BNB number`)))
```

:::{.callout-warning icon=false}
Извлеките все уникальные названия (столбец `Title`) из всех пяти таблиц в `HP`. Используйте функцию `distinct`. 
:::


Что, если мы не знаем заранее, какие столбцы есть _во всех пяти таблицах_, и хотим это выяснить? Для этого подойдет функция `reduce()` из того же `purrr`. Она принимает на входе вектор (или список) и  функцию и применяет функцию последовательно к каждой паре значений.

![[_Источник_.](https://adv-r.hadley.nz/functionals.html#reduce)](https://d33wubrfki0l68.cloudfront.net/9c239e1227c69b7a2c9c2df234c21f3e1c74dd57/eec0e/diagrams/functionals/reduce.png){ width="60%" }

</br>

Воспользуемся этим, чтобы найти общие для всех таблиц имена столбцов.

```{r}
map(HP, colnames) |> 
  reduce(intersect)
```

Еще одна неочевидная возможность функции `reduce` - объединение нескольких таблиц в одну одним вызовом. Например, так:

```{r message=FALSE}
HP_joined <- HP |> 
  reduce(left_join)

HP_joined
```

### EDA

Теперь можно почистить данные и построить несколько разведывательных графиков.

```{r warning=FALSE, message=FALSE}
library(ggplot2)
library(tidyr)

data_sum <- HP_joined |> 
  separate(`Date of publication`, into = c("year", NA)) |> 
  separate(`Country of publication`, into = c("country", NA), sep = ";") |>
  mutate(country = str_squish(country)) |> 
  mutate(country = 
           case_when(country == "England" ~ "United Kingdom",
                     country == "Scotland" ~ "United Kingdom",
                     TRUE ~ country)) |> 
  filter(!is.na(year)) |> 
  filter(!is.na(country)) |> 
  group_by(year, country) |> 
  summarise(n = n()) |> 
  arrange(-n)
  

data_sum
```


```{r}
data_sum |> 
  ggplot(aes(year, n, fill = country)) + 
  geom_col() + 
  xlab(NULL) +
  theme(axis.text.x = element_text(angle = 90))
```

В качестве небольшого бонуса к этому уроку построим облако слов. Вектор слов возьмем из столбца `Topic`. 

```{r warning=FALSE}
data_topics <- HP_joined |> 
  filter(!is.na(Topics)) |> 
  separate(Topics, into = c("topic", NA)) |> 
  mutate(topic = tolower(topic)) |> 
  group_by(topic) |> 
  summarise(n = n()) |> 
  filter(!topic %in% c("harry", "rowling", "potter", "children", "literary"))


pal <- c("#f1c40f", "#34495e", 
         "#8e44ad", "#3498db",
         "#2ecc71")

library(wordcloud)
par(mar = c(1, 1, 1, 1))
wordcloud(data_topics$topic, 
          data_topics$n,
          min.freq = 3,
          #max.words = 50, 
          scale = c(3, 0.8),
          colors = pal, 
          random.color = T, 
          rot.per = .2,
          vfont=c("script","plain")
          )
```

Интерактивное облако слов можно построить с использованием пакета `wordcloud2`. Сделаем облако в форме шляпы волшебника!

```{r eval=FALSE}
# devtools::install_github("lchiffon/wordcloud2")
library(wordcloud2)


wordcloud2(data_topics, 
           figPath = "./book/images/Wizard-Hat.png",
           size = 1.5,
           backgroundColor="black",
           color="random-light", 
           fontWeight = "normal",
)

```

![](./images/hat_wordcloud.jpg)

Теперь попробуйте сами. 

:::{.callout-warning icon=false}
Практическое задание "Алиса в стране чудес"
:::


```{r eval=FALSE}
# постройте облако слов для "Алисы в стране чудес"

library(languageR)
library(dplyr)
library(tidytext)

# вектор с "Алисой"
alice <- tolower(alice)

# частотности для слов
freq <- as_tibble(table(alice)) |> 
  rename(word = alice)

# удалить стоп-слова
freq_tidy <- freq |> 
  anti_join(stop_words) 
# возможно, вы захотите произвести и другие преобразования

# облако можно строить в любой библиотеке
```

