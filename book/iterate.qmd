# Функциональное программирование

```{r echo=FALSE}
library(checkdown)
```

## Зачем писать функции?

Программировать на R -- прежде всего значит писать функции. Несмотря на десятки тысяч функций, обитающих в тысячах пакетов, рано или поздно вам понадобится своя функция, которая будет подходить для решения именно ваших задач.

Функция и код -- не одно и то же. Чтобы стать функцией, кусок кода должен, как минимум, получить имя. Зачем давать имя коду, который и так работает?

Вот три причины, которые [приводит](https://r4ds.had.co.nz/functions.html) Хадли Уикхем:

-   у функции есть выразительное имя, которое облегчает понимание кода;
-   при изменении требований необходимо обновлять код только в одном месте, а не во многих;
-   меньше вероятность случайных ошибок при копировании (например, обновление имени переменной в одном месте, но не в другом)

> Writing good functions is a lifetime journey.
>
> --- Hadley Wickham

Чтобы определить функцию, необходимо дать ей имя. Машине все равно, как вы назовете функцию, но тем, кто будет читать код, не все равно. Имена должны быть информативы (поэтому функция `f()` -- плохая идея). Также не стоит переписывать уже существующие в R имена!

Далее следует определить **формальные аргументы** и, при желании, **значения по умолчанию**. Тело функции пишется в фигурных скобках. В конце кода функции располагается команда `return()`; если ее нет, то функция возвращает последнее вычисленное значение (см. [здесь](https://r4ds.had.co.nz/functions.html) о том, когда что предпочесть).

Написание функций -- навык, который можно бесконечно совершенствовать. Начать проще всего с обычного кода. Убедившись, что он работает как надо, вы можете упаковать его в функцию.

Например, нам нужна функция, которая ищет совпадения в двух векторах и возвращает совпавшие элементы. Сначала решим задачу для двух векторов.

```{r}
x <- c("гнев", "богиня", "воспой")
y <- c("в", "мысли", "ему", "то", "вложила", "богиня", "державная", "гера")
idx <- which(x %in% y) # 2
x[idx]
```

Теперь заменяем фактические переменные на формальные.

```{r}
common_words <- function(x, y){
  idx <- which(x %in% y)
  x[idx]
}
```

И применяем к новым данным.

```{r}
x <- c("лишь", "явилась", "заря", "розоперстая", "вестница", "утра")
y <- c("вестница", "утра", "заря", "на", "великий", "олимп", "восходила")
common_words(x, y)
```

Ура, все работает! Запомните простое правило: если вы трижды скопировали код, пора писать функцию!

::: {.callout-warning icon=false}
Загрузите библиотеку `swirl`, выберите курс `R Programming E` и пройдите из него урок 9 `Functions`.
:::

</br>

::: {.callout-tip icon=false}
Для просмотра исходного кода любой функции необходимо...
:::

```{r echo=FALSE}
checkdown::check_question(
  answer = "набрать имя функции без аргументов и без скобок",
  options = c("набрать имя функции без аргументов и без скобок", "вызвать help к функции", "единственный способ — найти код функции в репозитории на GitHub", "использовать специальную функцию для просмотра кода"),
  right = "Все верно!", 
  wrong = "Не совсем...", 
  type = "radio",
  random_answer_order = TRUE)
```

## Область видимости переменных

Напишем функцию, которая будет центрировать данные, то есть вычитать среднее из каждого значения (забудем на время, что это уже делает базовая `scale()`):

```{r}
center <- function(x){ 
  n = x - mean(x)
  return(n) 
}

x <- c(5, 10, 15)
center(x) 
```

Внутри нашей функции есть переменная `n`, которую не видно в глобальном окружении. Это **локальная переменная**. Область ее видимости -- тело функции. Когда функция возвращает управление, переменная исчезает. Обратное неверно: глобальные переменные доступны в теле функции.

## Аргументы функции

Функция может принимать произвольное число аргументов. Доработаем наш код:

```{r}
center <- function(x, na.rm = F){
  if(na.rm) { x <- x[!is.na(x)]} # добавим условие
  x - mean(x) # на этот раз без return()
}

x <- c(5, 10, NA)
center(x)
```

Что произошло? Почему следующий код выдает другой результат?

```{r}
center(x, na.rm = T)
```

Вычисления в R **ленивы**, то есть они откладываются до тех пор, пока не понадобится результат. Если вы зададите аргумент, который не нужен в теле функции, ошибки не будет.

```{r}
center <- function(x, na.rm = F, what_is_your_name){
  if(na.rm) { x <- x[!is.na(x)]} # добавим условие
  x - mean(x) # на этот раз без return()
}

center(x, na.rm = T)
center(x, na.rm = T, what_is_your_name = "Locusclassicus")
```

Часто имеет смысл добавить условие остановки или сообщение, которое будет распечатано в консоль при выполнении.

```{r eval=FALSE}
center <- function(x){
  if (length(x) == 1) {stop("И без меня посчитаете")}
  x - mean(x) # на этот раз без return()
}

x <- 10
center(x) # вернет ошибку
```

## Векторизируй это

Теперь самое главное: если мы хотим применить функцию к каждому элементу вектора, то в большинстве случаев достаточно просто вызвать функцию. Это называется **векторизация**.

Это относится не только ко многим встроенным функциям R, но и к даже к операторам. `x + 4` в действительности представляет собой `+(x, 4)`:

```{r}
x <- c(1.2, 2.51, 3.8)

`+`(x, 4) 
```

Ключевую роль здесь играет переработка данных, о которой мы уже говорили: короткий вектор повторяется до тех пор, пока его длина не сравняется с длиной более длинного вектора. Как-то так:

$$\left(
    \begin{array}{c}
      1.2 \\
      2.51 \\
      3.8
    \end{array}
  \right) + \left(
    \begin{array}{c}
      4 \\
      4 \\
      4
    \end{array}
  \right)$$

Понимание того, как действуют векторизованные вычисления, очень важно для написания корректного кода. Посмотрите на пример ниже: почему функция `is_article()` возвращает два значения, хотя на входе только одно?

```{r}
is_article <- function(x){
  x == c("a", "the")
}

x <- "the"
is_article(x)
```

Поскольку векторы сравниваются поэлементно, то функция ниже вернет разный результат в зависимости от того, в каком порядке заданы элементы:

```{r}
x <- c("just", "the")
is_article(x) 

x <- c("the", "just")
is_article(x) # взрыв мозга
```

</br>

::: {.callout-tip icon=false}
Подумайте, вектор какого типа и какой длины вернет код ниже.
:::

```{r eval=FALSE}
is_article <- function(x) { 
  articles <- c("a", "the")
  x %in% articles
}

x <- c(rep("the", 5), rep("if", 5))
is_article(x)
```

</br>

:::{.callout-warning icon=false}
Напишите функцию `awesome_plot`, которая будет принимать в качестве аргументов два вектора, трансформировать их в тиббл и строить диаграмму рассеяния при помощи ggplot(). Задайте цвет и прозрачность точек, а в подзаголовке выведите коеффицент корреляции.
:::

</br>

## Векторизованные конструкции

### Циклы

Еще один способ повторить действия в R, при этом не копируя один и тот же код много раз, -- это циклы.

> Один из главных принципов программирования на R гласит, что следует обходиться без циклов, а если это невозможно, то циклы должны быть простыми.
>
> --- Нормат Мэтлофф

Существует два основных цикла: цикл `for` и цикл `while`. На практике чаще используется цикл `for`, потому что цикл `while` легко отправить в бесконечность.

#### Цикл `for`

Цикл ниже считает количество букв для каждого слова в векторе. Вы можете заметить, что в циклах часто используется буква `i`. Но никакой особой магии в ней нет, имя переменной можно изменить.


```{r}
y <- c("в", "мысли", "ему", "то", "вложила", "богиня", "державная", "гера")

result <- c()
for(i in y) { 
  n <- nchar(i)
  result <- c(result, n)
}

result
```

В данном случае мы указали, что надо совершить какую-то операцию над каждым элементом вектора; но по сути это избыточно, потому что `nchar()` тоже векторизована.

```{r}
nchar(y)
```

Поэтому чаще цикл `for` применяют к другим структурам данных. Например, к спискам и датафреймам. Загрузим и немного изменим датасет о гапаксах у Платона. Изменения нужны, так как цикл работает для данных только одного типа, в то время как в нашей таблице столбец `dialogue` содержит символьные строки, а `group` -- фактор. Обратите внимание, что оператор `pipe` и функции из `dplyr` работают и с обычными датафреймами:

```{r echo=FALSE, message=F}
library(tidyverse)
load("../data/hapax_plato.Rdata")
```

```{r}
rownames(hapax_plato) <- hapax_plato$dialogue 

hapax_plato_num <- hapax_plato %>% select(-group, -dialogue) # 
str(hapax_plato_num)
```

Сейчас все данные в нашей таблице имеют тип `chr`, то есть строка, и при помощи цикла мы можем их трансформировать.

```{r}
for (i in seq_along(hapax_plato_num)) {  # seq_along ≈ 1:length(x)
  hapax_plato_num[,i] <- as.numeric(hapax_plato_num[,i])
}

str(hapax_plato_num) # убеждаемся, что все получилось
```

При помощи циклов можно не только трансформировать данные, но и создавать новые. Чтобы посчитать среднее для столбца, цикл писать не надо: для этого есть функция `colSums()` (или, для других задач, `rowSums()`). А вот посчитать медиану таким образом не получится, тут может пригодиться цикл.

```{r}
library(tictoc)

tic()
medians <- c()
for (i in seq_along(hapax_plato_num)) { 
  m <- median(hapax_plato_num[,i])
  medians <- c(medians, m)
}
toc()

medians
```

Мы сохранили результат, инициировав пустой вектор, к которому затем привязали данные по каждому столбцу. Это не всегда хорошая идея, поскольку для больших данных может сильно замедлить цикл[^04-iterate-1]. Еще один способ -- сразу инициировать вектор нужной длины. Сравнить скорость можно при помощи функций из пакета `tictoc`.

[^04-iterate-1]: <https://r4ds.had.co.nz/iteration.html>

```{r}
tic()
medians <- vector("double", ncol(hapax_plato_num))
for (i in seq_along(hapax_plato_num)) { 
  medians[i] <- median(hapax_plato_num[,i])
}
toc()
```

Второй способ чуть быстрее, и для больших данных это может быть существенно.

#### Цикл `while`

Как уже говорилось, с циклами `while` стоит быть осторожнее. Посмотрите, например, на этот цикл, который перебирает слова, пока не найдет слово длиной 6 букв. Что могло пойти не так?

```{r}
tic()
k <- 0
n <- 0
while (n != 6) {
  k <- k + 1
  n <- nchar(y[k])
}
y[k]
toc()
```

То же самое можно сделать без цикла, причем быстрее!

```{r}
tic()
y[nchar(y) == 6][1] 
toc()
```

В целом, ничего незаконного в циклах нет, но

-   множество вложенных друг в друга циклов сложно воспринимать;
-   порой они могут замедлить выполнение кода.

И в базовом R, и в диалекте tidyverse для этого есть несколько решений, о которых скажем чуть ниже. Сначала рассмотрим еще одну векторизованную конструкцию -- условие.


### Условия

Иногда необходимо ограничить выполнение функции неким условием. Короткие условия можно писать в одну строку без фигурных скобок.

```{r}
if(any(nchar(y) > 6)) print("многабукв")
```

Более сложные и множественные условия требуют фигурных скобок. Можно сравнить это с условным периодом: протасис (всегда либо TRUE, либо FALSE) в круглых скобках, аподосис в фигурных.

```{r}
if (sum(nchar(y)) > 10) {
  print("много букв")
} else if (sum(nchar(y)) < 5) {
  print("мало букв")
} else {
  print("норм букв")
}
```

Также в R можно использовать специальную функцию:

```{r}
ifelse((sum(nchar(y)) > 10), "много букв", "мало букв")
```

Прописывая условие, не забывайте, что применение булева оператора к вектору возвращает логический вектор:

```{r}
x <- c(1:10)
x >= 5
```

Такое условие вернет ошибку.

```{r error=TRUE}
if (x >= 5) print("все сломалось")
```

Можно скорректировать код так:

```{r}
if (any(x >= 5)) print("все сработало")
```

По той же причине внутри условия не надо использовать логические операторы `|` ("или") или `&` ("и"), потому что они векторизованы:

```{r}
x < 3 | x > 7
```

</br>

::: {.callout-warning icon=false}
ПРАКТИЧЕСКОЕ ЗАДАНИЕ 4: ГАРРИ ПОТТЕР
:::

</br>

```{r eval=FALSE}
# скачайте датасет о Гарри Поттере (источник: сайт Британской библиотеки)  
my_url <- "https://github.com/locusclassicus/text_analysis_2024/raw/main/files/HP.zip"
download.file(url = my_url, destfile = "HP.zip")
```

```{r eval=FALSE}
# после этого перейдите в директорию с архивом и распакуйте его 

unzip("HP.zip")

# сохраните список всех файлов с расширением .csv, 
# используя подходящую функцию из base R

# ваш код здесь
# my_files <- 

# напишите цикл, который:
# 1) прочитает все файлы из my_files, используя для этого функцию read_csv() из пакета readr
# (аргумент show_col_types установите на FALSE);
# 2) для каждого датасета выяснит количество рядов _без_ NA в столбце BNB Number;
# 3) разделит число таких рядов на общее число рядов;
# 4) вернет таблицу c четырьми столбцами: 
# - название файла (id), 
# - число рядов (total), 
# - число рядов без NA (complete), 
# - доля полных рядов (ratio)

my_df <- data.frame(id = my_files, 
                    total = rep(0, length(my_files)),
                    complete = rep(0, length(my_files)),
                    ratio = rep(0, length(my_files)))

for (i in 1:length(my_files)) {
  # ваш код здесь
}

```


## Вместо циклов: семейство `_apply`

Функция **`tapply()`** из базового R принимает на входе вектор, фактор (или список факторов) и функцию. Каждый фактор должен быть той же длины, что и вектор. Код ниже считает среднюю долю гапаксов по группам диалогов:

```{r}
# подготавливаем векторы 
my_fct <- as.factor(hapax_plato$group)
my_vct <- as.numeric(hapax_plato$ratio)

# применяем к ним функцию mean()
tapply(my_vct, my_fct, mean)
```
</br>

::: {.callout-tip icon=false}
Подумайте, как решить эту задачу на диалекте tidyverse.
:::

</br>

Если группировка не нужна, то подойдет функция **`apply()`**: она вызывает функцию для каждого ряда или столбца матрицы или датафрейма. В качестве второго аргумента функция принимает `1` (для вычислений по рядам) или `2` (для вычислений по столбцам).

```{r}
tic()
round(apply(hapax_plato_num, 2, mean), 3)
toc()
```

Эти функции работают быстрее циклов. Сравните:

```{r}
tic()
my_means <- c()
for (i in seq_along(hapax_plato_num)) {  
  m <- round(mean(hapax_plato_num[,i]), 3)
  my_means <- c(my_means, m)
}
my_means
toc()
```

Функция `apply()` позволяет применять к данным собственные функции, в том числе анонимные.

```{r}
hapax_centered <- apply(hapax_plato_num, 2, function(x) x - mean(x))
head(hapax_centered)
```

Также можно использовать грамматику трансформации данных dplyr:

```{r eval=F}
tic()
as_tibble(hapax_plato_num) %>% 
  mutate(words = words - mean(words), 
         hapax = hapax - mean(hapax),
         ratio = ratio - mean(ratio))
toc()
```

Видно, что по времени мы при этом сильно не выигрываем; к тому же, нам пришлось повторить один код три раза. Значит, надо что-то менять. Например, так[^04-iterate-2]:

[^04-iterate-2]: <https://dplyr.tidyverse.org/reference/mutate_all.html>

```{r eval=F}
tic()
as_tibble(hapax_plato_num) %>% 
  mutate_all(function(x) x - mean(x))
toc()
```

Или даже так[^04-iterate-3]:

[^04-iterate-3]: <https://dplyr.tidyverse.org/articles/colwise.html>

```{r}
fn <- function(x) x - mean(x)
as_tibble(hapax_plato_num) %>%
  mutate(across(1:3, fn)) %>% 
  invisible()
```

В любом случае, нам удалось обойтись без цикла, код понятен и хорошо читается.

Функции **`lapply()`** и **`sapply()`** подходят для применения функций к спискам (и к датафреймам, которые по сути представляют собой прямоугольные списки).

Чтобы понять, как они работают, сначала создадим список.

:::{.callout-note icon=false}
При анализе текста со списками приходится иметь дело достаточно часто: объекты типа `stylo.corpus`, которые создает пакет [`stylo`](https://rdrr.io/cran/stylo) по сути являются списками.
:::

Создадим игрушечный корпус из двух текстов.

```{r}
x <- c("гнев", "богиня", "воспой")
y <- c("в", "мысли", "ему", "то", "вложила", "богиня", "державная", "гера")
corpus <- list(x = x, y = y)
```

Наш условный корпус -- это список из 2 элементов (текстов), а каждый текст хранится как символьный вектор. Допустим, мы хотим взять из каждого текста выборку размером 5 слов, то есть применить функцию `sample()` к элементам списка. При помощи `lapply()` (l = list) это делается так:

```{r}
set.seed(0211) 
lapply(corpus, sample, 5, replace = T)
```

Функция **`sapply()`** ведет себя так же, но упрощает результат до вектора или матрицы (s = simplify).

```{r}
sapply(corpus, sample, 5, replace = T)
```

Функция **`vapply()`** позволяет задать тип данных на выходе.

```{r}
vapply(corpus, sample, size = 5, replace = T, character(5))
```

Поскольку наш "корпус" -- это список, применять грамматику `dplyr` не очень удобно. Но списко легко превращается в таблицу:

```{r}
corpus_tbl <- stack(corpus) %>% 
  as_tibble()
corpus_tbl
```


::: {.callout-warning icon=false}
Используйте `relocate()` и `rename()`, чтобы поменять столбцы местами и переименовать их.
:::

</br>

Повторные выборки из тиббла можно делать так:

```{r}
set.seed(0211)
corpus_tbl %>% 
  group_by(ind) %>% 
  sample_n(size = 5, replace = T)
```

</br>

::: {.callout-warning icon=false}
Пройдите урок 10 `lapply and sapply` и урок 11 `vapply and tapply` из курса `R Programming E` в `swirl`.
:::

</br>

## Purrr

### `map()`

По-настоящему мощный инструмент для итераций -- это пакет `purrr` из семейства `tidyverse`[^04-iterate-4]. Разработчики предупреждают, что потребуется время, чтобы овладеть этим инструментом [@wickham2016].

[^04-iterate-4]: <https://purrr.tidyverse.org/>

> You should never feel bad about using a loop instead of a map function. The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work.
>
> --- Hadley Wickham & Garrett Grolemund

В семействе функций `map_` из этого пакета всего 23 вариации[^04-iterate-5]. Вот основные из них:

[^04-iterate-5]: <https://adv-r.hadley.nz/functionals.html>

-   `map()`
-   `map_lgl()`
-   `map_int()`
-   `map_dbl()`
-   `map_chr()`

Все они принимают на входе данные и функцию (или формулу), которую следует к ним применить, и возвращают результат в том виде, который указан после подчеркивания. Просто `map()` вернет список, а `map_int()` -- целочисленный вектор, и т.д. 

Воспользуемся возможностями `purrr`, чтобы исследовать датасет `starwars` из пакета `dplyr`. Для начала узнаем число отсутствующих значений в каждом столбце. Тильда (`~`) указывает на то, что мы используем формулу.

```{r}
library(purrr)
data(starwars)
map_int(starwars, ~sum(is.na(.)))
```

Обратите внимание, что `map_int`, как и `map_dbl` возвращает именованный вектор. Чтобы избавиться от имен, можно использовать `unname()`:

```{r}
unname(map_chr(starwars, class))
```
</br>

:::{.task .code}
Используйте `map_dbl` и `n_distinct`, чтобы узнать число уникальных наблюдений в каждом столбце.
:::

</br>

Если функция принимает дополнительные аргументы, их можно задать после названия функции. В таком случае для _каждого_ вызова функции будет использовано это значение аргумента. В примере ниже это аргумент `na.rm`. Заметьте, что `map` можно использовать с оператором pipe `%>%`:

```{r}
starwars %>% 
  select(mass, height) %>% 
  map(mean, na.rm = TRUE)
```
При вызове `map_df` есть дополнительная возможность сохранить названия столбцов, используя аргумент `.id`:

```{r}
starwars %>% 
  map_df(~data.frame(distinct = n_distinct(.x),
                     class = class(.x)),
         .id = "variable"
         )
```

Функции `map` можно передать пользовательскую функцию. 
Для примера создадим функцию `describe_vec()`, которая возвращает строку с длиной и классом вектора, и применим ее к игрушечному корпусу, который мы создали выше.

```{r}
# пользовательская функция
describe_vec <- function(vec){
  l = paste("Длина вектора: ", length(vec))
  c = paste("Класс вектора: ", class(vec))
  result = paste(l, c, sep = " | ")
  return(result)
}

unname(map_chr(corpus, describe_vec))
```

Кроме того, мы можем передать `map` анонимную функцию:

```{r}
map_chr(corpus, 
        function(x) paste("Длина вектора: ", length(x))
        )
```


### `map2()`

Если необходимо несколько раз вызывать одну и ту же функцию с двумя аргументами, используется функция `map2()` [^04-iterate-6]. Аргументы, которые меняются при каждом вызове, пишутся до функции; аргументы, которые остаются неизменны, -- после.

[^04-iterate-6]: <https://adv-r.hadley.nz/functionals.html>

```{r}
mean = list(5, 10, -3)
sd = list(1, 5, 50)
map2(mean, sd, rnorm, n = 5)
```

</br>

![_Как работает `map2()_`](https://d33wubrfki0l68.cloudfront.net/68a21c4a103426c3b311c9dcfad8fe379d4892f1/55c9d/diagrams/lists-map2.png){width="60%"}

</br>

Это можно обобщить следующим образом ([источник](https://adv-r.hadley.nz/functionals.html#map2){width="60%"}):

![](https://d33wubrfki0l68.cloudfront.net/7a545699ff7069a98329fcfbe6e42b734507eb16/211a5/diagrams/functionals/map2-arg.png)

Можно было бы предположить, что должны быть и map3(), map4() и т.д., но во всех случаеях, когда у функции больше двух аргументов, используется `pmap()`.

В анализе текстовых данных функция `map2()` применяется, например, при создании скользящего окна. Такие окна используются при создании эмбеддингов.[^04-iterate-7]  

[^04-iterate-7]: Пример отсюда, с некоторыми упрощениями: <https://smltar.com/embeddings.html#understand-word-embeddings-by-finding-them-yourself>. Подробный разбор в [видео](https://vk.com/video-211800158_456239215)

Разделим наш игрушечный корпус на окна. Функция вернет список с тибблами, число рядов в каждом из которых соответствует заданному размеру окна.

```{r}
windows <- slider::slide(corpus_tbl, ~.x, .after = 1)
windows[[1]]
```
Для анализа этих данных каждому окну следует присвоить id. Здесь пригодится `map2()`.

```{r}
out <- map2(.x = windows, .y = 1:length(windows), ~ mutate(.x, window_id = .y)) # out  -- это список
out[[1]]
```

Поскольку аргумент `.y` -- это, по сути, индекс, можно было бы использовать функцию `imap()`:

```{r}
out <- imap(.x = windows, ~ mutate(.x, window_id = .y))
out[[1]]
```

:::{.callout-warning icon=false}
Установите курс `swirl::install_course("Advanced R Programming")` и пройдите из него урок 3 `Functional Programming with purrr`.
:::

Несколько вопросов для самопроверки.

:::{.callout-tip icon=false}
Функции-предикаты (predicate functions) возвращают `TRUE` или `FALSE`. Выберите из списка все функции-предикаты.
:::

```{r echo=F, results='asis'}
check_question(options = c("every()", "some()", "none()", "has_element()", "is.factor()", "keep()", "discard()", "is.numeric()", "detect()"), 
               type = "checkbox",
               answer = c("every()", "some()", "none()", "has_element()", "is.factor()", "is.numeric()"), 
               right = "Правильно!",
               wrong = "Что-то тут лишнее 🤔")
```

</br>

:::{.callout-tip icon=false}
Какие из функций ниже принимают *в качестве аргумента* функции-предикаты?
:::

```{r echo=F, results='asis'}
check_question(options = c("every()", "some()", "none()", "has_element()", "is.factor()", "keep()", "discard()", "is.numeric()", "detect()"), 
               type = "checkbox",
               answer = c("keep()", "discard()", "detect()"), 
               right = "Верно!",
               wrong = "Не совсем 🤔")
```

</br>

### Дополнительные возможности purrr

Вы уже поняли, что благодаря циклам можно прочитать сразу несколько файлов (см. Практическое задание выше). Та же задача решается и при помощи `map`. Рассмотрим на том же примере с датасетом Британской библиотеки про Гарри Поттера. Если вы еще не скачали архив, посмотрите выше, как это сделать.

Узнаем имена файлов в директории и прочитаем их все одним вызовом функции (подробнее про формат .csv будет рассказано в следующем уроке).

```{r}
# чтение файлов 
library(readr)

files <- list.files("../files/HP", pattern = ".csv", full.names = TRUE)

HP <- map(files, read_csv, col_types = cols())
```

Объект `HP` -- это список. В нем пять элементов, так как на входе у нас было пять файлов. Для удобства назначим имена элементам списка. Пока можно не вникать, что здесь происходит -- регулярные выражения мы рассмотрим в одном из следующих уроков.

```{r}
library(stringr) 
names(HP) <- str_extract(files, "\\w+(?=.csv)")
names(HP)
```

Начнем с простого: при помощи `map` можно извлечь столбцы (по имени) или ряды (по условию) из всех пяти таблиц. Прежде чем выполнить код ниже, подумайте, как будет выглядеть результат. 

```{r eval=FALSE}
# извлечь столбцы
map(HP, select, `BNB number`)

# извлечь ряды
map(HP, filter, !(is.na(`BNB number`)))
```

</br>

:::{.callout-warning icon=false}
Извлеките все уникальные названия (столбец `Title`) из всех пяти таблиц в `HP`. Используйте функцию `distinct`. 
:::

</br>

Что, если мы не знаем заранее, какие столбцы есть во всех пяти таблицах, и хотим это выяснить? Для этого подойдет функция `reduce()` из того же `purrr`. Она принимает на входе вектор (или список) и  функцию и применяет функцию последовательно к каждой паре значений.

![[_Источник_.](https://adv-r.hadley.nz/functionals.html#reduce)](https://d33wubrfki0l68.cloudfront.net/9c239e1227c69b7a2c9c2df234c21f3e1c74dd57/eec0e/diagrams/functionals/reduce.png){ width="60%" }

</br>

Воспользуемся этим, чтобы найти общие для всех таблиц имена столбцов.

```{r}
map(HP, colnames) %>% 
  reduce(intersect)
```

Еще одна неочевидная возможность функции `reduce` - объединение нескольких таблиц в одну одним вызовом. Например, так:

```{r message=FALSE}
HP_joined <- HP %>% 
  reduce(left_join)
```

Теперь можно почистить данные и построить несколько разведывательных графиков.

```{r warning=FALSE, message=FALSE}
library(ggplot2)
library(tidyr)
data_sum <- HP_joined %>% 
  separate(`Date of publication`, into = c("year", NA)) %>% 
  separate(`Country of publication`, into = c("country", NA), sep = ";") %>%
  mutate(country = str_squish(country)) %>% 
  mutate(country = 
           case_when(country == "England" ~ "United Kingdom",
                     country == "Scotland" ~ "United Kingdom",
                     TRUE ~ country)) %>% 
  group_by(year, country) %>% 
  summarise(n = n()) %>% 
  filter(!is.na(year)) %>% 
  filter(!is.na(country)) 
  

# график
data_sum %>% 
  ggplot(aes(year, n, fill = country)) + 
  geom_col() + 
  xlab(NULL) +
  theme(axis.text.x = element_text(angle = 90))
```

В качестве небольшого бонуса к этому уроку построим облако слов. Вектор слов возьмем из столбца `Topic`. 

```{r warning=FALSE}
library(tidyr)
data_topics <- HP_joined %>% 
  filter(!is.na(Topics)) %>% 
  separate(Topics, into = c("topic", NA)) %>% 
  mutate(topic = tolower(topic)) %>% 
  group_by(topic) %>% 
  summarise(n = n()) %>% 
  filter(!topic %in% c("harry", "rowling", "potter", "children", "literary"))


pal <- c("#f1c40f", "#34495e", 
         "#8e44ad", "#3498db",
         "#2ecc71")

library(wordcloud)
par(mar = c(1, 1, 1, 1))
wordcloud(data_topics$topic, 
          data_topics$n,
          min.freq = 3,
          #max.words = 50, 
          scale = c(3, 0.8),
          colors = pal, 
          random.color = T, 
          rot.per = .2,
          vfont=c("script","plain")
          )
```

Интерактивное облако слов можно построить с использованием пакета `wordcloud2`. Сделаем облако в форме шляпы волшебника!

```{r eval=FALSE}
# devtools::install_github("lchiffon/wordcloud2")
library(wordcloud2)


wordcloud2(data_topics, 
           figPath = "./images/hat.png",
           size = 1.5,
           color="random-light", 
           fontWeight = "normal",
           backgroundColor="black"
           )
```

![](./images/hat_wordcloud.jpg)

</br>

:::{.callout-warning icon=false}
ПРАКТИЧЕСКОЕ ЗАДАНИЕ 5: АЛИСА В СТРАНЕ ЧУДЕС
:::

</br>

```{r eval=FALSE}
# постройте облако слов для "Алисы в стране чудес"

library(languageR)
library(dplyr)
library(tidytext)

# вектор с "Алисой"
alice <- tolower(alice)

# частотности для слов
freq <- as_tibble(table(alice)) %>% 
  rename(word = alice)

# удалить стоп-слова
freq_tidy <- freq %>% 
  anti_join(stop_words) 
# возможно, вы захотите произвести и другие преобразования

# облако можно строить в любой библиотеке
```
