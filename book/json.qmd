# Импорт: JSON

```{r message=FALSE}
library(tidyverse)
library(jsonlite)
library(imager)
library(httr)
```

## Формат JSON

Формат JSON (JavaScript Object Notation) предназначен для представления структурированных данных. JSON имеет шесть основных [типов данных](https://r4ds.hadley.nz/rectangling#json). Четыре из них - скаляры:

-   cамый простой тип - `null`, который играет ту же роль, что и `NA` в R. Он представляет собой отсутствие данных;
-   cтрока (string) похожа на строку в R, но в ней всегда должны использоваться двойные кавычки;
-   число аналогично числам в R, при этом поддерживается целочисленная (например, 123), десятичная (например, 123.45) или научная (например, 1,23e3) нотация. JSON не поддерживает `Inf`, `-Inf` или `NaN`;
-   логическое значение аналогично `TRUE` и `FALSE` в R, но использует строчные буквы `true` и `false`.

Строки, числа и булевы значения в JSON очень похожи на символьные, числовые и логические векторы в R. Основное отличие заключается в том, что скаляры JSON могут представлять только одно значение. Для представления нескольких значений необходимо использовать один из двух оставшихся типов: массивы и объекты.

И массивы, и объекты похожи на списки в R, разница заключается в том, именованы они или нет. _Массив_ подобен безымянному списку и записывается через `[]`. Например, `[1, 2, 3]` - это массив, содержащий 3 числа, а `[null, 1, "string", false]` - массив, содержащий ноль, число, строку и булево значение. 

_Объект_ подобен именованному списку и записывается через `{}`. Имена (ключи в терминологии JSON) являются строками, поэтому должны быть заключены в кавычки. Например, {"x": 1, "y": 2} - это объект, который сопоставляет x с 1, а y -- с 2.

## От JSON к таблице

Загрузим небольшой файл `TBBT.json`, хранящий данные о сериале "Теория большого взрыва" ([источник](https://gist.github.com/sahithyandev/540c82170a19f97deef9e23796083f01)). Скачать лучше из репозитория курса [ссылка](https://github.com/locusclassicus/text_analysis_2024/blob/main/files/TBBT.json). 

```{r message=FALSE}
path <- "../files/TBBT.json"
tbbt <- read_json(path)
```

Функция `read_json()` вернула нам список со следующими элементами:

```{r}
summary(tbbt)
```


Выборочно преобразуем список в тиббл, используя функцию `pluck()` из пакета `{purrr}`.

```{r}
episodes_count <- tibble(
  season = tbbt |>  
    pluck("episodes_count_per_season") |> 
    names(),
  n = tbbt |> 
    pluck("episodes_count_per_season") |> 
    as.integer()
)

episodes_count |> 
  print()
```


```{r message=FALSE}
tbbt |> 
  pluck("casting") |> 
  map_dfr(as_tibble) |> 
  print()
```

Еще один способ. 


```{r}
tibble(
  episode_id = map_chr(tbbt$episode_list, pluck, "episode_id"),
  title = map_chr(tbbt$episode_list, pluck, "title")) |> 
  print()
```

##  Кейс: Шедевры Пушкинского музея 

JSON -- популярный формат для публикации открытых данных. В таком виде часто публикуют данные органы государственной власти, культурные и некоммерческие организации и др. Например, [Пушкинский музей](https://pushkinmuseum.art/open_data/).

Взглянем на датасет "Шедевры из коллекции музея". JSON можно прочитать напрямую из Сети.

```{r}
doc <- read_json("https://pushkinmuseum.art/json/masterpieces.json")
```

Датасет содержит информацию о 97 единицах хранения.

```{r}
names(doc)
```
Для каждого предмета дано подробное описание. 

```{r}
summary(doc[[1]])
```

Заберем только то, что нам интересно. 

```{r}
masterpieces <- tibble(
  name = map_chr(doc, pluck, "name", "ru"),
  get_year = map_chr(doc, pluck, "get_year"),
  year = map_int(doc, pluck, "year"),
  period = map_chr(doc, pluck, "period", "name", "ru"),
  country = map_chr(doc, pluck, "country", "ru"),
  gallery = paste0("https://pushkinmuseum.art", map_chr(doc, pluck, "gallery", 1, 1)))
```

Библиотека `imager` позволяет работать с изображениями из датасета. Вот так мы могли бы забрать одно из них.

```{r eval=FALSE}
img <- load.image(masterpieces$gallery[1]) |> 
  plot()
img
```

```{r echo=FALSE, eval=FALSE}
save(img, file = "../data/img.Rdata")
```

![](./images/pushkin1.png)

В пакете `imager` есть функция `map_il()`, которая похожа на свою родню из `{purrr}`, но возвращает список изображений. 

```{r eval=FALSE}
img_gallery <- map_il(masterpieces$gallery, ~load.image(.x))
```

```{r echo=FALSE, eval=FALSE}
save(img_gallery, file = "../data/img_gallery.Rdata")
```

Функция `walk()` из пакета `purrr` -- это аналог `map()` для тех случаев, когда нас интересует только вывод, т.е.не надо ничего сохранять в окружение.

```{r eval=FALSE}
par(mfrow = c(10, 10), mar = rep(0,4))
walk(img_gallery, plot, axes = FALSE)
```

![](./images/pushkin2.png)

:::{.callout-warning icon=false}
Попробуйте самостоятельно узнать, когда приобретена большая часть шедевров и из каких регионов они происходят.
:::

## Кейс: Нобелевские лауреаты

Мы заберем данные о [нобелевских лауреатах](https://www.nobelprize.org/about/developer-zone-2/) по литературе. В данном случае API не требует ключа авторизации.

```{r}
# Базовый URL API Нобелевской премии
base_url <- "https://api.nobelprize.org/2.1/laureates"
```

```{r}

# Параметры запроса (фильтрация и ограничение результатов)
query_params <- list(
  nobelPrizeCategory = "lit",  # Фильтр по категории
  limit = 100                  # Ограничение количества результатов
)
```

Другие категории: 

- phy (физика), 
- che (химия), 
- med (медицина), 
- lit (литература), 
- pea (мир), 
- eco (экономика).


```{r eval=FALSE}
# Выполнение GET-запроса
response <- GET(url = base_url, query = query_params)
```

```{r echo=FALSE, eval=FALSE}
save(response, file = "../data/response.Rdata")
```

```{r echo=FALSE}
load("../data/response.Rdata")
```

Функция `content()` берет сырой ответ от API и возвращает готовые к анализу данные.

```{r}
nobel_data <- content(response, "text")
```
  
```{r}
laureates_data <- fromJSON(nobel_data) 
```
  
Нам осталось преобразовать данные в таблицу. 

```{r}
laureates_tbl <- laureates_data |> 
  pluck("laureates") 
```

```{r}
laureates_tbl |> 
  unnest_wider(knownName, names_sep  = "_") |> 
  select(-fullName, -givenName, -knownName_se, -familyName, -fileName) |> 
  unnest_wider(birth, names_sep = "_") 
```

И так далее. Пример исследования, выполненного по итогам этого курса, можно посмотреть по [ссылке](https://sysblok.ru/visual/recept-nobelevskoj-premii-issleduem-otkrytye-dannye-o-laureatah/).

## Кейс: Google Books 

Подробные [инструкции](https://developers.google.com/books/docs/v1/using) для разработчиков.

```{r}
# Функция для поиска книг через Google Books API
search_google_books <- function(query, max_results = 15) {
  base_url <- "https://www.googleapis.com/books/v1/volumes"
  
  full_url <- paste0(base_url, "?q=", URLencode(query), "&maxResults=", max_results, "&printType=books")
  
  response <- GET(full_url)
  
  if (status_code(response) != 200) {
    stop("Ошибка при запросе к API Google Books")
  }

  content <- content(response, "text", encoding = "UTF-8")
  data <- fromJSON(content)
}
```

Попробуем в действии.

```{r eval=FALSE}
res <- search_google_books('plato')
```
```{r echo=FALSE, eval=FALSE}
save(res, file = "../data/res.Rdata")
```

```{r echo=FALSE}
load("../data/res.Rdata")
```

```{r}
# Извлекаем метаданные
plato_data <- res$items$volumeInfo |> 
  mutate(authors = map_chr(authors, ~paste(.x, collapse = ", "))) |> 
  select(-industryIdentifiers, -readingModes, -printType, -maturityRating, -allowAnonLogging, -contentVersion, -panelizationSummary) |> 
  unnest_wider(imageLinks, names_sep = "_") |> 
  select(-categories) 

plato_data |> 
  print() 
```

И последний штрих. 

```{r eval=FALSE}
library(magick)

catch_cover <- function(url) {
   
   tryCatch({
      # Прямая загрузка через magick
      img <- image_read(url) |> 
        image_border("white", "10x10")  # Добавляем рамку
      
      return(img)
    }, error = function(e) {
      message("Ошибка загрузки изображения: ", url)
      message("Ошибка: ", e$message)
      return(NULL)
    })
  
}

plato_gallery <- map(plato_data$imageLinks_smallThumbnail, catch_cover)
```

```{r eval=FALSE}
# Функция для создания сетки обложек
create_cover_grid <- function(images, cols = 4, target_width = 200) {
  if (length(images) == 0) return(NULL)
  
  # Ресайзим все изображения к одинаковой ширине
  images_resized <- map(images, ~ image_scale(.x, paste0(target_width, "x")))
  
  # Вычисляем количество строк
  rows <- ceiling(length(images_resized) / cols)
  
  # Создаем строки
  gallery_rows <- map(1:rows, function(row) {
    start_idx <- (row - 1) * cols + 1
    end_idx <- min(row * cols, length(images_resized))
    
    row_images <- images_resized[start_idx:end_idx]
    
    # Если в последней строке меньше изображений, добавляем пустые места
    if (length(row_images) < cols) {
      empty_count <- cols - length(row_images)
      empty_images <- map(1:empty_count, ~ image_blank(target_width, 300, "white"))
      row_images <- c(row_images, empty_images)
    }
    
    # Объединяем изображения в строку
    image_append(do.call(c, row_images), stack = FALSE)
  })
  
  # Объединяем все строки
  image_append(do.call(c, gallery_rows), stack = TRUE)
}

# Создаем и отображаем галерею
gallery <- create_cover_grid(plato_gallery, cols = 5)
print(gallery)
```

![](./images/plato_covers.jpeg)