# Разметка TEI XML

XML (от англ. eXtensible Markup Language) --- расширяемый язык разметки. Слово "расширяемый" означает, что список тегов не зафиксирован раз и навсегда: пользователи могут вводить свои собственные теги и создавать так называемые _настраиваемые языки разметки_ [@xml2004, 29]. Один из таких настраиваемых языков -- это TEI (Text Encoding Initiative), о котором будет сказано дальше. 

Для работы нам понадобятся следующие библиотеки:

```{r message=FALSE}
library(tidyverse)
library(xml2)
```


## Основы XML

Назначение языков разметки заключается в описании структурированных документов. Структура документа представляется в виде набора вложенных в друг друга элементов (дерева XML). У элементов есть открывающие и закрывающие теги. 

Все составляющие части документа обобщаются в пролог и корневой элемент. Корневой элемент — обязательная часть документа, в которую вложены все остальные элементы. Пролог может включать объявления, инструкции обработки, комментарии.

В правильно сформированном XML открывающий и закрывающий тег вложенного элемента всегда находятся внутри одного родительского элемента.

Создадим простой XML из строки. Сначала идет инструкция по обработке XML (со знаком вопроса), за ней следует объявление типа документа (с восклицательным знаком) и открывающий тег корневого элемента. В этот корневой элемент вложены все остальные элементы.

```{r}
string_xml <- '<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE recipe>
<recipe name="хлеб" preptime="5min" cooktime="180min">
   <title>
      Простой хлеб
   </title>
   <composition>
      <ingredient amount="3" unit="стакан">Мука</ingredient>
      <ingredient amount="0.25" unit="грамм">Дрожжи</ingredient>
      <ingredient amount="1.5" unit="стакан">Тёплая вода</ingredient>
   </composition>
   <instructions>
     <step>
        Смешать все ингредиенты и тщательно замесить. 
     </step>
     <step>
        Закрыть тканью и оставить на один час в тёплом помещении. 
     </step>
     <step>
        Замесить ещё раз, положить на противень и поставить в духовку.
     </step>
   </instructions>
</recipe>'
```

### Библиотека `xml2`

Для работы с xml понадобится установить библиотеку `xml2`. Функция `read_xml()` создаст объект, представляющий дерево XML.

```{r}
doc <- read_xml(string_xml)
class(doc)
```

Функция `xml_root()` позволяет извлечь корневой элемент вместе со всеми детьми. 

```{r}
rootnode <- xml_root(doc)
rootnode
```
 
У корневого элемента есть "дети". Это набор узлов.

```{r}
xml_children(rootnode)
```

У детей есть имена, которые можно извлечь специальной функцией. 

```{r}
xml_name(xml_children(rootnode))
```

### Выбор элементов

 Функция `xml_find_first()` вернет первый подходящий узел.

```{r}
composition_node <- xml_find_first(rootnode, "composition")
composition_node
```
Выбирать узлы можно и по индексу:

```{r}
instructions_node <- xml_children(rootnode)[[3]]
instructions_node
```

### Значения узлов и атрибутов

Но обычно нам нужен не элемент как таковой, а его содержание (значение). Чтобы добраться до него, используем функцию `xml_text()`:

```{r}
composition_node |> 
  xml_children() |> 
  xml_text()
```

Можно уточнить атрибуты узла при помощи `xml_attrs()`:

```{r}
composition_node |> 
  xml_children() |> 
  xml_attrs()
```

Чтобы извлечь значение атрибута, используем функцию `xml_attr()`. Первым аргументом функции передаем xml-узел, вторым -- имя атрибута.

```{r}
composition_node |> 
  xml_children() |> 
  xml_attr("unit")
```


### Синтаксис XPath

Добраться до узлов определенного уровня можно также при помощи синтаксиса [XPath](https://ru.wikipedia.org/wiki/XPath). XPath -- это язык запросов к элементам XML-документа. С его помощью можно описать "путь" до нужного узла: _абсолютный_ (начиная с корневого элемента) или _относительный_. В пакете `xml` синтаксис XPath поддерживают функции `xml_find_first()` и `xml_find_all()`.

```{r}
# абсолютный путь
xml_find_all(rootnode, "/recipe//composition//ingredient")

# относительный путь
xml_find_all(rootnode, "//composition//ingredient")

# атрибут unit == "стакан"
xml_find_all(rootnode, "//composition//ingredient[@unit='стакан']")
```


:::{.callout-note icon=false}
В большинстве случаев функция требует задать **пространство имен** (namespace), но в нашем случае оно не определено, поэтому пока передаем только дерево и путь до узла. С пространством имен встретимся чуть позже!
:::

### От дерева к таблице

При работе с xml в большинстве случаев наша задача -- извлечь значения определеннных узлов или их атрибутов и сохранить их в прямоугольном формате. 

```{r}
title <- rootnode |> 
  xml_find_all("title") |>  
  xml_text() |> 
  trimws() 
  
title
```

Достаем три узла с ингредиентами.  

```{r}
ingredient_ns <- rootnode |> 
  xml_find_all("//composition//ingredient")

ingredient_ns 
```

```{r}
tibble(
  title  = title |> 
    trimws(),
  ingredients = xml_text(ingredient_ns) |> 
    trimws(),
  unit = xml_attr(ingredient_ns, "unit"),
  amount = xml_attr(ingredient_ns, "amount")
) |> 
  print()
```

Теперь рассмотрим более сложные примеры.

## Разметка TEI

TEI (Text Encoding Initiative) — специализированный язык разметки на основе XML, разработанный как средство формального кодирования наиболее значимых текстологических свойств документа: физических параметров рукописи, критического аппарата, лингвистической информации, выходных данных, сведений об авторе, обстоятельствах публикации и первоисточнике [@skorinkin2016]. TEI появился в 1987 г. и в наши дни стал де-факто стандартом для создания цифровых гуманитарных ресурсов.

Основная задача структурированной разметки — формальное эксплицитное представление некоторых свойств документа, заложенных в нем имплицитно. Например, для человека очевидно, где в тексте романа кончается одна часть и начинается другая, какие герои упоминаются в той или иной главе, какие реплики кем произнесены. Однако для машины ничего из этого не является «очевидным» — электронный текст без разметки остается не более чем цепочкой символов.

Большая часть размеченных литературных корпусов хранится именно в формате XML. Это очень удобно, и вот почему: с  помощью тегов XML мы можем достать из документа именно то, что нам интересно: определенную главу, речи конкретных персонажей, слова на иностранных языках и т.п. 

Использование TEI обеспечивает:

- Хранение богатой метаинформации о тексте и его носителях;
- Кодирование структуры текста и лингвистической разметки;
- Независимость от конкретного ПО;
- Открытость для доработки и расширения;
- Оптимизацию для автоматической обработки.

Добавлять и удалять разметку может любой пользователь в редакторе XML кода или даже в простом текстовом редакторе. Стандарт TEI предоставляет исследователям универсальный метаязык для обмена текстологической информацией и встраивает документы в мировую коллекцию машиночитаемых текстов.

### Структура документа TEI

Корневой элемент в документах TEI называется `TEI`, внутри него располагается элемент `teiHeader` с метаинформацией о документе и элемент `text`. Последний содержит текст документа с элементами, определяющими его структурное членение. 

```
<TEI>
  <teiHeader></teiHeader>
  <text></text>
</TEI>
```

Пример оформления документа можно посмотреть [по ссылке](https://github.com/dracor-org/rusdracor/blob/main/tei/fonvizin-nedorosl.xml).

### teiHeader

У `teiHeader` есть четыре главных дочерних элемента:

- `fileDesc` (описание документа c библиографической информацией)
- `encodingDesc` (описание способа кодирование первоисточника)
- `profileDesc` ("досье" на текст, например отправитель и получатель для писем, жанр, используемые языки, обстоятельства создания, место написания и т.п.)
- `revisionDesc` (история изменений документа).


Элемент `fileDesc` должен содержать полную библиографическую информацию о первоисточнике. Пример для повести Л.Н. Толстого «Детство»:

```
<fileDesc>
  <titleStmt>
    <title>Повесть «Детство». Электронное издание.</title>
    <author>Толстой Л.Н.</author>
    <editor>Иванов И.И.</editor>
    <respStmt>
      <resp>Подготовка и разметка метаинформации для электронного издания</resp>
      <name>Иванов И.И.</name>
    </respStmt>
  </titleStmt>
  <publicationStmt>
    <publisher>Школа лингвистики <orgName>НИУ ВШЭ</orgName></publisher>
    <availability>
      <p>Распространяется свободно</p>
    </availability>
  </publicationStmt>
  <sourceDesc>
    <biblStruct>
      <author>Толстой Л.Н.</author>
      <title level="a">Детство</title>
      <monogr>
        <title level="m">Полное собрание сочинений. Том 1</title>
        <imprint>
          <pubPlace>Москва</pubPlace>
          <publisher>Государственное издательство "Художественная литература"</publisher>
          <date when="1935"/>
        </imprint>
      </monogr>
    </biblStruct>
  </sourceDesc>
</fileDesc>
```


Элемент `<profileDesc>` содержит метаданные, относящиеся непосредственно к тексту:

```
<profileDesc>
  <creation>
    <date when="1852">1852</date>
    <placeName>Москва</placeName>
    <placeName>станица Старогладковская</placeName>
    <placeName>Тифлис</placeName>
  </creation>
  <langUsage>
    <language ident="rus" usage="99">Русский</language>
    <language ident="fra" usage="0,5">Французский</language>
    <language ident="deu" usage="0,5">Немецкий</language>
  </langUsage>
  <textClass>
    <catRef type="type" target="#short_novel"/>
  </textClass>
</profileDesc>
```

### Варианты и исправления

В самом тексте язык TEI дает возможность представлять разные варианты (авторские, редакторские, корректорские и др.) Основным средством параллельного представления является элемент `choice`. Например, в [тексте Лукреция](https://github.com/PerseusDL/canonical-latinLit/blob/master/data/phi0550/phi001/phi0550.phi001.perseus-lat1.xml) вы можете увидеть такое:

```
sic calor atque <choice><reg>aer</reg><orig>aër</orig></choice> et venti caeca potestas
```

Здесь `reg` указывает на нормализованное написание, а `orig` -- на оригинальное.

Для исправления ошибок используются элементы `<sic>` ("так у автора") и `<corr>` ("исправленное написание"):

```
<choice>
  <sic>вихремъ</sic>
  <corr resp="#editor1">верхомъ</corr>
</choice>
```

Атрибут `resp` содержит ссылку на идентификатор редактора.

### Структурная разметка

TEI предоставляет богатый набор элементов для разметки структуры текста:

- `<text>` — текст целиком
- `<body>` — основное содержание текста
- `<div>` — структурное деление (глава, часть, раздел)
- `<p>` — параграф
- `<l>` — стихотворная строка
- `<lg>` — группа стихотворных строк (строфа)
- `<sp>` — речь персонажа в драме
- `<stage>` — ремарка

Пример разметки поэзии:

```
<lg type="quatrain">
  <l met="+-|+-|+-|+-">Дар напрасный, дар случайный,</l>
  <l met="+-|+-|+-|+">Жизнь, зачем ты мне дана?</l>
  <l met="+-|+-|+-|+-">Иль зачем судьбою тайной</l>
  <l met="+-|+-|--|+">Ты на казнь осуждена?</l>
</lg>
```


## Кейс: "Горе от ума"

Скачаем по из репозитория проекта [Dracor](https://github.com/dracor-org) "Горе от ума" Грибоедова и преобразуем xml в прямоугольный формат таким образом, чтобы для каждой реплики был указан акт, сцена и действующее лицо.

:::{.callout-note icon=false}
Для работы с корпусом Dracor в среде R существует пакет `rdracor`. Он позволяет доставать тексты пьес сразу в виде таблицы. 
:::

```{r eval=FALSE}
url <- "https://raw.githubusercontent.com/dracor-org/rusdracor/main/tei/griboyedov-gore-ot-uma.xml"
download_xml(url, file = "griboedov.xml")
```

```{r}
doc <- read_xml("../files/griboedov.xml")

# определить пространство имён
ns <- xml_ns(doc)
ns

ns <- xml_ns_rename(xml_ns(doc), d1 = "tei")
ns
```

Пространство имён (namespace) в XML — это механизм, который позволяет однозначно различать элементы и атрибуты с одинаковыми именами, но из разных словарей или стандартов. Оно действует как "фамилия" для элемента. Чтобы задать "фамилию", её связывают с уникальным идентификатором (обычно это URI, в нашем случае <http://www.tei-c.org/ns/1.0>). Для удобства этому идентификатору присваивают короткий префикс.


```{r}
# Найти все строки (tei:l)
line_nodes <- xml_find_all(doc, "//tei:l", ns)

# Извлечь текст каждой строки
line_text <- line_nodes |> 
  xml_text()

line_text |> 
  head()
```
Теперь нам надо для каждой реплики найти информацию о том, кто говорит: она хранится в  теге `<speaker>`. То есть нам надо подняться на два этажа вверх (на уровень `<sp>`), а потом спуститься к его другому "ребенку", `<speaker>`.

Для этого используем синтаксис XPath: сначала при помощи `ancestor::tei:sp` поднимаемся вверх по дереву и выбираем всех предков узла, которые являются элементами `sp`, а затем спускаемся к ребенку `speaker` этого найденного `sp`. Так список спикеров будет равно числу стихов. 

```{r}
# line_nodes — вектор узлов <l>
speakers <- line_nodes |> 
  xml_find_first("ancestor::tei:sp/tei:speaker", ns = ns) |> 
  xml_text()

speakers |> 
  head()
```

Аналогичным образом находим явление и акт.

```{r}
scenes <- line_nodes |> 
  xml_find_first("ancestor::tei:div[@type='scene']/tei:head", ns = ns) |> 
  xml_text()

scenes |> 
  tail()
```

```{r}
acts <- line_nodes |> 
  xml_find_first("ancestor::tei:div[@type='act']/tei:head", ns = ns) |> 
  xml_text()

acts |> 
  sample(6)
```

Нам осталось объединить все векторы в одну таблицу. 

```{r message=FALSE}
woe_from_wit <- tibble(
  act = acts,
  scene = scenes,
  speaker = speakers,
  text = line_text
)

woe_from_wit |> 
  head(6) |> 
  gt::gt()
```

## Кейс: "Война и мир"

В качестве примера загрузим датасет "Пушкинского дома", подготовленный Д.А. Скоринкиным: ["Персонажи «Войны и мира» Л. Н. Толстого: вхождения в тексте, прямая речь и семантические роли"](https://dataverse.pushdom.ru/dataset.xhtml?persistentId=doi:10.31860/openlit-2022.1-C005). 


```{r}
filename = "../files/War_and_Peace.xml"
doc <- read_xml(filename)
ns <- xml_ns_rename(xml_ns(doc), d1 = "tei")
ns
```


```{r}
rootnode <- xml_root(doc)
```

 Корневой элемент расходится на две ветви. Полностью они нам пока не нужны, узнаем только имена:

```{r}
xml_children(rootnode) |>  
  xml_name()
```


Очевидно, что что-то для нас интересное будет спрятано в ветке text, смотрим на нее и ее детей:

```{r}
divs <- xml_find_all(rootnode, "//tei:text//tei:div", ns) 
divs
```
Обратите вниманию на разницу: при помощи одного слеша ищем только прямых потомков.

```{r}
xml_find_all(rootnode, "//tei:text/tei:div", ns) 
```


Так отбираем узлы по конкретному атрибуту.

```{r}
xml_find_all(rootnode, "//tei:text//tei:div[@type='volume']", ns)
```

Так ищем книгу _или_ эпилог:

```{r}
xml_find_all(rootnode, "//tei:text//tei:div[@type='volume' or @type='epilogue']", ns)
```

Забрать конкретную главу можно по значению соответствующего атрибута. Извлечем только прямую речь Анны Павловны. Точка перед слешами означает поиск в одном (родительском) узле.

```{r}
rootnode |> 
  xml_find_first("//tei:text//tei:div[@xml:id='chapter1part1Volume1']", ns) |> 
  xml_find_all(".//tei:said[@who='Anna_Pavlovna_Scherer']", ns) |> 
  xml_attr("speech_text") 
```

Подбробнее о структуре XML документов и способах работы с ними вы можете прочитать в книгах: [@nolan2014] и [@xml2004]. 

## Видео 

- [Видео](https://vk.com/video91786643_456239079) 2025 г.

## Домашнее задание 

Используя библиотеки `{tidyverse}` и `{xml2}`, вам необходимо запарсить датасет писем Л.Н. Толстого (всего 9087). [Источник](https://github.com/tolstoydigital/TEI).

Вы найдете письма в репозитории, приняв задание через GitHub Classroom (здесь)[https://classroom.github.com/a/8LHrY3gq].  
Пожалуйста, не переименовывайте папки и не меняйте структуру рабочей директории. Заготовки для кода в этот раз в репозитории нет: файл с решением (любое имя, расширение `.R`) загрузите самостоятельно — задание проверяется вручную.

Ваша задача – написать функцию на R, которая для каждого письма извлекает том, дату и адресата, и собрать эти данные в одну таблицу. XML имеет очень ветвистую структуру, для начала испытайте свой код на любом одном письме. Потом оберните свое решение в функцию `read_letter()` и прочтите все письма в один тиббл при помощи `map_dfr()`. 

Что вам надо извлечь: 

1) дата письма: в header — тег correspAction, тип sending — тег date, атрибут when;
2) в header – тег correspAction, тип receiving — имя получателя (текст)
3) в header — biblScope, юнит vol — номер тома

Критерии оценивания (1 п. = 1 б.): 

1) корректно извлечены все сведения для одного письма (без функции);
2) корректно извлечены все сведения для всех писем (с функцией), задействован `map_dfr()`;
3) аккуратное оформление кода, воспроизводимость;
4) из столбца с датой извлечен год, хранится как тип date (надо самостоятельно поколдовать с пакетом lubridate), каждое письмо снабжено уникальным id (можно просто номер ряда), пустые строки заменены на NA;
5) есть разведывательный анализ данных и график, например: письма за какие года хранятся в каком томе? сколько NA по томам? в каком году кому чаще всего писал Толстой, сколько писем в год и т.д. Достаточно чего-то одного. Снабдите код к этому пункту своими комментариями. 

Текст писем извлекать (пока) не надо. Не забывайте использовать `trimws()`! 

На выполнение задания дается две недели (до 3 ноября 23:59).
