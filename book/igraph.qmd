# Сетевые данные в `igraph`

> Сети -- это все, что окружает нас. 
> 
> @luke2017

Любые сети состоят из отдельных участников (людей или вещей в сети) и отношений между ними. Сети часто визуализируются с помощью _графов_ –- структур, состоящих из множества участников (вершин) и линий (ребер или дуг), отображающих связи между ними. В гуманитарных науках в виде сети можно представить, например, отношения [соавторства](https://dhcloud.org/spishemsya-studenty-fgn-issledovali-seti-soavtorstva-na-fakultete/) между исследователями, совместное появление [персонажей](https://sysblok.ru/philology/socseti-russkoj-dramy-chast-i-osnovy-setevogo-analiza/) в драматическом произведении или связи между философскими [концептами](https://muse.jhu.edu/article/761035). 

В R доступно множество пакетов для работы с сетями (`network`, `sna`, `UserNetR` и др.), но в ближайших уроках мы сосредоточимся на одном из них под названием [igraph](https://cran.r-project.org/web/packages/igraph/vignettes/igraph.html#usage).

```{r message=FALSE}
library("igraph")
```
## Создание графа

### Функция `make_graph()`
igraph предлагает много способов создания графа. Наиболее распространенный способ создания графа - make_graph(), который строит сеть на основе указанных ребер. Например, чтобы создать граф с 10 узлами (пронумерованными от 1 до 10) и двумя ребрами, соединяющими узлы 1-2 и 1-5:

```{r}
g <- make_graph(edges = c(1, 2, 1, 5), n = 10, directed = FALSE)

plot(g)
```

Также можно использовать буквальную запись с помощью _формульной нотации_ igraph. Выражения состоят из имен вершин и операторов ребер. Оператор ребра - это последовательность символов `-` и `+`, где первый используется для ребер, а второй - для стрелок. Ребра могут быть произвольно длинными, то есть вы можете использовать столько символов -, сколько нужно для "рисования" их. Если все операторы ребер состоят только из символов -, тогда граф будет ненаправленным, в то время как хотя бы один символ `+` подразумевает направленный граф:

```{r}
g <- make_graph(~ 1--2, 1--5, 3, 4, 5, 6, 7, 8, 9, 10)
```

Мы можем напечатать граф, чтобы получить сводку его узлов и ребер:

```{r}
g
```

Это означает: ненаправленный граф с 10 вершинами и 2 ребрами.

Направленность также можно узнать при помощи специальной функции.

```{r}
is_directed(g)
```

```{r}
g <- graph_from_literal(Sam-+Mary, Sam-+Tom, Mary++Tom)
g
plot(g)
```

Функция make_graph() также может создавать некоторые графы по названию. Например, вы можете создать граф, представляющий социальную сеть клуба каратэ Захарии, который показывает дружбу между 34 членами клуба каратэ в университете США в 1970-х годах:

```{r}
g <- make_graph("Zachary")
```

Вызовите документацию к функции, чтобы узнать, какие еще графы можно создать таким способом. 

Вот еще несколько возможностей.

```{r}
g.full = make_full_graph(7)
g.ring = make_ring(7)
g.tree = make_tree(7, children = 2, mode="undirected")
g.star = make_star(7, mode = "undirected")

par(mfrow = c(2,2), mai = rep(0.2, 4))
plot(g.full)
plot(g.ring)
plot(g.tree)
plot(g.star)
```

### Cоциоматрица

Еще один способ -- _социоматрица_, т.е. матрица, хранящая информацию о сети. Ее можно создать вручную. 

```{r}
netmat1 <- rbind(c(0,1,1,0,0),
                c(0,0,1,1,0),
                c(0,1,0,0,0),
                c(0,0,0,0,0),
                c(0,0,1,0,0))
rownames(netmat1) <- letters[1:5]
colnames(netmat1) <- letters[1:5]

g <- graph_from_adjacency_matrix(netmat1)
plot(g)
class(g)
summary(g)
```


### Список ребер

Также матрицу можно построить при помощи _списка ребер_. Списки ребер меньше по размеру, и собирать сетевые данные в таком формате проще. 

```{r}
netmat2 <- rbind(c(1,2),
                 c(1,3),
                 c(2,3),
                 c(2,4),
                 c(3,2),
                 c(5,3))
g <- graph_from_edgelist(netmat2)
V(g)$name <- letters[1:5]
plot(g)
summary(g)
```

### Таблица

Воспользуемся датасетом, подготовленным Б.В. Ореховым и опубликованном на сайте Пушкинского дома, ["Словарь русских писателей XVIII века: сеть персоналий"](https://dataverse.pushdom.ru/dataset.xhtml?persistentId=doi:10.31860/openlit-2022.1-B002).

> Датасет представляет собой осмысленные в терминах сетевого анализа междустатейные ссылки в Словаре русских писателей XVIII века (1988–2010. Вып. 1–3). Узлами сети выступают посвященные персоналиям статьи словаря, а ребрами — ссылки на другие статьи в том же словаре.


```{r eval=FALSE}
url <- "https://dataverse.pushdom.ru/api/access/datafile/3646"
download.file(url, destfile = "Persons_EDGES.csv")
```

```{r message=FALSE}
library(readr)
# у вас будет другой путь
writers_data <- read_tsv(file = "../files/Persons_EDGES.csv")

writers_data
```

Эту таблицу можно преобразовать в сеть несколькими способами. Можно использовать функцию `graph_from_edgelist()`, которая ожидает на входе матрицу с двумя столбцами или же создать граф напрямую из датафрейма. 

```{r message=FALSE}
library(dplyr)

writers <- writers_data |> 
              select(-Type) |> 
              graph_from_data_frame()

writers
```

Описание позволяет понять, что граф является направленным (D), а его узлы имеют имена (N). Всего в графе 780 вершин и 4440 связей. 

:::{.callout-info icon=false}
Демонстрационная версия интерактивного приложения, построенного на сетевых данных, размещена [здесь](https://nevmenandr.github.io/rus-dict18-persons/). 
:::

Разумеется, таблицу не обязательно импортировать, но можно создать самим. Например, на основе совместной встречаемости слов, которую вы уже умеете считать.

## Вершины и ребра

Самая главная характеристика сети -- это ее _размер_. Размер -- это количество _участников_ (members), которые называются _узлами_ (nodes), _вершинами_ (vertices) или акторами.


```{r}
V(writers)
```

```{r}
vcount(writers)
```

Узнать число ребер и характер связей можно так 

```{r}
E(writers)
ecount(writers)
```

## Плотность

Еще одна важная характеристика сети -- это ее _плотность_. 

```{r}
edge_density(writers)
```

Плотность -- это доля имеющихся связей по отношению к максимально возможному количеству связей. Формула плотности будет отличаться для направленных и ненаправленных сетей. 


:::: {.columns}

::: {.column}
**Направленный граф**

$\frac{L}{k\times(k - 1)}$
:::

::: {.column}
**Ненаправленный граф**

$\frac{2L}{k\times(k-1)}$
:::
::::


Здесь $k\times(k-1)$ -- это максимально возможное число связей, а k - число акторов. 

## Компоненты

_Компонента_ сети -- это подгруппа, где все акторы связаны между собой прямо или косвенно. 

```{r}
components(writers)$no
components(writers)$csize
```

Обратим внимание: в нашем графе 4 писателя, которые не связаны с главной компонентой. 

```{r}
which(components(writers)$membership !=1)
```
Интересная компания (точнее, две компании) из XVIII в.  Иоганн-Вернер Паузе был переводчиком Эразма Роттердамского в начале XVIII века, и его также обычно причисляют к создателям «Зерцала». Братья Иван Выродов и Андрей Выродов -- выпускники Московского благородного пансиона (ныне МГУ), а Эрнст Глюк -- один из переводчиков Библии на русский язык. 

## Диаметр

_Диаметр_ сети -- количество шагов, которые нужно пройти, чтобы попасть из узла А в узел B; для сетей с несколькими компонентами учитывается та, что больше. Сначала вычисляются кратчайшие пути (геодезическое расстояние) между каждой парой узлов, затем из них берется максимальный.

```{r}
lgc <- largest_component(writers)
diameter(lgc, directed = TRUE)
```

```{r}
get_diameter(lgc)
```

```{r}
farthest_vertices(lgc)
```

Посмотрим на кратчайшие пути.

```{r}
shortest_paths(lgc, from = "Н.Карандашов", to = "Ф.П.Печерин")
```
Почему [Николай Карандашов](http://lib.pushkinskijdom.ru/Default.aspx?tabid=994), оказался так далеко от [Федора Печерина](http://lib.pushkinskijdom.ru/Default.aspx?tabid=787), нам решительно не известно. 

## Транзитивность

Коэффициент _кластеризации_, или _транзитивность_,  отражает тенденцию к созданию закрытых треугольников, т.е. к замыканию. Транзитивность определяется как доля закрытых треугольников по отношению к общему количеству открытых и закрытых треугольников. 

```{r}
transitivity(writers)
```

## Атрибуты вершин

В датасете "Словарь..." в качестве  атрибута вершины хранятся данные об имени автора:

```{r}
names <-vertex_attr(writers)$name
names[1:12]
```

## Фильтрация на основе значений атрибутов вершин

Атрибуты вершин можно использовать для того, чтобы задать новую подсеть для анализа.

```{r}
vert <- which(vertex_attr(writers)$name == "М.С.Пахомов")

p <- induced_subgraph(writers, vids = vert)

p
```
> ПАХОМОВ Матвей Сергеевич [1745—1792], преподаватель Смольного ин-та, совм. с И. И. Сидоровским перевел с греч. языка «Разговоры Лукиана Самосатского» (1775—1784. Ч. 1—3), «Творения велемудрого Платона» (1780—1785. Ч. 1—3; с кратким изложением содержания перед текстом каждого рассуждения), «Павсания, или Павсаниево описание Еллады, то есть Греции» (1788—1789. Ч. 1—3) и «Землеописание» Страбона (последний перевод остался неизданным). 

Мы отобрали всего один узел, что не очень интересно. Вот его соседи.

```{r}
neighbors(writers, "М.С.Пахомов")
```

> СИДОРОВСКИЙ Иван Иванович [1748-1795], преподаватель Смольного ин-та. Совместно с М. С. Пахомовым перевел с греч. языка: «Разговоры Лукиана Самосатского» (1775—1784. Ч. 1—3), «Творения велемудрого Платона» (1780—1785. Ч. 1—3), «Павсаний, или Павсаниево описание Еллады, то есть Греции» (1788—1789. Ч. 1—3). Ч. 3 сочинений Платона и Ч. 3 «Разговоров...» переведены одним С. Также С. перевел с греч. сб. «Поучительных разных слов и бесед Св. Иоанна Златоустого» (1787—1791. Ч. 1—2), в котором мн. из произведений Златоуста были впервые представлены на рус. языке, и «Деяния церковные и гражданские от Рождества Христова до половины XV столетия, собранные Георгием Кедрином с продолжением других» (1794. Ч. 1—3). В конце жизни С. начал переводить «Толкование св. Кирилла Александрийского на 12 Малых Пророков». 

```{r}
p2 <- induced_subgraph(writers, vids = c(vert, neighbors(writers, "М.С.Пахомов")))
```


```{r}
plot(p2)
```

## Функция `make_ego_graph()`

`Make_ego_graph()` создает (под)графы из всех соседей заданных вершин. Аргумент `o` можно мыслить как число "рукопожатий": порядок 0 - это всегда сама v, порядок 1 - это v плюс ее ближайшие соседи, порядок 2 - это порядок 1 плюс ближайшие соседи вершин из порядка 1 и т.д. Попробуем найти "друзей друзей" М.С. Пахомова.

```{r}
p3 <- make_ego_graph(
  writers,
  order = 2,
  nodes = "М.С.Пахомов",
  mode = "all"
)[[1]]

# функция позволит распечатать все ребра
# print_all(p3)

p3
```

Чтобы изобразить такой граф, придется немного поправить [настройки](https://kelseyandersen.github.io/DataVizR/Networks.html). 

```{r}
par(mar = rep(0,4), cex = 0.7)
layout_p3 <- layout_with_kk(p3)

plot(p3, vertex.size=6, 
     edge.arrow.size = 0.5, 
     vertex.label.dist = 1,
     edge.curved = 0.2,
     edge.color = "grey80",
     vertex.color = "plum",
     layout = layout_p3)
```
М.С. Пахомов связан с Екатериной II через И.Ф. Янковича де Мириево, камерпажа императрицы, впоследствии (при Павле I) -- генерал-майора и участника походов против Наполеона в 1805 и 1807 г., отличившегося в сражении под Аустерлицем. 

Это можно подтвердить и другим, уже известным нам способом:

```{r}
shortest_paths(writers, from = "М.С.Пахомов", to = "ЕкатеринаII")$vpath[[1]]
```
Узнать размер ego-графа можно при помощи специальной функции.

```{r}
# размер подграфа
ego_size(writers,
  order = 2,
  nodes = "М.С.Пахомов",
  mode = "all")
```
Посмотрим, как растет размер сети при увеличении порядка.

```{r}
library(purrr)

f <- function(x) {
  ego_size(writers, 
  order = x,
  nodes = "М.С.Пахомов", 
  mode = "all")
}

order <- 1:10
out <- map_dbl(order, f)
plot(order, out, "o")

```

## Атрибуты ребер

У ребер в данных "Словаря..." есть атрибут, но он везде одинаковый.  

```{r}
options(max.print=35)

edge_attr(writers)
```
```{r echo=FALSE}
options(max.print=1000)
```

## Преобразование направленной сети в ненаправленную

Направленный граф бывает необходимо преобразовать в неправленный. Возьмем подграф "соседей" М.С. Пахомова и создадим симметричную сеть, оставив только те связи, где ссылки взаимны.

```{r}
p4 <- as.undirected(p3, mode = "mutual")

p4
```
В новой сети по-прежнему 48 узлов, но количество связей стало меньше (58 вместо 266). 

```{r}
par(mar = rep(0,4), cex = 0.7)
plot(p4, vertex.size=6, 
     edge.arrow.size = 0.5, 
     vertex.label.dist = 1,
     edge.curved = 0.2,
     edge.color = "grey80",
     vertex.color = "plum",
     layout = layout_p3)
```

## Удаление изолированных узлов

После симметризации некоторые узлы оказались изолированы. Удалим их. Для этого сначала необходимо найти узлы, степень которых равна 0.

```{r}
d <- unname(degree(p4))
p4 <- set_vertex_attr(p4, name = "degree", value = d)
```

Проверим.

```{r}
vertex_attr(p4)$degree
```


```{r}
p5 <- delete_vertices(p4, vertex_attr(p4)$degree == 0)
p5
```


```{r}
par(mar = rep(0,4), cex = 0.7)
layout_p5 <- layout_with_kk(p5)

plot(p5, vertex.size=6, 
     edge.arrow.size = 0.6, 
     vertex.label.dist = 1,
     edge.curved = 0.2,
     edge.color = "grey80",
     vertex.color = "plum",
     layout = layout_p5)
```

## Сравнение графов

Убедимся, что графы отличаются.

```{r}
identical_graphs(p4, p5)
```

Два графа называются _изоморфными_, если у них одинаковое число вершин (обозначим его n) и вершины каждого из них можно занумеровать так числами от 1 до n, что в первом графе две вершины соединены ребром тогда и только тогда, когда вершины с такими же номерами во втором графе соединены. 

Проверим подграфы на изоморфность.

```{r error=TRUE}
isomorphic(p4, p5)
```

Теперь произвольным образом переименуем узлы в p5, удалим один из атрибутов вершины (атрибуты ребер "потерялись" при симметризации) и снова проверим "двойника" на изоморфность. 

```{r}
p6 <- p5
V(p6)$name <- c(letters, "aa", "bb")
p6 <- delete_vertex_attr(p6, "degree")

p6
```
Снова сравним графы двумя способами.

```{r}
identical_graphs(p5, p6)
```
```{r}
isomorphic(p5, p6)
```

