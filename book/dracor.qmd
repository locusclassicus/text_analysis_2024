# Обнаружение сообществ. Dracor.

Граф -- это математический объект, и в этом уроке речь пойдет о том, как можно его описывать и анализировать. Данные для этого урока происходят из корпуса Dracor. 

## О корпусе Dracor

DraCor — сокращение от _drama corpora_ — это собрание размеченных по стандарту TEI драматических текстов. Здесь есть пьесы на французском, немецком, испанском, русском, итальянском, шведском, португальском (только Кальдерон) и английском (только Шекспир), а также совсем небольшие коллекции эльзасских, татарских и башкирских пьес.

Два крупных корпуса пьес в составе собрания — немецкий и русский — были собраны и поддерживаются создателями проекта DraCor. Остальные корпуса были взяты из сторонних проектов, а затем адаптированы для совместимости с функционалом DraCor. Подробнее об этом можно прочитать [здесь](https://sysblok.ru/philology/dracor-i-programmable-corpora-korpusa-dlja-cifrovyh-gumanitariev/).

На сайте проекта "Системный Блокъ" можно прочитать серию материалов о том, как возможности Dracor используются в литературоведении:

- о ["Ревизоре"](https://sysblok.ru/philology/socseti-russkoj-dramy-chast-ii-revizor-vs-gorodnichij-kto-zhe-glavnyj-geroj/);
- о [плотности сетей](https://sysblok.ru/nlp/prazdnik-ili-smert-drama-v-seti/) в трагедии и комедии;
- о "зоне смерти" в ["Гамлете"](https://sysblok.ru/philology/smert-v-seti/). 

## Начало работы с Dracor

```{r message=FALSE}
# remotes::install_github("Pozdniakov/rdracor")
library(rdracor)
library(tidyverse)
library(igraph)

get_dracor_meta()  |> 
  summary()
```

Извлекаем метаданные.

```{r}
meta <- get_dracor_meta()  |> 
  select(name, title, plays)

meta
```

```{r}
meta  |> 
  plot()
```

```{r warning=FALSE}
rus <- get_dracor("rus")
summary(rus)
```

```{r}
rus <- as_tibble(rus)
rus
```

Тут хранится очень много всего: размер сети, плотность сети и т.д. Вот так, например, выглядят самые длинные пьесы в корпусе:

```{r}
rus  |> 
  arrange(-wordCountText)  |> 
  select(firstAuthorName, title, wordCountText)
```

А так -- самые густонаселенные.

```{r}
rus  |> 
  arrange(-size) |> 
  select(firstAuthorName, title, size)
```
Подробнее см. [презентацию](https://rpubs.com/Pozdniakov/rdracor_presentation) Ивана Позднякова, разработчика DraCor Shiny App (https://shiny.dracor.org/).

## Сети Dracor

[Извлекаем](https://github.com/dracor-org/rdracor) граф для "Бориса Годунова".

```{r}
godunov <- get_net_cooccur_igraph(play = "pushkin-boris-godunov", corpus = "rus")

godunov
```

Помимо уже знакомых нам атрибутов вроде имени (`name (v/c)`), гендера (`gender (v/c)`) и степени (`degree(v/n)`), мы видим здесь много новой информации. Некоторые атрибуты интуитивно понятны: является ли персонаж групповым (`isGroup (v/l)`); в каком часле явлений он участвует (`numOfScenes (v/n)`); сколько у него реплик (`numOfSpeechActs (v/n)`) и слов (`numOfWords (v/n)`). 

Атрибут `wikidataId (v/c)` представлен лишь для исторических лиц, например, для самого [Годунова](https://www.wikidata.org/wiki/Q170172). 

```{r}
tibble(name = V(godunov)$name,
       isGroup = V(godunov)$isGroup,
       numOfScenes = V(godunov)$numOfScenes,
       numOfSpeechActs = V(godunov)$numOfSpeechActs,
       numOfWords = V(godunov)$numOfWords) |> 
  arrange(-numOfScenes)
```

Эта информация заботливо собрана создателями Dracor'а, но при желании ее можно проверить: функция `get_text_df()` дает возможность извлечь текст пьесы в виде датафрейма. Убедимся, например, что Григорий появляется в 8 сценах.

```{r}
godunov_df <- get_text_df(play = "pushkin-boris-godunov", corpus = "rus")
godunov_df
```

```{r}
godunov_df |> 
  filter(who == "grigorij_dimitrij_lzhedimitrij_samozvanets") |> 
  count(scene_id)
```

Нам осталось разобраться с такими атрибутами, как `weightedDegree (v/n)`, `closeness (v/n)`, `betweenness (v/n)`, `eigenvector (v/n)`, `weight (e/n)`. Начнем с последнего.

## Анализ узлов и ребер

### Вес ребра

Веса ребер, как следует из технической [документации](https://cran.r-project.org/web/packages/rdracor/rdracor.pdf) к пакету, хранят информацию о том, сколько раз персонажи вместе появляются на сцене.

```{r}
E(godunov)[weight > 1] 
```
Эти сведения можно извлечь и при помощи специальной функции.

```{r}
cooc_dracor <- get_net_cooccur_edges(play = "pushkin-boris-godunov", corpus = "rus")

cooc_dracor |> 
  filter(Weight > 1) |> 
  arrange(-Weight)
```
### Взвешенная центральность

_Важность_ (prominence) участника (актора, вершины, узла) определяется его положением внутри сети. Применительно к ненаправленным сетям говорят о _центральности_ (центральный актор вовлечен в наибольшее количество связей, прямых или косвенных), а применительно к направленным -- о _престиже_. Престижный актор характеризуется большим количеством входящих связей. 

Мы уже умеем считать _центральность по степени_ (degree centrality), которая определяется количеством связей: чем больше прямых связей, тем более важным является узел. 

```{r}
degrees <- degree(godunov)
sort(degrees, decreasing = T)[1:10]

# проверка
# V(godunov)$degree == degrees
```

С понятием веса ребра тесно связана _взвешенная центральность по степени_ (`weightedDegree(v/n)`). В отличие от простой центральности, она учитывает вес связанных с узлом ребер. 

```{r}
wDegree <- strength(godunov)

# проверка
tibble(wd_old = V(godunov)$weightedDegree,
       wd_new = wDegree) |> 
  arrange(-wd_old)

```

Вот так, например, считается взвешенная центральность для Бориса Годунова:

```{r}
# ребра, связанные с Годуновым
idx <- incident(godunov, "Борис")

# суммарный вес ребер
sum(E(godunov)[idx]$weight)
```

На графе веса ребер можно отразить за счет толщины и (или) прозрачности линии, а взвешенную центральность - за счет размера узла

```{r}
library(ggraph)
library(paletteer)
cols <- paletteer_d("nbapalettes::hawks_statement")

set.seed(22092024)
ggraph(godunov, layout = "kk", maxiter = 500) + 
  # здесь кодируем вес ребер
  geom_edge_link(aes(alpha = weight),
                 color = cols[3],
                 width = 0.8,
                 show.legend = FALSE) +
  # здесь взвешенная центральность
  geom_node_point(aes(size = weightedDegree),
                  color = cols[2],
                  show.legend = FALSE) + 
  # обратите внимание на фильтр!
  geom_node_text(aes(filter = (weightedDegree > 10 | name %in% c("Курбский", "Воротынский")),
                     label = name),
                 color = cols[1],
                 repel = TRUE) +
  theme_graph()
```

### Центральность по близости

_Центральность по близости_ (closeness centrality) говорит о том, насколько близко узел расположен к другим узлам сети. Центральность по близости -- это величина, обратная сумме расстояний от узла i до всех остальных узлов сети. 

$$\frac{1}{\sum_{i\neq v}d_{vi}}$$

:::{.callout-info icon=false}
обратите внимание: в версии igraph 2.0.3 способ расчета closeness centrality [изменился](https://cran.r-project.org/web/packages/igraph/news/news.html), поэтому наши результаты будут немного отличаться от того, что хранится в атрибутах узлов).
:::

```{r}
close_new <- closeness(godunov, 
                     mode = "all",
                     normalized = TRUE)

# похожие значения хранятся как атрибуты узлов
tibble(name = V(godunov)$name,
       close_old = V(godunov)$closeness,
       close_new = close_new) |> 
arrange(-close_old)
```

> В пьесах эта метрика может означать, напрямую ли взаимодействуют с этим персонажем или нет. Например, в пьесе А. Н. Островского «Лес» персонаж Аксюша имеет невысокую взвешенную степень, но наибольшую степень близости. По сюжету, она находится в зависимом положении, в первую очередь от Гурмыжской (которая имеет наибольшую взвешенную степень), и это может означать что остальные персонажи взаимодействуют с ней напрямую, так как могут себе это позволить. -- [Источник](https://sysblok.ru/philology/socseti-russkoj-dramy-chast-i-osnovy-setevogo-analiza/).

На графе закодируем этот атрибут цветом; температурную шкалу установим вручную.

```{r}
set.seed(22092024)
ggraph(godunov, layout = "kk", maxiter = 500) + 
  geom_edge_link(aes(alpha = weight),
                 color = cols[3],
                 width = 0.8,
                 show.legend = FALSE) +
  geom_node_point(aes(size = weightedDegree,
                      # тут новое
                      color = closeness),
                  show.legend = FALSE) + 
  geom_node_text(aes(filter = (weightedDegree > 10 | name %in% c("Курбский", "Воротынский")),
                     label = name),
                 color = cols[3],
                 repel = TRUE) +
  # градиентная шкала для closeness
  scale_color_gradient(low = "plum", high = "purple") +
  theme_graph()
```

### Центральность по посредничеству

_Центральность по посредничеству_ (betweenness centrality) характеризует, насколько важную роль данный узел играет на пути "между" парами других узлов сети. 

```{r}
betweenness_new <- betweenness(godunov, 
                               directed = FALSE,
                               normalized = TRUE)

tibble(name = V(godunov)$name,
       b_old = round(V(godunov)$betweenness, 4),
       b_new = round(betweenness_new, 4)) |> 
  arrange(-b_old)
```

> Хороший пример персонажа с высокой степенью посредничества в корпусе русской драмы — второстепенный персонаж Гаврила Пушкин из пьесы «Борис Годунов» А.С. Пушкина. ...По сюжету, он является связующим персонажем между приближёнными Бориса и Григорием. При прочтении легко не заметить важность этого персонажа, однако на визуализации сети пьесы хорошо видно, что Гаврила связывает два кластера — персонажей в Москве и в Польше. -- [Источник](https://sysblok.ru/philology/socseti-russkoj-dramy-chast-i-osnovy-setevogo-analiza/).

### Центральность по собственному вектору

Степень влиятельности (eigenvector centrality) показывает важность персонажа, учитывая влиятельность персонажей, с которыми взаимодействует данный персонаж. В пьесах эта метрика позволяет разделить действующих лиц на «центральных» и «периферийных». 

> Персонажи более значимы, если они взаимодействуют с персонажами важнее себя, и теряют свою значимость при контакте с менее важными действующими лицами. -- [Источник](https://sysblok.ru/philology/socseti-russkoj-dramy-chast-i-osnovy-setevogo-analiza/).

Чтобы посчитать eigenvector centrality, необходимо преобразовать граф в матрицу смежности (социоматрицу), в которой единицами отмечено наличие рёбер между персонажами, а нулями -- их отсутствие. Вместо единиц в матрице могут быть указаны веса рёбер; в таком случае матрица будет взвешенной. 

У таких матриц есть собственные векторы, то есть такие векторы, произведение которых на матрицу эквивалентно произведению числа на этот вектор. 

$$\lambda \cdot C_e = A \cdot C_e,$$
где 

- $А$ — это матрица смежности;
- $λ$ — действительное число;
- $С_e$ — собственный вектор матрицы $А$.

Элементы вектора $C_e$ являются степенями влиятельности для каждой вершины. Это можно переписать для отдельных вершин так:

$$C_e(v_i)=\frac{1}{\lambda}\sum_{j=1}^{n}a_{ij} C_e(v_j),$$
где 

- $С_E(v_i)$ — это степень влиятельности вершины $v_i$;
- $a_ij$ — элемент матрицы $A$, расположенный в i-й строке и j-м столбце.

В такой записи видно, что на степень влиятельности вершины $v_i$ влияют значения всех остальных вершин. Алгоритм расчета eigenvector centrality в последних версиях igraph немного отличается. 

```{r}
eigen_new <- eigen_centrality(godunov, scale = FALSE)$vector

tibble(name = V(godunov)$name,
       eigen_old = V(godunov)$eigenvector,
       eigen_new = eigen_new) |> 
  arrange(-eigen_old)
```

Теперь мы понимаем смысл всех атрибутов в графах Dracor, и можем перейти к характеристике графа в целом.


## Централизация

Рассмотрим два крайних случая: круговой граф и звездчатый граф. 

```{r}
star_g <- make_star(5, mode = "undirected") 
circle_g <- make_ring(5)

par(mfrow = c(1, 2))
plot(circle_g, vertex.color=2)
plot(star_g, vertex.color=3)
```

В случае звездчатого графа централизация максимальна, а для отдельных узлов наблюдается разброс центральности. 

```{r}
centr_clo(star_g)
```

Во втором случае наборот -- разброса нет, а для графа в целом централизация минимальна.

```{r}
centr_clo(circle_g)
```

Расчитаем централизацию для графа "Годунова". 

```{r}
centr_clo(godunov)$centralization
```

Но в наших данных она уже рассчитана.

```{r}
summary(godunov)
```

## Точки сочленения

Точка сочленения -- это узел, при удалении которого увеличивается число компонент связности. Таким образом, они соединяют разные части сети. При их удалении акторы (узлы, вершины) не могут взаимодействовать друг с другом. 

```{r}
articulation_points(godunov)
```

Точки сочленения тесто связаны с центральностью по посредничеству.

```{r}
V(godunov)[betweenness > 0.025]
```

## Клики

Многие сети состоят из относительно плотных подгрупп, которые соединены между собой менее крепкими связями. Один из способов взглянуть на подгруппы сети заключается в исследовании _социальной сплочености_ (cohesion). Сплоченные подгруппы - это множество акторов, которые объединены между собой посредством многочисленных, сильных и прямых связей. 

_Клика_ -- один из самых простых типов сплоченных подгрупп; это максимально полный подграф, т.е. подмножество узлов со _всеми_ возможными связями между ними. Вопреки своему названию, функция `clique_num()` возвращает размер наибольшей клики:

```{r}
clique_num(godunov)
```
На самом деле таких клик даже три. Узнаем, кто туда входит.

```{r}
cliques(godunov, min=11)
```

Или, что то же самое:

```{r eval=FALSE}
largest_cliques(godunov)
```

Но клика -- это очень строгое определение сплоченной группы. Например, чтобы подграф, состоящий из 11 вершин, считался кликой, нужно, чтобы между ними было проведено $(11 \times 10) / 2 = 21$ связей. Если хотя бы одно ребро отсутствует, то условие не выполняется. Такие клики просто очень редко встречаются. 

## K-ядра

Популярным определением социальной сплоченности является _k-ядро_ (k-core). Это максимальный подграф, в котором каждая вершина связана минимум с k другими вершинами этого же подграфа. K-ядра имеют множество преимуществ:

- они вложены друг в друга (каждый участник 4-ядра является также участником 3-ядра и т.д.);
- они не перекрываются;
- их легко определить. 

:::{.callout-info icon=false}
Выражение 6-ядро читают как "ядро степени 6". 
:::

Ядро степени k+1 является подграфом ядра степени k. Любой узел в ядре степени k имеет степень либо k, _либо выше_. При этом coreness узла определяется по ядру с наибольшей степенью, к которому они принадлежат. 

![](https://www.researchgate.net/publication/326621799/figure/fig1/AS:652484443910144@1532575822967/Illustration-of-the-k-core-decomposition-Here-k-max-3.png)

Для определения k-ядерной структуры используется функция `graph.coreness()`:

```{r}
cores_godunov <- coreness(godunov)
head(cores_godunov)
```

Посчитаем количество вершин в ядрах.

```{r}
table(cores_godunov)
```


Для лучшей интерпретации k-ядерной структуры мы можем графически изобразить сеть, используя информацию о множестве k-ядер. Для начала добавим информацию о цвете к атрибутам узлов. 

```{r}
V(godunov)$core <- cores_godunov

# убедимся, что добавился новый атрибут
names(vertex_attr(godunov))
```

```{r}
set.seed(22092024)
ggraph(godunov, layout = "kk", maxiter = 500) + 
  geom_edge_link(color = cols[3],
                 alpha = 0.3,
                 width = 0.6) +
  # тут  новое
  geom_node_point(aes(color = as.factor(core)),
                  size = 3, 
                  show.legend = TRUE) + 
  # новый фильтр
  geom_node_text(aes(filter = degree > 10,
                     label = name),
                 color = cols[3],
                 repel = TRUE) +
  scale_color_brewer("k-ядра", type = "qual") +
  theme_void()
``` 


Чтобы глубже исследовать подгруппы, последовательно удаляют k-ядра более низкой степени. Для этого можно воспользоваться функцией `induced_subgraph()`. 

```{r}
godunov5_10 <- induced_subgraph(godunov, vids=V(godunov)[core > 4])

ggraph(godunov5_10, layout = "kk", maxiter = 500) + 
  geom_edge_link(color = cols[3],
                 alpha = 0.3,
                 width = 0.6) +
  geom_node_point(aes(color = as.factor(core)),
                  size = 3, 
                  show.legend = TRUE) + 
  geom_node_text(aes(filter = degree > 10,
                     label = name),
                 color = cols[3],
                 repel = TRUE) +
  scale_color_brewer("k-ядра", type = "qual") +
  theme_void()
```

При интерпретации важно помнить, что ядра являются вложенными. Чем выше степень ядра, тем больше узлы связаны между собой.

## Модулярность

Модулярность — одна из мер структуры сетей или графов. Мера была разработана для измерения силы разбиения сети на модули (называемые группами, кластерами или сообществами). Сети с высокой модулярностью имеют плотные связи между узлами внутри модулей, но слабые связи между узлами в различных модулях.

![](https://www.researchgate.net/profile/Maksim-Koptelov-2/publication/345039212/figure/fig8/AS:952552506019840@1604117623007/Modularity-values-and-quality-of-discovered-communities-12_W640.jpg)

Модулярность равна доле рёбер от общего числа рёбер, которые попадают в данные группы, минус ожидаемая доля рёбер, которые попали бы в те же группы, если бы они были распределены случайно. 

Если все узлы принадлежат к одному классу, то модулярность равна нулю. Если разбиение на классы хорошее, то модулярность должна быть высокая. Мы можем проверить, хорошо ли группируются персонажи по гендеру. Для этого перекодируем гендер, так как функция `modularity()` принимает числовую переменную в качестве аргумента. Значение гендера 3 (unknown) в пьесе имеют групповые персонажи.

```{r}
V(godunov)$gender

## male = 1
idx <- V(godunov)$gender=="MALE"
V(godunov)$gender[idx] <- 1

## female = 2
idx <- V(godunov)$gender=="FEMALE"
V(godunov)$gender[idx] <- 2

## unknown = 3
idx <- V(godunov)$gender=="UNKNOWN"
V(godunov)$gender[idx] <- 3
```

```{r}
gender <- as.numeric(V(godunov)$gender)
modularity(godunov, gender)
```

:::{.callout-info icon=false}
При выделении сообществ в большинстве случаев наша задача -- максимизировать модулярность.
:::

Очевидно, что гендер не лучшим образом описывает деление персонажей "Годунова" на группы. Поищем другие сообщества.

## Алгоритмы обнаружения сообществ

В пакете `igraph` реализовано множество алгоритмов обнаружения сообществ. Обычной практикой является применение нескольких алгоритмов и сравнение результатов. 

![](./images/communities-detection.png)

У нас ненаправленная взвешенная сеть. Применим алгоритм "случайного блуждания".

```{r}
cw <- cluster_walktrap(godunov)
membership(cw) |> head()
```

```{r}
par(mar = rep(0, 4))
plot(cw, godunov)
```

Значение модулярности достаточно высокое (уж точно лучше, чем гендер). 

```{r}
modularity(cw)
```

Поищем другое разбиение.

```{r}
csg <- cluster_spinglass(godunov)
membership(csg) |> head()
```

```{r}
par(mar = rep(0, 4))
plot(csg, godunov)
```

Показатели модулярности чуть выше, чем для предыдущего разбиения.

```{r}
modularity(csg)
```

Также используем алгоритм под названием "главный собственный вектор".

```{r}
cev <- cluster_leading_eigen(godunov)
modularity(cev)
```

```{r}
par(mar = rep(0, 4))
plot(cev, godunov)
```
