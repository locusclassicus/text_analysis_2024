# Стилометрический анализ с пакетом `stylo`

## Установка `stylo` 

В этом уроке мы рассмотрим возможности стилометрического анализа с использованием пакета [stylo](https://github.com/computationalstylistics/stylo?tab=readme-ov-file
). К пакету прилагается внятный [HOWTO](https://github.com/computationalstylistics/stylo_howto/blob/master/stylo_howto.pdf). 

```{r}
library(stylo)
```

Возможности этого инструмента мы исследуем на корпусе древнегреческой литературы, подробнее о котором можно прочитать [в препринте](https://github.com/locusclassicus/compareDist/blob/master/%D1%82%D0%B5%D0%BA%D1%81%D1%82%20%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8/CompareDist_0912023.pdf) (upd.: [опубликованная версия](http://pushkinskijdom.ru/zhurnal-tsifrovye-issledovaniya/tsifrovye-gumanitarnye-issledovaniya-1-2024/)). Для этого эксперимента корпус был немного урезан и разложен по папкам. Корпус в формате `.zip` надо забрать по [ссылке](https://github.com/locusclassicus/text_analysis_2024/raw/main/files/stylo.zip) и сделать рабочей директорией. 

Тексты могут быть на любом языке, но обязательно в кодировке Unicode.

На Mac может потребоваться поставить XQuartz.

## `stylo()`

Главная рабочая лошадка этого пакета -- функция `stylo()`. Если вызвать ее без аргументов, то запустится GUI (который можно отключить).

```{r eval=FALSE}
stylo()
```

На вкладке `Input & Language` выбираете формат файла и язык. 

![](./images/stylo1.png)

На вкладке `Features` указываете, как разбивать текст: на слова, символы, словесные или символьные энграмы. Также можно уточнить, что делать с прописными буквами (в нашем случае это нерелевантно). Параметр `MFW` указывает, сколько слов использовать для анализа. `CULLING` задает порог отсечения для слов: 20 означает, что будут использованы слова, которые встречаются как минимум в 20% текстов, 0 -- все слова, 100 - только те, которые есть во всех текстах корпуса. 

![](./images/stylo2.png)

Следующая вкладка определяет метод, который будет использоваться для анализа. 

![](./images/stylo3.png)

Можно также уточнить метод выборки. 

![](./images/stylo4.png)

И, наконец, формат, в котором следует вернуть результат.

![](./images/stylo5.png)

Без графического интерфейса команда будет выглядеть так.

```{r eval=FALSE}
stylo(corpus.dir = "corpus", 
      analysis.type = "CA",
      analyzed.features="w", 
      ngram.size=1,
      culling.min=20,
      culling.max=20,
      mfw.min = 100,
      mfw.max = 100,
      mfw.incr = 0,
      distance.measure = "dist.delta",
      write.png.file = FALSE,
      gui = FALSE,
      corpus.lang = "Other",
      plot.custom.height=8,
      plot.custom.width=7
      )
```

![](./images/stylo8.png)

Подписи и цвета функция подбирает автоматически. Попробуйте использовать другие меры расстояния и другие статистические методы, и сравните результат (пока можно не обращать внимания на `Consensus Tree` -- об этом поговорим на следующем занятии). После каждого запуска функции в рабочей директории сохраняются файлы с конфигурацией, признаками, которые использовались для анализа и, опционально, визуализация.

```{r eval=FALSE}
stylo(corpus.dir = "corpus", 
      analysis.type = "PCR",
      analyzed.features="w", 
      ngram.size=1,
      mfw.min = 100,
      mfw.max = 100,
      mfw.incr = 0,
      #pca.visual.flavour="loadings",
      write.png.file = FALSE,
      gui = FALSE,
      corpus.lang = "Other",
      plot.custom.height=8,
      plot.custom.width=8,
      save.analyzed.freqs=FALSE
      )
```

![](./images/stylo9.png)

Заглянуть внутрь функции `stylo()` можно [здесь](https://rdrr.io/cran/stylo/src/R/stylo.R). 

## Что такое Delta

[Delta Берроуза](https://sysblok.ru/glossary/a-avtor-kto-rassudit-delta-bjorrouza/) -- это мера стилистической близости между текстами. Метод был [предложен](https://academic.oup.com/dsh/article-abstract/17/3/267/929277) в 2001 году австралийским филологом Джоном Бёрроузом. С тех пор дельту используют во многих исследованиях, большая часть которых посвящена установлению авторства различных произведений. 

Суть метода заключается в том, что для корпуса текстов рассчитывается частотность ряда признаков; это могут быть слова (словоформы) или так называемые n-граммы, то есть последовательности n символов подряд. Для сравнения берутся самые частотные слова, среди которых будет значительная доля служебных, в наименьшей степени связанных с тематикой текста (предлоги, союзы, частицы и т.п.). Поскольку сравниваемые тексты, как правило, имеют разную длину, в стилометрических исследованиях принято брать для сравнения относительную, а не абсолютную частотность; Берроуз идет еще дальше, предлагая использовать так называемые z-scores, то есть стандартизированные оценки, показывающие разброс значений относительно средних. Z-score вычисляется по формуле: 

$$Ζ =\frac{x-\mu}{sd}$$

Здесь случайная величина $x$ — это значение частотности, $μ$ — математическое ожидание (среднее), а $sd$ — стандартное отклонение. Иными словами, z-score показывает, на сколько стандартных отклонений x отстоит от ожидаемого. Зная z-scores для заданных слов у известных авторов/текстов, можно сравнить их с z-scores спорного текста; искомая дистанция Delta вычисляется как сумма взятых по модулю разниц между z-scores у двух сравниваемых текстов, поделенная на количество слов: 

$$ΔB = \frac{1}{n}\times\ \sum_{i}^{n}{|z_{i,\ A-}}z_{i,\ B}|$$,

где i – конкретное слово, n – общее число слов, а A и B – сравниваемые авторы (знак | указывает, что суммируется абсолютное значение разницы). Чем больше дистанция, тем менее вероятно авторство.

Простота метода позволяет использовать его в традиционных методах обучения без учителя, таких как кластерный анализ, так и с машинно-обучаемыми классификаторами, когда для каждого значения предиктора $x_i$ имеется значение отклика $y_i$. Это позволяет, имея показатели предикторов, прогнозировать отклик, то есть, в нашем примере, определять наиболее вероятного автора. Количество классов формально не ограничено: мы можем сравнивать спорные тексты (test set) как с двумя, так и с двадцатью кандидатами, которые включаются в обучающую выборку (training set).

Пакет `stylo` дает возможность работать не только с классической Delta, но и с ее вариациями, из которых заслуживает внимание т.н. "вюрцбургская Delta". В отличие от Delta Берроуза, она использует не манхэттенское, а косинусное расстояние, что во многих случаях позволяет повысить точность классификации. Подробнее о разных расстояниях (на примере древнегреческого корпуса) см.  [препринт](https://github.com/locusclassicus/compareDist/blob/master/%D1%82%D0%B5%D0%BA%D1%81%D1%82%20%D1%81%D1%82%D0%B0%D1%82%D1%8C%D0%B8/CompareDist_0912023.pdf). Upd. 2026: [Ссылка](https://pushkinskijdom.ru/mery-rasstoyaniya-dlya-opredeleniya-avtorstva-drevnegrecheskih-tekstov/) на публикацию.

## `classify()`

Если `stylo()` возвращает результат, который должен интерпретировать человек, то `classify()` используется для машинного обучения с учителем. Вызов функции без аргументов  вернет GUI, похожий на тот, что мы видели выше. Отличие будет на вкладке "Статистика". 

![](./images/stylo6.png)

Среди доступных методов классификации: Delta, k-NN, SVM, Наивный Байес, метод ближайших центроидов. Подробнее о них мы будем говорить позже, а пока можно поэкспериментировать с Delta.

Перед запуском функции необходимо создать в рабочей директории две папки: `primary_set` и `secondary_set` (они есть в архиве, который вы уже скачали). В первой находится так называемые обучающие данные, во второй - тестовые (контрольные) данные. Обычно это тексты неизвестного авторства, но к ним можно добавить и несколько произведений известного авторства для дополнительного контроля. Мы примем за спорные отрывок из "Греческой истории" Ксенофонта, диалог "Софист" Платона, "Наблюдателей" Лукиана и "Против софистов" Исократа.

```{r eval=FALSE}
classify_result <- classify(
      training.corpus.dir = "primary_set",
      test.corpus.dir = "secondary_set",
      classification.method = "delta",
      culling.of.all.samples = FALSE,
      analyzed.features="w", 
      culling.max=20,
      culling.min=20,
      ngram.size=1,
      mfw.min = 100,
      mfw.max = 100,
      mfw.incr = 0,
      gui = FALSE,
      corpus.lang = "Other")
```

```{r echo=FALSE, eval=FALSE}
save(classify_result, file = "../data/classify_result.Rdata")
```

```{r echo=FALSE}
load("../data/classify_result.Rdata")
```

После того, как функция вернет управление, в рабочей директории появится несколько файлов, среди них -- `final_results.txt`. В нашем случае успех 100%, но не стоит переоценивать этот результат: пример был совсем игрушечный. О подводных камнях поговорим в модуле про машинное обучение.

```{r}
classify_result$expected == classify_result$predicted
```

Теперь попробуйте поэкспериментировать с разными методами и настройками.


## `samplesize.penalize()`

Одна из известных проблем стилометрии связана с тем, что любые метрики плохо работают на [небольших отрывках](https://academic.oup.com/dsh/article-abstract/30/2/167/390738). Но какого размера должен быть текст, чтобы мы могли установить его автора?

Функция `samplesize.penalize()` позволяет проверить эффективность метода на отрывках разной длины  при работе с различными машинно-обучаемыми классификаторами, в том числе Delta. 

Функция извлекает из текста случайные выборки все большей и большей длины и сравнивает их с обучающей выборкой для классификации с применением разного числа mfw; по умолчанию для каждой заданной длины отрывка проводится 100 итераций. На выходе функция возвращает матрицы с указанием количества успешных классификаций для каждой длины отрывка и заданного количества mfw, а также матрицы смешения, позволяющие судить о том, между какими авторами чаще возникала путаница.

```{r eval=FALSE}
penalize_result <- samplesize.penalize(mfw = c(100, 200, 500), 
                    features = NULL,
                    path = NULL, corpus.dir = "corpus",
                    sample.size.coverage = seq(100, 5000, 100),
                    sample.with.replacement = TRUE,
                    iterations = 100, 
                    classification.method = "delta")
```

```{r echo=FALSE, eval=FALSE}
save(penalize_result, file = "../data/penalize_result.Rdata")
```

```{r echo=FALSE}
load("../data/penalize_result.Rdata")
```

Функция вернет список с показателями точность и матрицами смешения и некоторыми другими показателями. Подробнее о матрицах смешения мы будем говорить в разделе про машинное обучение, а пока просто посмотрим на то, как это выглядит.

```{r message=FALSE}
library(tidyverse)

helen_confusion_mfw100 <- penalize_result$confusion.matrices$Isocrates_Hel$mfw_100 |> 
   as.data.frame() |> 
   rownames_to_column("predicted") |> 
   as_tibble()

helen_confusion_mfw100
```
Вытянем в длину и визуализируем.

```{r}
helen_confusion_mfw100 |> 
  filter(predicted == "Isocrates") |> 
  pivot_longer(-predicted, 
               names_to = "sample_size", 
               values_to = "n") |> 
  ggplot(aes(as.numeric(sample_size), n)) +
   geom_point(color = "steelblue") + 
   scale_x_continuous(breaks = seq(100, 5000, 300)) +
   labs(x = NULL)
   
```

Больше о подборе оптимального размера выборки см. [статью](https://classics.nsu.ru/schole/16/16-2-alieva.pdf) в журнале Schole.

## `rolling.delta()`

Еще одна "фирменная" функция `stylo`  называется `rolling.delta()`. Она подходит для тех случаев, когда текст написан в соавторстве (или мы предполагаем, что это так). Delta "прокатится" по всему тексту и для каждого его отрывка оценит вероятность того, что он создан тем или иным автором. Разумеется, это имеет смысл лишь в том случае, если у нас, во-первых, достаточно длинный спорный текст, а, во-вторых, есть понятные кандидаты. [Статья](https://computationalstylistics.github.io/projects/rolling-stylometry/) от создателей с красивой картинкой (и еще [одна](https://maciejeder.org/projects/rolling_stylo/)). 

Для демонстрации работы функции мы составили "монстра" из "Бусириса" Исократа и "Софиста" Платона: первая тысяча слов из Исократа, потом две тысячи из Платона, потом еще тысяча из Исократа и тысяча из Платона. Монстр лежит в папке `test_set`. Обучающие данные находятся в папке `reference_set`.

```{r eval=FALSE}
rolling.classify(training.corpus.dir = "reference_set",
                 test.corpus.dir = "test_set",
                 write.png.file = FALSE, 
                 classification.method = "delta", 
                 mfw = 150, 
                 corpus.lang="Other", 
                 slice.size = 500, 
                 slice.overlap = 200,
                 plot.legend = FALSE,
                 milestone.points = seq(0, 5000, 500),
                 shading = TRUE
                 )
par(mar=c(0,0,0,0))
legend('top', c("Isocrates","Plato"), 
       col=c('red', 'green'), lty = 2)

```


![](./images/stylo10.png)

## `oppose()`

Функция `oppose()` реализует контрастивный анализ, помогая понять, каких слов авторы избегают, а какие -- предпочитают. Функция возвращает два файла: `words-preferred.txt` и `words-avoided.txt`. Она тоже поддерживает графический интерфейс, но с древнегреческим [бывают](https://github.com/computationalstylistics/stylo/issues/55#issuecomment-2356146537) трудности токенизации, поэтому прописываем правило при помощи регулярных выражений.


Для сравнения возьмем Платона и Исократа (они тоже есть в архиве). 

```{r eval=FALSE}
oppose(corpus.format = "plain",
       corpus.lang = "Other",
       primary.corpus.dir = "Plato" , 
       secondary.corpus.dir = "Isocrates", 
       splitting.rule = "[ \t\n]+",
       text.slice.length = 1000,
       text.slice.overlap = 0,
       rare.occurrences.threshold = 3,
       zeta.filter.threshold = 0.05,
       oppose.method = "craig.zeta",
       display.on.screen = TRUE,
       gui = FALSE)
```

![](./images/stylo7.png)

Изменим настройки визуализации и проверим, к кому из двух ближе Демосфен.

```{r eval=FALSE}
oppose(corpus.format = "plain",
       corpus.lang = "Other",
       primary.corpus.dir = "Plato" , 
       secondary.corpus.dir = "Isocrates", 
       test.corpus.dir = "Demosthenes",
       splitting.rule = "[ \t\n]+",
       text.slice.length = 1000,
       text.slice.overlap = 0,
       rare.occurrences.threshold = 3,
       visualization="markers", # изменение тут
       zeta.filter.threshold = 0.05,
       oppose.method = "craig.zeta",
       display.on.screen = TRUE,
       gui = FALSE)
```

![](./images/stylo11.png)

## Что такое Zeta

Контрастивный анализ, который проводит функция `oppose()`, тоже основан на методе, [предложенном](https://academic.oup.com/dsh/article-abstract/22/1/27/1024545) Д. Берроузом. Этот метод был описан и доработан рядом других исследователей, в том числе [Хью Крейгом](https://www.cambridge.org/core/books/shakespeare-computers-and-the-mystery-of-authorship/89F8AEF655C5FFD3D73E500870C71972). 

Его смысл подробно объясняет @savoy2020, а более популярное объяснение (со ссылками на специальную литературу) можно найти на сайте <https://zeta-project.eu>. Общий смысл такой. Берутся два корпуса, которые необходимо сравнить. Это может быть корпус мужской и женской прозы, корпус Шекспира и других драматургов его времени, корпус американских и британских детективов... you name it. Один из корпусов (назовем его `primary set`) принимается за основу сравнения. 

Все тексты делятся на фрагменты фиксированной длины, обычно от 900 до 6000 слов [@savoy2020, 154]. Дальше считается, в какой доле фрагментов из `primary set` слово встретилось и в какой доле фрагментов из `secondary set` оно _не_ встретилось. Затем доли суммируются (тогда $0 \leqslant  z \leqslant  2$). Допустим, мы сравниваем Шекспира и Марлоу. Если у Шекспира слово есть во всех фрагментах, а у Марлоу -- ни в одном, то $1 + 1 = 2$. Если наоборот, то $0 + 0 = 0$. На практике крайние значения встречаются очень редко. 

[Другой вариант](https://ceur-ws.org/Vol-2989/short_paper11.pdf) с примерно тем же смыслом. Считаем долю документов, в которых слово _встречается_ у Шекспира и у Марлоу. Например, у Шекспира в 100%, а у Марло - ни в одном. Вторая доля вычитается из первой: $1 - 0 = 1$. Если наоборот, то Zeta равна $-1$. Таким образом,  $-1 \leqslant  z \leqslant  1$.

Достоинство этого метода в том, что результат легко интерпретировать: мы сразу видим слова-дискриминаторы. Но надо помнить, что Zeta работает не с самыми частотными словами (точнее, не только с ними), а значит подвержена влиянию тематики и жанра. 

## `imposters()`

Функция `imposters()` реализует метод верификации авторства, предложенный в [статье](https://asistdl.onlinelibrary.wiley.com/doi/epdf/10.1002/asi.22954) М. Коппеля и Я. Винтера и [апробированный](https://www.sciencedirect.com/science/article/abs/pii/S0957417416303116) на корпусе Цезаря.  

Название метода отражает его суть: вместо того чтобы сравнивать текст неизвестного автора с текстами предполагаемых авторов, метод использует "импостеров" — случайно выбранные тексты, не принадлежащие ни одному из кандидатов, — для создания фона, на котором оценивается вероятность принадлежности текста конкретному автору.

Основные идеи метода imposters:

1. Создание обучающей выборки. Для проверки гипотезы о принадлежности текста определенному автору берется его текст, тексты кандидатов и большое количество "самозванцев" (то есть случайные тексты, которые заведомо не принадлежат ни одному из кандидатов).
   
2. Бустреп-подход. Метод много раз случайным образом выбирает подмножества признаков и случайные наборы "импостеров", а затем выполняет этап классификации.

3. Проверка гипотезы. Если текст подозреваемого автора чаще всего классифицируется как принадлежащий этому автору, можно с высокой вероятностью утверждать, что это действительно так. Если же нет, значит, автором с большей долей вероятности является кто-то другой.

Почему такой метод эффективен? Классические методы (например, Delta-классификатор Бэрроуза) могут быть чувствительны к дисбалансу классов или менее устойчивы к вариативности текстов. Кроме того, использование "самозванцев" позволяет создать "естественный уровень шумова", на фоне которого можно оценить значимость конкретной атрибуции.

Автор считается установленным, если атрибуция одному автору превышает некий установленный порог; значение этого порога устанавливается в зависимости от того, какова цена ошибки, то есть что для нас важнее -- точность, precision (доля объектов, названными классификатором положительными и при этом действительно являющимися положительными) или полнота, recall (доля объектов положительного класса из всех объектов положительного класса). В качестве подмоги можно использовать функцию `imposters.optimize()`.


Об этой функции см. подробнее [виньетку](https://computationalstylistics.github.io/docs/imposters) и [документацию](https://rdrr.io/cran/stylo/man/imposters.html). На входе она требует уже подготовленные таблицы с частотностями. Обратите внимание: если не задать значение аргументу `candidate.set`, функция проверит на авторство все доступные в `reference.set` классы. 

```{r message=FALSE}
data("galbraith")

# забираем 8-й ряд из датасета:
my_text_to_be_tested = galbraith[8,]

# исключаем 8-й ряд из датасета
my_frequency_table = galbraith[-c(8),]

# поехали:
imposters(reference.set = my_frequency_table, 
          test = my_text_to_be_tested,
          iterations = 100,
          features = 0.5)
```

Функция возвращает вектор вероятностей, где значения, близкие к 1, соответствуют наиболее правдоподобным кандидатам на авторство. 

```{r}
library(stringr)

# кандидаты
idx = str_detect(rownames(my_frequency_table), "rowling")
my_candidates <- my_frequency_table[idx, ]
my_imposters <- my_frequency_table[-idx, ]

# поехали:
imposters(reference.set = my_imposters, 
          test = my_text_to_be_tested,
          # вот тут задаем кандидатов
          candidate.set = my_candidates,
          iterations = 100,
          features = 0.5,
          # доля импостеров для каждой итерации
          imposters = 1)
```

## Полезные материалы 

О стилометрии есть множество отличных материалов на "Системном блоке":

- "[Кто какую часть произведения написал? Выясняем с помощью Stylo](https://sysblok.ru/philology/kto-kakuju-chast-proizvedenija-napisal-vyjasnjaem-s-pomoshhju-stylo/)"
- "[Какие слова отличают один корпус от другого? Продолжаем изучать Stylo](https://sysblok.ru/philology/kakie-slova-otlichajut-odin-korpus-ot-drugogo-prodolzhaem-izuchat-stylo/)"
- "[Как провести стилометрический эксперимент с помощью stylo?](https://sysblok.ru/courses/kak-provesti-stilometricheskij-jeksperiment-s-pomoshhju-stylo/)"
- "[«Тихий Дон» и стилометрия: что говорят о «Шолоховском вопросе» количественные методы](https://sysblok.ru/blog/blog_danil_skorinkin/tihij-don-i-stilometrija-chto-govorjat-o-sholohovskom-voprose-kolichestvennye-metody/)"

Материалы для экспериментов доступны на GitHub: 

- Скоринкин Д. Попрактикуемся в стилометрии [Электронный ресурс] // Github.com. 31.01.2023 URL: <https://github.com/dhhse/distantreading/blob/main/stylometry/stylometry_practice.md> (дата обращения 23.01.2026).
- Еще один [датасет](https://github.com/dhhse/distantreading/raw/refs/heads/main/stylometry/stylometry_texts/rollingclassify.zip) от Д. Скоринкина (Ильф и Петров), подойдет для rolling delta.

