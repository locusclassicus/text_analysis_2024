[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Компьютерный анализ текста",
    "section": "",
    "text": "Введение",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#об-этом-курсе",
    "href": "index.html#об-этом-курсе",
    "title": "Компьютерный анализ текста",
    "section": "Об этом курсе",
    "text": "Об этом курсе\nЭтот сайт содержит материалы к курсу “Компьютерный анализ текста в R” для магистерской программы НИУ ВШЭ “Цифровые методы в гуманитарных науках”. Предыдущую версию курса можно найти здесь.\nИ тексты, и инструменты для работы с ними подобраны таким образом, чтобы помочь студентам гуманитарных специальностей (филологам, философам, историкам и др.) как можно быстрее, но с полным пониманием дела перейти к применению количественных методов в собственной работе.\nЧтобы лучше понимать, какие из этих методов более всего востребованы в научной работе, преподаватели магистратуры “Цифровые методы в гуманитарных науках” – Б.В. Орехов, А.А. Осмоловская и О.В. Алиева – организовали в 2024 г. серию встреч с ведущими представителями отрасли. Видео этих встреч и литературу к семинарам можно найти на сайте http://criticaldh.ru/.\nТам мы собрали именно теоретические обсуждения и литературу к ним, а в этом курсе предлагаем приступить к практике DH (на языке R). Оба этих аспекта, в нашем представлении и в программе магистратуры тесно связаны: одного программирования не хватит, чтобы стать “цифровым гуманистом”, а теории недостаточно, чтобы судить об успешности тех или иных цифровых проектов. Поэтому этот курс старается стоять на двух ногах и соединять кодинг с теоретической рефлексией. Это почти невыполнимая задача но когда нам это мешало.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#ресурсы",
    "href": "index.html#ресурсы",
    "title": "Компьютерный анализ текста",
    "section": "Ресурсы",
    "text": "Ресурсы\nИ в теоретическом, и в практическом плане курс опирается на огромную работу, уже проделанную преподавателями магистратуры ЦМГН. Важнейшие наши достижения собрал Б.В. Орехов: https://github.com/nevmenandr/awesome-dh-hse. Здесь вы найдете ссылки на видео, научно-популярные и научные публикации и датасеты.\nЕсли вдруг вам не хватит практических заданий по R, то в качестве дополнения к оффлайн-курсу можно рекомендовать онлайн-курс Георгия Мороза “Введение в анализ данных на R для гуманитарных и социальных наук”. К этому курсу прилагается онлайн-ноутбук (https://agricolamz.github.io/daR4hs/) с комментариями и всем кодом, и он полностью открыт. Надо иметь в виду, однако, что онлайн-курс рассчитан всего на 9 недель, в то время как наш – на два семестра, так что его можно использовать лишь как вспомогательный ресурс, но не замену.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#программа",
    "href": "index.html#программа",
    "title": "Компьютерный анализ текста",
    "section": "Программа",
    "text": "Программа\nКурс 2024/2025 г. включает в себя три основных блока и 22 темы (некоторые темы рассчитаны на 2-3 недели, всего 32 недели). Программа носит предварительный характер и может быть чуть изменена.\nЧасть 1. Основы работы в R\n\nЗнакомство с R и RStudio. Начало работы. Объекты, функции, операторы.\nВизуализация данных: базовый R, lattice, ggplot2.\nТрансформация данных. «Опрятные» данные с dplyr и tidyverse.\nУсловия и циклы. Написание собственных функций. Итерации с purrr.\nИмпорт данных. Импорт данных из XML.\nВоспроизводимые исследования. RMarkdown. Quarto.\nРегулярные выражения: базовый R и stringr.\nHTML. Веб-скрапинг.\n\nЧасть 2. Методы анализа текста\n\nТокенизация. Морфологический и синтаксический анализ.\nАнализ эмоциональной тональности (метод словарей).\nРаспределения слов и анализ частотностей.\nТематическое моделирование (LDA).\nЛатентно-семантический анализ. Векторные модели.\nАнализ текста с помощью сетей (графов). Описание и анализ графов.\nПространство и время: геоданные и временные ряды.\n\nЧасть 3. Машинное обучение и нейросети\n\nОбучение без учителя: иерархическая кластеризация и метод k-средних.\nПростая и множественная линейная регрессия.\nАлгоритмы для бинарной и многоклассовой классификации.\n\nДеревья решений и правил. Бэггинг, случайные леса, бустинг.\nПротоколы проверки моделей. Проблема переобучения.\nКонструирование признаков. Методы снижения размерности.\nМетоды “черного ящика”: опорные векторы и нейросети.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#оценивание",
    "href": "index.html#оценивание",
    "title": "Компьютерный анализ текста",
    "section": "Оценивание",
    "text": "Оценивание\nДомашние задания выполняются в GitHub Classroom. Еженедельно выполняются небольшие задания, которые оцениваются по бинарной шкале (1/0), раз в месяц – консолидирующие задания на весь пройденный материал (оценка 0-10). Все необходимые ссылки вы найдете в чате курса в Telegram.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#благодарности",
    "href": "index.html#благодарности",
    "title": "Компьютерный анализ текста",
    "section": "Благодарности",
    "text": "Благодарности\nЗа помощь в разработке курса и подготовке датасетов к нему автор благодарит Георгия Мороза и Бориса Орехова.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#обратная-связь",
    "href": "index.html#обратная-связь",
    "title": "Компьютерный анализ текста",
    "section": "Обратная связь",
    "text": "Обратная связь\nЕсли вы заметили ошибку или опечатку, можно писать на адрес oalieva@hse.ru.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "start.html",
    "href": "start.html",
    "title": "1  Начало работы",
    "section": "",
    "text": "1.1 Установка R и RStudio\nМы будем использовать R, так что для занятий понадобятся:\nМы будем использовать следующую версию R:\nR version 4.3.3 (2024-02-29)\nНекоторые люди не любят устанавливать лишние программы себе на компьютер, несколько вариантов есть и для них:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#установка-r-и-rstudio",
    "href": "start.html#установка-r-и-rstudio",
    "title": "1  Начало работы",
    "section": "",
    "text": "R\n\nна Windows\nна Mac\nна Linux.\n\nRStudio — IDE для R (можно скачать здесь)\n\n\n\n\n\nRStudio cloud — полная функциональность RStudio с некоторыми ограничениями;\nwebR REPL — ограниченная версия компилятора R, которая работает в вашем браузере и не требует никаких установок на компьютер\nJupyter ноутбуки;\nGoogle Colab (нужно в настройках переключить ядро);\nVS Code — другое IDE, которое также позволяет работать с R;\nв принципе, в IDE нет нужды, можно работать из терминала, после установки, нужно всего лишь набрать R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#знакомство-с-rstudio",
    "href": "start.html#знакомство-с-rstudio",
    "title": "1  Начало работы",
    "section": "1.2 Знакомство с RStudio",
    "text": "1.2 Знакомство с RStudio\nRStudio — основная среда разработки (IDE) для R. После установки R и RStudio можно открыть RStudio и перед вами предстанет что-то похожее на изображение ниже:\n\n\n\nRStudio при первом открытии\n\n\nВсе следующие команды можно:\n\nвводить в окне консоли, и тогда для исполнения следует нажимать клавишу Enter.\nвводить в окне скрипта, и тогда для исполнения следует нажимать клавиши Ctrl/Cmd + Enter или на команду Run на панели окна скрипта. Все, что введено в окне скрипта можно редактировать как в любом текстовом редакторе, в том числе сохранять Ctrl/Cmd + S.\n\nДля начала попробуйте получить информацию о сессии, введя в консоли такую команду:\n\nsessionInfo()\n\nsessionInfo() – это функция. За названием функции всегда следуют круглые скобки, внутри которых могут находиться аргументы функции. О функциях можно думать как о глаголах (“сделай то-то!”). Аргументы – это что-то вроде дополнений и обстоятельств. Аргументы могут быть обязательные и необязательные.\nЧтобы узнать, каких аргументов требует функция, надо вызывать help: ?mean(). Также можно (и нужно) читать техническую документацию к пакетам.\n\n\n\n\n\n\nВопрос\n\n\n\nСколько аргументов функции round() имеют значения по умолчанию?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#пакеты-и-виньетки",
    "href": "start.html#пакеты-и-виньетки",
    "title": "1  Начало работы",
    "section": "1.3 Пакеты и виньетки",
    "text": "1.3 Пакеты и виньетки\nПосле установки R вы получите доступ к уже готовым методам статистического анализа и инструментам для визуализации. Если в базовой инсталляции R нет нужного решения – надо поискать в библиотеке пакетов. Пакет – это набор функций и иногда датасетов, созданный пользователями. На 1 июля 2023 г. в репозитории CRAN доступно 19789 пакетов. И это далеко не все: многие пакеты доступны только на GitHub.\n\n\n\n\n\n\nНа заметку\n\n\n\nНекоторые функции, которые вы найдете в пакетах, частично дублируют друг друга – это нормально, как и в естественном языке, “сказать” что-то можно разными способами.\n\n\nПо технической документации и так называемым “виньеткам” можно понять, какой пакет вам нужен. Например, вот так выглядит виньетка пакета RPerseus, при помощи которого можно получить доступ к корпусу греческой и латинской литературы.\nБывают еще “пакеты пакетов”, то есть очень большие семейства функций, своего рода “диалекты” R. Таково, например, семейство tidyverse, объединяемое идеологией “опрятных” данных. Про него мы еще будем говорить.\nА если нигде нет нужной функции? Ее следует просто написать. Писать код, как и другие тексты, надо аккуратно и понятно. Рекомендуется использовать пояснения при помощи знака # (как в Python).\n\n# случайный набор чисел 1-1000\nx &lt;- sample(1000, 10)\nx\n\n [1] 177  78 436 484  29 132 594 445 116 577\n\n\nВ этом примере код, правда, настолько простой, что не требует особых пояснений. Но в больших проектах от “читабельности” кода зависит не только то, поймет ли вас потенциальный рецензент, но и сможете ли вы сами вспомнить, какая строчка за что отвечает. Также это позволит вернуться к проекту через некоторое время и быстро вспомнить, что там происходит.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#порядок",
    "href": "start.html#порядок",
    "title": "1  Начало работы",
    "section": "1.4 Порядок",
    "text": "1.4 Порядок\nУточнить свою рабочую директорию (в которой R будет искать и сохранять файлы) можно при помощи функции getwd() без аргументов. Установить рабочую директорию можно при помощи функции setwd(), указав в качестве аргумента путь к рабочей директории на вашем компьютере (в кавычках, так как это символьный вектор). В моем случае это выглядит так:\n\nsetwd(\"/Users/olga/R_Workflow/\")\n\nТакже для выбора рабочей директории можно использовать меню R Session &gt; Set Working Directory.\nПакеты для работы устанавливаются один раз, однако подключать их надо во время каждой сессии. Чтобы установить новый пакет, можно воспользоваться меню Tools &gt; Install Packages. Также можно устанавливать пакеты из консоли. Установим пакет с интерактивными уроками программирования на языке R:\n\ninstall.packages(\"swirl\")\n\nДля подключения используем функцию library(), которой передаем в качестве аргумента название пакета без кавычек:\n\nlibrary(swirl)\n\nА теперь – первое задание. После выполнения swirl предложит отправить e-mail преподавателю; ответьте Yes и сделайте скриншот сообщения об отправке. Укажите имя так, чтобы вас можно было узнать. Вот пример:\n\n\nУстановите курс программирования на R: install_course(\"R Programming E\"). После этого привяжите пакет командой library(swirl) и выполните следующую команду: swirl(). Укажите ваше имя. Пройдите урок 2 Workspace and Files.\n\n После выполнения ответьте на несколько вопросов на закрепление материала.\n\n\n\n\n\n\nВопрос\n\n\n\nКакие действия в рабочей директории можно совершать из консоли?\n\n\n\n\nсоздать директорию\n\n\nудалить директорию\n\n\nсоздать файл\n\n\nпереименовать файл\n\n\nкопировать файл\n\n\nудалить файл\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nЧтобы создать вложенную директорию при помощи функции dir.create(), аргументу recursive следует задать значение…\n\n\n\n\nTRUE\nFALSE\n\n\n\n\n\nЕсли все получилось, двигаемся дальше.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#r-как-калькулятор",
    "href": "start.html#r-как-калькулятор",
    "title": "1  Начало работы",
    "section": "1.5 R как калькулятор",
    "text": "1.5 R как калькулятор\nМожно использовать R как калькулятор. Для этого вводим данные рядом с символом приглашения &gt;, который называется prompt.\n\nsqrt(4) # квадратный корень\n\n[1] 2\n\n2^3 # степень\n\n[1] 8\n\nlog10(100) #логарифм\n\n[1] 2\n\n\nЕсли в начале консольной строки стоит +, значит предыдущий код не завершен. Например, вы забыли закрыть скобку функции. Ее можно дописать на следующей строке. Попробуйте набрать sqrt(2 в консоли.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#операторы-присваивания",
    "href": "start.html#операторы-присваивания",
    "title": "1  Начало работы",
    "section": "1.6 Операторы присваивания",
    "text": "1.6 Операторы присваивания\nЧтобы в окружении появился новый объект, надо присвоить результат вычислений какой-нибудь переменной при помощи оператора присваивания &lt;- (Alt + - (Windows) или Option + - (Mac)). Знак = также работает как оператор присваивания, но не во всех контекстах, поэтому им лучше не пользоваться.\n\nx &lt;- 2 + 2 # создаем переменную\ny &lt;- 0.1 # создаем еще одну переменную\nx &lt;- y # переназначаем  \nx + y\n\n[1] 0.2\n\n\nСочетание клавиш для оператора присваивания: Option/Alt + -. Имя переменной, как и имя функции, может содержать прописные и строчные буквы, точку и знак подчеркивания.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#пайпы-конвееры",
    "href": "start.html#пайпы-конвееры",
    "title": "1  Начало работы",
    "section": "1.7 Пайпы (конвееры)",
    "text": "1.7 Пайпы (конвееры)\nВ нашем коде мы часто будем использовать знаки конвеера (или пайпы): |&gt; (в вашей версии он может выглядить иначе: %&gt;%). Они призваны показывать последовательность действий. Сочетание клавиш: Ctrl/Cmd + M.\n\nmean(sqrt(abs(sin(1:100))))\n\n[1] 0.7654264\n\n1:100 |&gt; \n  sin() |&gt; \n  abs() |&gt; \n  sqrt() |&gt; \n  mean()\n\n[1] 0.7654264",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#векторы",
    "href": "start.html#векторы",
    "title": "1  Начало работы",
    "section": "1.8 Векторы",
    "text": "1.8 Векторы\nФункция c() позволяет собрать несколько элементов в единый вектор:\n\nx &lt;- c(3, 5, 7)\nx_mean &lt;- mean(x) \nx_mean\n\n[1] 5\n\n\nОбъекты, предназначенные для хранения данных, – это отдельные переменные, векторы, матрицы и массивы, списки, факторы, таблицы данных. Функции – это поименованные программы, предназначенные для создания новых объектов или выполнения определенных действий над ними.\nКак вы уже знаете из урока в swirl, список всех объектов в окружении возвращает функция ls(). Удалять объекты можно при помощи rm(). Функции можно вкладывать друг в друга:\n\nrm(list = ls()) # удаляет все объекты в окружении\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nСнова запустите swirl(). Укажите ваше имя. Пройдите урок 1 Basic Building Blocks.\n\n\nЕсли все получилось, можно двигаться дальше! Но сначала зафиксируем несколько новых функций из этих первого урока.\n\n\n\n\n\n\nВопрос\n\n\n\nЧто вычисляет функция abs()?\n\n\n\n\nсреднее\n\n\nмодуль\n\n\nквадратный корень\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nСколько значений вернет функция, если разделить c(2, 4, 6) на 2?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nБуква “c” в названии функции c() означает…\n\n\n\n\ncover\n\n\ncollapse\n\n\nconcatenate",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#типы-данных",
    "href": "start.html#типы-данных",
    "title": "1  Начало работы",
    "section": "1.9 Типы данных",
    "text": "1.9 Типы данных\nВ языке R нет скаляров (отдельных чисел). Числа считаются векторами из одного элемента.\n\nx &lt;- 2\nclass(x) # числовой вектор\n\n[1] \"numeric\"\n\nlength(x) # длина вектора\n\n[1] 1\n\n\nОсновные типы данных, с которыми мы будем работать, следующие:\n\nцелое число (integer)\nчисло с плавающей точкой (numeric, также называются double, то есть число двойной точности)\nстрока (character)\nлогическая переменная (logical)\nкатегориальная переменная, или фактор (factor)\n\n\n# проверить тип данных \nx &lt;- sqrt(2)\nclass(x)\n\n[1] \"numeric\"\n\nis.integer(x)\n\n[1] FALSE\n\nis.numeric(x)\n\n[1] TRUE\n\n\nДля начала мы научимся генерировать векторы. Например, так.\n\nseq(1, 5, 0.5)\n\n[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0\n\nrep(\"foo\", 5)\n\n[1] \"foo\" \"foo\" \"foo\" \"foo\" \"foo\"\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 3 Sequences of Numbers.\n\n\nПроверьте свои знания, прежде чем двигаться дальше.\n\n\n\n\n\n\nВопрос\n\n\n\nКакие числа вернет команда pi:10?\n\n\n\n\nнатуральные\n\n\nцелые\n\n\nрациональные\n\n\nвещественные\n\n\nкомплексные\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКакие функции могут использоваться для создания символьных векторов?\n\n\n\n\nseq()\n\n\nrep()\n\n\nc()\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nСколько значений вернет команда rep(c(0, 1, 2), times = 10)? Посчитайте в уме, не выполняя код.\n\n\n\n\n\n\n\n\n Факторы внешне похожи на строки, но в отличие от них хранят информацию об уровнях категориальных переменных. Уровень может обозначаться как числом (например, 1 и 0), так и строкой.\n\nt &lt;- factor(c(\"A\", \"B\", \"C\"), levels = c(\"A\", \"B\", \"C\"))\nt\n\n[1] A B C\nLevels: A B C\n\n\nПри попытке объединить в единый вектор данные разных типов, они будут принудительно приведены к одному типу:\n\nx &lt;- c(TRUE, 1, 3, FALSE)\nx # логические значения переработаны в числовые\n\n[1] 1 1 3 0\n\ny &lt;- c(1, \"a\", 2, \"лукоморье\") # строки всегда в кавычках\ny # числа превратились в строки\n\n[1] \"1\"         \"a\"         \"2\"         \"лукоморье\"\n\n\n\n\n\nТипы векторов в R. Источник\n\n\n Логические векторы можно получить в результате применения логических операторов (== “равно”, != “не равно”, &lt;= “меньше или равно”) к данным других типов:\n\nx &lt;- c(1:10) # числа от 1 до 10\ny &lt;- x &gt; 5\ny # значения TRUE соответствуют единице, поэтому их можно складывать\n\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nsum(y)\n\n[1] 5\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗдесь можно запустить swirl() и пройти урок 8 Logic. Это не обязательно, но очень полезно, если хотите разобраться в операторах! upd: В середине урока возможна ошибка, т.к. в версиях R 4.3.0 и выше было решено отказаться от двойного амперсанда (&&).\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nПопробуйте посчитать в уме: какое из выражений ниже вернет значение TRUE?\n\n\n\n\n7 == 9\n\n\n!(57 != 8)\n\n\n9 &gt;= 10\n\n\n-6 &gt; -7\n\n\n\n\n\nФункции all() и any() также возвращают логические значения:\n\nx &lt;- 10:20 \nany(x == 15)\n\n[1] TRUE\n\nall(x &gt; 9)\n\n[1] TRUE\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 4 Vectors. Это позволит больше узнать про логические и символьные векторы.\n\n\nНесколько вопросов для самопроверки.\n\n\n\n\n\n\nВопрос\n\n\n\nКакие значение вернет команда (3 &gt; 5) & (4 == 4)?\n\n\n\n\nTRUE\nFALSE\nNA\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКакие значения вернет команда (TRUE == TRUE) | (TRUE == FALSE)?\n\n\n\n\nTRUE\nFALSE\nNA\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКоманда paste(LETTERS, 1:4, sep = \"-\") вернет…\n\n\n\n\nчисловой вектор длиной 26\n\n\nсимвольный вектор длиной 26\n\n\nчисловой вектор длиной 4\n\n\nсимвольный вектор длиной 4\n\n\nошибку\n\n\n\n\n\n Над векторами можно совершать арифметические операции, но будьте внимательны, применяя операции к векторам разной длины: в этом случае более короткий вектор будет переработан, то есть повторен до тех пор, пока его длина не сравняется с длиной вектора большей длины.\n\nx &lt;- 2; y &lt;- c(10, 20, 30); z &lt;- c(5, 6, 7)\ny / x \n\n[1]  5 10 15\n\nx + y \n\n[1] 12 22 32\n\ny + z\n\n[1] 15 26 37\n\n\nВекторы можно индексировать, то есть забирать из них какие-то элементы:\n\nx &lt;- seq(1, 5, 0.5)\nx[4:5] # индексы начинаются с 1 (в отличие от Python)\n\n[1] 2.5 3.0\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 6 Subsetting Vectors.\n\n\nПроверьте, все ли вы поняли из этого урока.\n\n\n\n\n\n\nВопрос\n\n\n\nЕсли вектор x содержит числовые значения и некоторое количество NA, то что вернет команда x[is.na(x)]?\n\n\n\n\nвектор длиной 0\n\n\nвектор всех NA\n\n\nлогический вектор\n\n\nвектор без NA\n\n\nошибку\n\n\n\n\n\nЧто надо изменить в этом коде, чтобы получить все, кроме NA?\n\n\n\n\n\n\nВопрос\n\n\n\nДан именованный вектор: vect &lt;- c(foo = 11, bar = 2, norf = NA). Как можно выбрать второй элемент?\n\n\n\n\nvect[bar]\n\n\nvect['2']\n\n\nvect['bar']",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#отсутствующие-значения",
    "href": "start.html#отсутствующие-значения",
    "title": "1  Начало работы",
    "section": "1.10 Отсутствующие значения",
    "text": "1.10 Отсутствующие значения\nNULL означает, что значение не существует. Например, если мы создадим пустой вектор, то при попытке распечатать его получим NULL. А вот длина пустого вектора равна нулю!\n\ny &lt;- c() \ny \n\nNULL\n\nlength(y) \n\n[1] 0\n\n\nNA (not available) указывает на то, что значение существует, но оно неизвестно. Любые операции с NA приводят к появлению новых NA! Сравните:\n\nx &lt;- c(1, NA, 2)\nmean(x)\n\n[1] NA\n\ny &lt;- c(1, NULL, 2)\nmean(y)\n\n[1] 1.5\n\n\nКак проверить, есть ли в данных NA или NULL? Знак ==, который вы встречали в уроке swirl, здесь не подойдет.\n\nx &lt;- NA\nx == NA\n\n[1] NA\n\ny &lt;- NULL\ny == NULL\n\nlogical(0)\n\n\nДля этого есть специальные функции.\n\nis.na(x)\n\n[1] TRUE\n\nis.null(y)\n\n[1] TRUE\n\n\n\nWhen some people first get to R, they spend a lot of time trying to get rid of NAs. People probably did the same sort of thing when zero was invented. NA is a wonderful thing to have available to you. It is seldom pleasant when your data have missing values, but life if much better with NA than without.\nBurns (2012)\n\nКак избавиться от NA? В некоторых случаях достаточно аргумента функции.\n\nmean(c(1, NA, 2), na.rm=T) \n\n[1] 1.5\n\n\nЧуть более сложные способы вы узнаете из урока swirl ниже.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 5 Missing Values.\n\n\nГотово? Тогда попробуйте ответить на вопрос ниже, не выполняя вычислений в R.\n\n\n\n\n\n\nВопрос\n\n\n\nДан вектор x &lt;- c(44, NA, 5, NA). Сколько NA вернет команда x == NA?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#списки",
    "href": "start.html#списки",
    "title": "1  Начало работы",
    "section": "1.11 Списки",
    "text": "1.11 Списки\nСписки, или рекурсивные векторы (в отличие от атомарных векторов), могут хранить данные разных типов.\n\nlist = list(a = c(\"a\", \"b\", \"c\"), b = c(1, 2, 3), c = c(T, F, T))\nlist\n\n$a\n[1] \"a\" \"b\" \"c\"\n\n$b\n[1] 1 2 3\n\n$c\n[1]  TRUE FALSE  TRUE\n\n\nМожно получить доступ как к элементам списка целиком, так и к их содержимому.\n\nlist$a # обращение к поименованным элементам \n\n[1] \"a\" \"b\" \"c\"\n\nlist[2] # одинарные квадратные скобки извлекают элемент списка целиком\n\n$b\n[1] 1 2 3\n\nclass(list[2])\n\n[1] \"list\"\n\nlist[[2]] #  элементы второго элемента \n\n[1] 1 2 3\n\nclass(list[[2]])\n\n[1] \"numeric\"\n\nlist$c[1]# первый элемент второго элемента\n\n[1] TRUE\n\n\nОбратите внимание, что list[2] и list[[2]] возвращают объекты разных классов. Нам это еще понадобится при работе с XML.\n\n\n\nИндексирование списка в R. Источник 🧂\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nУстановите библиотеку rcorpora и загрузите список с названиями хлеба и сладкой выпечки.\nlibrary(rcorpora)\nmy_list &lt;-  corpora(\"foods/breads_and_pastries\")\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nУзнайте длину my_list и введите ее в поле ниже.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nДостаньте из my_list элемент pastries и узнайте его длину.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nА теперь извлеките пятый элемент из pastries и введите ниже его название.\n\n\n\n\n\n\n\n\nСо списками покончено. Теперь можно пойти выпить кофе с my_list$pastries[13].",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#матрицы",
    "href": "start.html#матрицы",
    "title": "1  Начало работы",
    "section": "1.12 Матрицы",
    "text": "1.12 Матрицы\n\nМатрица – это вектор, который имеет два дополнительных атрибута: количество строк и количество столбцов. Из этого следует, что матрица, как и вектор, может хранить данные одного типа. Проверим.\n\nM = matrix(c(1, 2, 3, 4), nrow = 2)\nM # все ок\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nM = matrix(c(1, 2, 3, \"a\"), nrow = 2)\nM # все превратилось в строку! \n\n     [,1] [,2]\n[1,] \"1\"  \"3\" \n[2,] \"2\"  \"a\" \n\n\nВ матрице есть ряды и столбцы. Их количество определяет размер (порядок) матрицы. Выше мы создали матрицу 2 x 2. Элементы матрицы, как и элементы вектора, можно извлекать по индексу. Сначала указывается номер ряда (строки), потом номер столбца.\n\nM = matrix(c(1, 2, 3, 4), nrow = 2)\nM[1, ] # первая строка полностью\n\n[1] 1 3\n\nM[,2] # второй столбец полностью\n\n[1] 3 4\n\nM[1,1] # одно значение\n\n[1] 1\n\n\nОбратите внимание, как меняется размерность при индексировании.\n\nM = matrix(c(1, 2, 3, 4), nrow = 2)\nclass(M)\n\n[1] \"matrix\" \"array\" \n\ndim(M) # функция для извлечения измерений\n\n[1] 2 2\n\nclass(M[1, ]) # первая строка полностью\n\n[1] \"numeric\"\n\ndim(M[1, ]) \n\nNULL\n\n\nПопытка узнать измерения вектора возвращает NULL, потому что с точки зрения R векторы не являются матрицами из одного столбца или одной строки, и потому не имеют измерений. С другой стороны, можно создать матрицу, в которой будет одна строка или один столбцец. При выводе они выглядят не так, как обычные векторы. Хотя казалось бы.\n\n# вектор-строка\nC = matrix(c(1, 2, 3), nrow = 1)\nC\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n\n# вектор-столбец\nD = matrix(c(1, 2, 3), nrow = 3)\nD\n\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n\n\nНад числовыми матрицами в R можно совершать разные операции из линейной алгебры (А. Буховец и П. Москалев 2015); многие из них нам понадобятся, когда мы будем говорить о латентно-семантическом анализе. Ниже несколько полезных функций (но пока их можно пропустить).\n\n# в квадратной матрице есть главная и побочная диагонали\nM = matrix(c(1, 2, 3, 4), nrow = 2) # ее мы распечатывали выше\ndiag(M)\n\n[1] 1 4\n\n# если поставить матрицу на бок, то получится транспонированная матрица\nt(M)\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\n# матрицу можно умножить на скаляр, то есть на обычное число. \nM * 3\n\n     [,1] [,2]\n[1,]    3    9\n[2,]    6   12\n\n# матрицы одного размера можно складывать\nM + M\n\n     [,1] [,2]\n[1,]    2    6\n[2,]    4    8\n\n\nЕсли хотите, можете посмотреть видео. Упражнений на матрицы пока не будет! (Они настигнут вас позже.)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#таблицы",
    "href": "start.html#таблицы",
    "title": "1  Начало работы",
    "section": "1.13 Таблицы",
    "text": "1.13 Таблицы\nТаблицы (кадры данных, data frames) – это двумерные объекты (как и матрицы). Датафреймы отличаются от матриц тем, что их столбцы могут хранить данные разного типа.\n\n\n\n\n\n\nНа заметку\n\n\n\nЕсли списки являются разнородными аналогами векторов в одном измерении, кадры данных являются разнородными аналогами матриц для двумерных данных (Мэтлофф 2019, 134).\n\n\n\n\n# создание датафрейма\ndf &lt;- data.frame(names = c(\"A\", \"B\"), age = c(10, 11))\ndf\n\n\n  \n\n\n# извлечение элементов\ndf$names # забирает весь столбец\n\n[1] \"A\" \"B\"\n\ndf[,\"names\"] # то же самое, другой способ\n\n[1] \"A\" \"B\"\n\ndf[1, ] # забирает ряд\n\n\n  \n\n\n\nПотренируемся на датасете с данными о гапаксах1 в диалогах Платона. Датасет можно скачать по ссылке. Файл имеет расширение .Rdata; щелкнув на него правой кнопкой мыши, можете открыть его сразу в RStudio и потренироваться.\nЭтот датасет позволяет перепроверить выводы Льюиса Кэмпбелла, профессора Сент-Эндрюсского университета в Шотландии. Еще 1867 г., впервые применив количественный метод для датировки диалогов Платона, он пришел к выводу, что для “позднего” стиля Платона, среди прочего, характерно обилие редкой лексики (Campbell 1867, xxxi).\nВ корпус подлинных диалогов Кэмпбелл включал 26 текстов, которые делил на три хронологические группы. Свои вычисления он делал вручную, а мы можем попробовать все пересчитать в R.\n\nhead(hapax_plato)\n\n\n  \n\n\n\nВот так выглядят наши данные. Функция class() позволяет убедиться, что это датафрейм.\n\nclass(hapax_plato)\n\n[1] \"data.frame\"\n\n\nПотренируемся работать с данными в таблицах.\n\n# узнать имена столбцов\ncolnames(hapax_plato) \n\n[1] \"dialogue\" \"words\"    \"hapax\"    \"ratio\"    \"group\"   \n\n\n\n# извлечь ряд(ы) по значению\nhapax_plato[hapax_plato$dialogue == \"Parmenides\", ]\n\n\n  \n\n\n\n\n# узнать тип данных в столбцах\nstr(hapax_plato) \n\n'data.frame':   26 obs. of  5 variables:\n $ dialogue: chr  \"Apology\" \"Charmides\" \"Cratylus\" \"Critias\" ...\n $ words   : chr  \"8745\" \"8311\" \"17944\" \"4950\" ...\n $ hapax   : chr  \"36\" \"31\" \"122\" \"104\" ...\n $ ratio   : chr  \"0.004\" \"0.004\" \"0.007\" \"0.021\" ...\n $ group   : num  1 1 1 3 1 1 1 1 1 1 ...\n\n\n\n# преобразовать тип данных в столбцах\nhapax_plato$group &lt;- as.factor(hapax_plato$group)\nhapax_plato[,2:4] &lt;- sapply(hapax_plato[,2:4],as.numeric) # подробнее о функции `sapply()` в уроке про итерации\n\n\n# отобрать ряды по количеству слов\nhapax_plato[hapax_plato$words &gt; 10000, ]\n\n\n  \n\n\n\nИ еще с датафреймами полезна функция summary():\n\nsummary(hapax_plato)\n\n   dialogue             words            hapax            ratio          group \n Length:26          Min.   :  4024   Min.   : 12.00   Min.   :0.001000   1:16  \n Class :character   1st Qu.:  7154   1st Qu.: 31.25   1st Qu.:0.004000   2: 4  \n Mode  :character   Median : 15590   Median : 94.50   Median :0.007000   3: 6  \n                    Mean   : 19364   Mean   :146.69   Mean   :0.007154         \n                    3rd Qu.: 17907   3rd Qu.:136.75   3rd Qu.:0.008000         \n                    Max.   :103193   Max.   :914.00   Max.   :0.021000         \n\n\nПоследнее упражнение на кодинг в этой главе!\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 7 Matrices and Data Frames.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#практическое-задание",
    "href": "start.html#практическое-задание",
    "title": "1  Начало работы",
    "section": "1.14 Практическое задание",
    "text": "1.14 Практическое задание\nНапоследок небольшое практическое задание. Код для его выполнения сохраните в виде файла с расширением .R. Его надо будет отправить преподавателю.\n\n\n\n\n\n\n\nЗадание\n\n\n\nПРАКТИЧЕСКОЕ ЗАДАНИЕ 1: ИСПАНСКИЕ ПИСАТЕЛИ\n\n\n\n\n# устанавливаем и загружаем нужный пакет\ninstall.packages(\"languageR\")\nlibrary(languageR)\n\n# загружаем датасет\nmeta &lt;- spanishMeta\n\n# допишите ваш код ниже\n# посчитайте средний год публикации романов Камило Хосе Селы\n\n\n# вычислите суммарное число слов в романах Эдуардо Мендосы\n\n\n# извлеките ряды с текстами, опубликованными до 1980 г.\n\nПоздравляем! С этой главой вы справились. Дальше будет сложнее, но интереснее.\n\n\n\n\n\nBurns, Patrick. 2012. The R inferno. Lulu.com.\n\n\nCampbell, Lewis. 1867. The Sophistes and Politicus of Plato with a Revised Text and English Notes. Clarendon Press.\n\n\nА. Буховец и П. Москалев. 2015. Алгоритмы вычислительной статистики в системе R: Учебное пособие. Лань.\n\n\nМэтлофф, Норман. 2019. Искусство программирования на R. Питер.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#footnotes",
    "href": "start.html#footnotes",
    "title": "1  Начало работы",
    "section": "",
    "text": "Гапакс – это слово, которое встречается один раз в корпусе или тексте.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  }
]