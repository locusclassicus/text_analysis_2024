[
  {
    "objectID": "tabular.html",
    "href": "tabular.html",
    "title": "2  Таблицы",
    "section": "",
    "text": "2.1 Матрицы\nМатрица – это вектор, который имеет два дополнительных атрибута: количество строк и количество столбцов. Из этого следует, что матрица, как и вектор, может хранить данные одного типа. Проверим.\nM = matrix(c(1, 2, 3, 4), nrow = 2)\nM # все ок\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nM = matrix(c(1, 2, 3, \"a\"), nrow = 2)\nM # все превратилось в строку! \n\n     [,1] [,2]\n[1,] \"1\"  \"3\" \n[2,] \"2\"  \"a\"\nВ матрице есть ряды и столбцы. Их количество определяет размер (порядок) матрицы. Выше мы создали матрицу 2 x 2. Элементы матрицы, как и элементы вектора, можно извлекать по индексу. Сначала указывается номер ряда (строки), потом номер столбца.\nM = matrix(c(1, 2, 3, 4), nrow = 2)\nM\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\nM[1, ] # первая строка полностью\n\n[1] 1 3\n\nM[,2] # второй столбец полностью\n\n[1] 3 4\n\nM[1,1] # одно значение\n\n[1] 1\nОбратите внимание, как меняется размерность при индексировании.\nM = matrix(c(1, 2, 3, 4), nrow = 2)\ndim(M) # функция для извлечения измерений\n\n[1] 2 2\n\ndim(M[1, ]) \n\nNULL\nПопытка узнать измерения вектора возвращает NULL, потому что, с точки зрения R, векторы не являются матрицами из одного столбца или одной строки и потому не имеют измерений.\nВ этом уроке мы не будем много работать с матрицами, но полезно помнить, что они существуют: матрицы и алгебраические операции с ними задействованы при латентно-семантическом анализе и построении эмбеддингов (см. ниже).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "tabular.html#таблицы-датафреймы",
    "href": "tabular.html#таблицы-датафреймы",
    "title": "2  Таблицы",
    "section": "2.2 Таблицы (датафреймы)",
    "text": "2.2 Таблицы (датафреймы)\nЕсли матрица – это двумерный аналог вектора, то таблица (кадр данных, data frame) – это двумерный аналог списка. Как и список, датафрейм может хранить данные разного типа.\n\n# создание датафрейма\ndf &lt;- data.frame(names = c(\"John\", \"Mary\"), age = c(18, 25), sport = c(\"basketball\", \"tennis\"))\ndf\n\n\n  \n\n\n\nИзвлечение данных тоже напоминает работу со списком.\n\ndf$names # забирает весь столбец\n\n[1] \"John\" \"Mary\"\n\ndf[,\"names\"] # то же самое, другой способ\n\n[1] \"John\" \"Mary\"\n\ndf[1, ] # забирает ряд",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "tabular.html#импорт-табличных-данных",
    "href": "tabular.html#импорт-табличных-данных",
    "title": "2  Таблицы",
    "section": "2.3 Импорт табличных данных",
    "text": "2.3 Импорт табличных данных\nВ этом уроке мы будем работать с датасетом из Репозитория открытых данных по русской литературе и фольклору под названием “Программы по литературе для средней школы с 1919 по 1991 гг.” Этот датасет был использован при подготовке интерактивной карты российского школьного литературного канона (1852-2023). Карта была представлена в 2023 г. Лабораторией проектирования содержания образования ВШЭ. Подробнее о проекте можно посмотреть материал “Системного блока”.\nОсновная функция для скачивания файлов из Сети – download.file(), которой необходимо задать в качестве аргументов url, название сохраняемого файла, иногда также метод.\n\nurl &lt;- \"https://dataverse.pushdom.ru/api/access/datafile/4229\"\n\n# скачивание в папку files в родительской директории\ndownload.file(url, destfile = \"../files/curricula.tsv\") \n\nОсновные функции для чтения табличных данных в базовом R - это read.table() и read.csv(). Файл, который мы скачали, имеет расширение .tsv (tab separated values). Чтобы его прочитать, используем read.table(), указав тип разделителя:\n\ncurricula_df &lt;- read.table(\"../files/curricula.tsv\", sep = \"\\t\", header = TRUE)\n\ncurricula_df\n\n\n  \n\n\n\nФункция read.csv() отличается лишь тем, что автоматически выставляет значения аргументов sep = \",\", header = TRUE.\nФункция class() позволяет убедиться, что перед нами датафрейм.\n\nclass(curricula_df)\n\n[1] \"data.frame\"",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "tabular.html#работа-с-датафреймом",
    "href": "tabular.html#работа-с-датафреймом",
    "title": "2  Таблицы",
    "section": "2.4 Работа с датафреймом",
    "text": "2.4 Работа с датафреймом\n\n# узнать имена столбцов\ncolnames(curricula_df) \n\n[1] \"author\"     \"title\"      \"comment\"    \"curriculum\" \"id\"        \n[6] \"year\"       \"grade\"      \"priority\"  \n\n\n\n# извлечь ряд(ы) по значению\ncurricula_df[curricula_df$year == \"1919\", ]\n\n\n  \n\n\n\n\n# извлечь столбец \ncurricula_df$year |&gt; head()\n\n[1] \"1919\" \"1919\" \"1919\" \"1919\" \"1919\" \"1919\"\n\ncurricula_df[ , \"year\"] |&gt; head()\n\n[1] \"1919\" \"1919\" \"1919\" \"1919\" \"1919\" \"1919\"\n\ncurricula_df[ , 6] |&gt;  head()\n\n[1] \"1919\" \"1919\" \"1919\" \"1919\" \"1919\" \"1919\"\n\n\n\n# узнать тип данных в столбцах\nstr(curricula_df) \n\n'data.frame':   10306 obs. of  8 variables:\n $ author    : chr  \"Андреев Л.Н.\" \"Андреев Л.Н.\" \"Андреев Л.Н.\" \"Бальмонт К.Д.\" ...\n $ title     : chr  \"Жили-были\" \"Иуда\" \"Рассказ о семи повешенных\" \"\" ...\n $ comment   : chr  \"\" \"\" \"\" \"\" ...\n $ curriculum: chr  \"19 ИРЛ 2 ст\" \"19 ИРЛ 2 ст\" \"19 ИРЛ 2 ст\" \"19 ИРЛ 2 ст\" ...\n $ id        : int  1 1 1 1 1 1 1 1 1 1 ...\n $ year      : chr  \"1919\" \"1919\" \"1919\" \"1919\" ...\n $ grade     : int  9 9 9 9 9 8 8 8 8 8 ...\n $ priority  : chr  \"\" \"\" \"*\" \"*\" ...\n\n\n\n# преобразовать тип данных в столбцах\ncurricula_df$year &lt;- as.numeric(curricula_df$year)\n\n\n# вывести сводку\nsummary(curricula_df)\n\n    author             title             comment           curriculum       \n Length:10306       Length:10306       Length:10306       Length:10306      \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n                                                                            \n       id             year          grade          priority        \n Min.   : 1.00   Min.   :1919   Min.   : 5.000   Length:10306      \n 1st Qu.:13.00   1st Qu.:1946   1st Qu.: 8.000   Class :character  \n Median :31.00   Median :1966   Median :10.000   Mode  :character  \n Mean   :28.01   Mean   :1963   Mean   : 9.195                     \n 3rd Qu.:42.00   3rd Qu.:1981   3rd Qu.:10.000                     \n Max.   :50.00   Max.   :1991   Max.   :11.000                     \n                 NA's   :12                                        \n\n\nНебольшое упражнение на кодинг позволит закрепить навыки работы с матрицами и датафреймами.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 7 Matrices and Data Frames.\n\n\nВсе ли вы запомнили?\n\n\n\n\n\n\nВопрос\n\n\n\nДля чего нужна функция cbind()?\n\n\n\n\nдля добавления рядов\n\n\nдля добавления столбцов\n\n\nдля извлечения имен столбцов\n\n\nдля извлечения имен рядов\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nФункция colnames() позволяет как назначать новые имена таблице, так и извлекать существующие.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\nКод для выполнения следующего задания сохраните в виде файла с расширением .R.\n\n\n\n\n\n\nЗадание\n\n\n\nПРАКТИЧЕСКОЕ ЗАДАНИЕ 1: ИСПАНСКИЕ ПИСАТЕЛИ\n\n\n\n# устанавливаем и загружаем нужный пакет\ninstall.packages(\"languageR\")\nlibrary(languageR)\n\n# загружаем датасет\nmeta &lt;- spanishMeta\n\n# допишите ваш код ниже\n# посчитайте средний год публикации романов Камило Хосе Селы\n\n\n# вычислите суммарное число слов в романах Эдуардо Мендосы\n\n\n# извлеките ряды с текстами, опубликованными до 1980 г.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "tabular.html#tibble",
    "href": "tabular.html#tibble",
    "title": "2  Таблицы",
    "section": "2.5 Tibble",
    "text": "2.5 Tibble\nСуществуют два основных “диалекта” R, один из которых опирается главным образом на функции и структуры данных базового R, а другой пользуется синтаксисом tidyverse. Tidyverse – это семейство пакетов (метапакет), разработанных Хадли Уикхемом и др., которое включает в себя в том числе пакеты dplyr, ggplot2 и многие другие.\n\n# загрузить все семейство\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors\n\n\nОсновная структура данных в tidyverse – это tibble, современный вариант датафрейма. Тиббл, как говорят его разработчики, это ленивые и недовольные датафреймы: они делают меньше и жалуются больше. Это позволяет решать проблемы на более ранних этапах, что, как правило, приводит к созданию более чистого и выразительного кода.\nОсновные отличия от обычного датафрейма:\n\nусовершенствованный метод print(), не нужно постоянно вызывать head();\nнет имен рядов;\nдопускает синтаксически “неправильные” имена столбцов;\nпри индексировании не превращается в вектор.\n\nПреобразуем наш датафрейм в тиббл для удобства работы с ним.\n\ncurricula_tbl &lt;- as_tibble(curricula_df)\n\nСравним поведение датафрейма и тиббла.\n\n# индексирование \ncurricula_df[, 1] |&gt; class()\n\n[1] \"character\"\n\ncurricula_tbl[,1]  |&gt; class()\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\nПора тренироваться.\n\n\n\n\n\n\nЗадание\n\n\n\nУстановите курс swirl::install_course(\"Getting and Cleaning Data\"). Загрузите библиотеку library(swirl), запустите swirl(), выберите этот курс и пройдите из него урок 1 Manipulating Data with dplyr. При попытке загрузить урок 1 вы можете получить сообщение об ошибке. В таком случае установите версию курса из github, как указано здесь, или загрузите файл вручную, как указано здесь.\n\n\nВремя вопросов! Обычный датафрейм или тиббл?\n\n\n\n\n\n\nВопрос\n\n\n\nПо умолчанию распечатывает только первые 10 рядов в консоль.\n\n\n\n\nдатафрейм\n\n\nтиббл\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nМолчаливо исправляет некорректные названия столбцов.\n\n\n\n\nдатафрейм\n\n\nтиббл\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nНе имеет названий рядов.\n\n\n\n\nдатафрейм\n\n\nтиббл\n\n\n\n\n\nКстати, обратили внимание, как работает оператор &lt;= с символьным вектором?",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "tabular.html#dplyr",
    "href": "tabular.html#dplyr",
    "title": "2  Таблицы",
    "section": "2.6 Dplyr",
    "text": "2.6 Dplyr\nВ уроке swirl выше вы уже немного познакомились с “грамматикой манипуляции данных”, лежащей в основе dplyr. Здесь об этом будет сказано подробнее. Эта грамматика предоставляет последовательный набор глаголов, которые помогают решать наиболее распространенные задачи манипулирования данными:\n\nmutate() добавляет новые переменные, которые являются функциями существующих переменных;\nselect() выбирает переменные (столбцы) на основе их имен;\nfilter() выбирает наблюдения (ряды) на основе их значений;\nsummarise() обобщает значения;\narrange() изменяет порядок следования строк.\n\nВсе эти глаголы естественным образом сочетаются с функцией group_by(), которая позволяет выполнять любые операции “по группам”, и с оператором pipe |&gt; из пакета magrittr.\nВ итоге получается более лаконичный и читаемый код. Узнаем, за какие года у нас есть программы по литературе.\n\ncurricula_tbl |&gt; \n  count(curriculum, year) \n\n\n  \n\n\n\nОтберем две программы для 8 класса и выясним, какие авторы в них представлены лучше всего.\n\ncurricula_tbl |&gt; \n  filter(year %in% c(1919, 1922), grade == 8) |&gt; \n  count(author, year) |&gt; \n  arrange(-n)\n\n\n  \n\n\n\nТеперь упражнения в swirl. Вам придется редактировать код, который предложит программа, так что сгруппируйтесь.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс Getting and Cleaning Data и пройдите из него урок 2 Grouping and Chaining with dplyr.\n\n\nПравда или ложь?\n\n\n\n\n\n\nВопрос\n\n\n\nФункция n_distinct() возвращает все уникальные значения.\n\n\n\n\nПравда\n\n\nЛожь",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "tabular.html#опрятные-данные",
    "href": "tabular.html#опрятные-данные",
    "title": "2  Таблицы",
    "section": "2.7 Опрятные данные",
    "text": "2.7 Опрятные данные\n\nTidy datasets are all alike, but every messy dataset is messy in its own way.\n— Hadley Wickham\n\nTidyverse – это не только особый синтаксис, но и отдельная идеология “опрятных данных”. “Сырые” данные, с которыми мы работаем, редко бывают опрятны, и перед анализом их следует “почистить” и преобразовать.\nОсновные принципы опрятных данных:\n\nотдельный столбец для каждой переменной;\nотдельный ряд для каждого наблюдения;\nу каждого значения отдельная ячейка;\nодин датасет – одна таблица.\n\n\n\n\nПринципы опрятных данных. Источник.\n\n\n\nПосмотрите на учебные тибблы из пакета tidyr и подумайте, какое из этих правил нарушено в каждом случае.\n\ndata(\"table2\")\ntable2\n\n\n  \n\n\ndata(\"table3\")\ntable3\n\n\n  \n\n\ndata(\"table4a\")\ntable4a\n\n\n  \n\n\ndata(\"table4b\")\ntable4b\n\n\n  \n\n\n\nВажные функции для преобразования данных из пакета tidyr:\n\nseparate() делит один столбец на новые;\nunite() объединяет столбцы;\npivot_longer() удлиняет таблицу;\npivot_wider() расширяет таблицу;\ndrop_na() и replace_na() указывают, что делать с NA и др.\n\nКроме того, в dplyr есть полезное семейство функций _join, позволяющих объединять данные в различных таблицах. Дальше мы потренируемся с ними работать, но сначала пройдем урок swirl. Это достаточно сложный урок (снова понадобится редактировать скрипт), но он нам дальше здорово поможет.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс Getting and Cleaning Data и пройдите из него урок 3 Tidying Data with tidyr.\n\n\nПравда или ложь?\n\n\n\n\n\n\nВопрос\n\n\n\nФункция separate() обязательно требует указать разделитель.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nПринципы опрятных данных требуют, чтобы одному наблюдению соответствовал один столбец.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nФункция contains() используется вместе с filter() для выбора рядов.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n Отличная работа! Прежде чем двигаться дальше, приведите в порядок table2, 3, 4a-4b, используя dplyr и tidyr.\n\n\n\n\n\n\nЗадание\n\n\n\nПрактическое задание “Библиотека Gutenberg”\n\n\n\ndevtools::install_github(\"ropensci/gutenbergr\")\nlibrary(gutenbergr)\nlibrary(dplyr)\nlibrary(tidyr)\n\nworks &lt;- gutenberg_works()\n\n# Отберите ряды, в которых gutenberg_author_id равен 65;\n# после этого выберите два столбца: author, title\nmy_data &lt;- works |&gt; \n  # ваш код здесь\n  \n# Загрузите данные об авторах и выберите столбцы: author, deathdate\nauthors &lt;- gutenberg_authors |&gt; \n  # ваш код здесь\n\n# Соедините my_data с данными о смерти автора из authors, \n# так чтобы к my_data добавился новый столбец. \n# После этого используйте функцию separate, \n# чтобы разделить столбец с именем и фамилией на два новых: author, name. \n# Удалите столбец с именем автора, оставив только фамилию.\n# Добавьте новый столбец century, \n# используя функцию mutate и данные из столбца deathdate. \n# Используйте оператор pipe, не сохраняйте промежуточные результаты!\n\nmy_data |&gt; \n  # ваш код здесь",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Компьютерный анализ текста",
    "section": "",
    "text": "Введение",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#об-этом-курсе",
    "href": "index.html#об-этом-курсе",
    "title": "Компьютерный анализ текста",
    "section": "Об этом курсе",
    "text": "Об этом курсе\nЭтот сайт содержит материалы к курсу “Компьютерный анализ текста в R” для магистерской программы НИУ ВШЭ “Цифровые методы в гуманитарных науках”. Предыдущую версию курса можно найти здесь.\nИ тексты, и инструменты для работы с ними подобраны таким образом, чтобы помочь студентам гуманитарных специальностей (филологам, философам, историкам и др.) как можно быстрее, но с полным пониманием дела перейти к применению количественных методов в собственной работе.\nЧтобы лучше понимать, какие из этих методов более всего востребованы в научной работе, преподаватели магистратуры “Цифровые методы в гуманитарных науках” – Б.В. Орехов, А.А. Осмоловская и О.В. Алиева – организовали в 2024 г. серию встреч с ведущими представителями отрасли. Видео этих встреч и литературу к семинарам можно найти на сайте http://criticaldh.ru/.\nТам мы собрали именно теоретические обсуждения и литературу к ним, а в этом курсе предлагаем приступить к практике DH (на языке R). Оба этих аспекта, в нашем представлении и в программе магистратуры тесно связаны: одного программирования не хватит, чтобы стать “цифровым гуманистом”, а теории недостаточно, чтобы судить об успешности тех или иных цифровых проектов. Поэтому этот курс старается стоять на двух ногах и соединять кодинг с теоретической рефлексией. Это почти невыполнимая задача но когда нам это мешало.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#ресурсы",
    "href": "index.html#ресурсы",
    "title": "Компьютерный анализ текста",
    "section": "Ресурсы",
    "text": "Ресурсы\nИ в теоретическом, и в практическом плане курс опирается на огромную работу, уже проделанную преподавателями магистратуры ЦМГН. Важнейшие наши достижения собрал Б.В. Орехов: https://github.com/nevmenandr/awesome-dh-hse. Здесь вы найдете ссылки на видео, научно-популярные и научные публикации и датасеты.\nЕсли вдруг вам не хватит практических заданий по R, то в качестве дополнения к оффлайн-курсу можно рекомендовать онлайн-курс Георгия Мороза “Введение в анализ данных на R для гуманитарных и социальных наук”. К этому курсу прилагается онлайн-ноутбук (https://agricolamz.github.io/daR4hs/) с комментариями и всем кодом, и он полностью открыт. Надо иметь в виду, однако, что онлайн-курс рассчитан всего на 9 недель, в то время как наш – на два семестра, так что его можно использовать лишь как вспомогательный ресурс, но не замену.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#программа",
    "href": "index.html#программа",
    "title": "Компьютерный анализ текста",
    "section": "Программа",
    "text": "Программа\nКурс 2024/2025 г. включает в себя три основных блока и 22 темы (некоторые темы рассчитаны на 2-3 недели, всего 32 недели). Программа носит предварительный характер и может быть чуть изменена.\nЧасть 1. Основы работы в R\n\nЗнакомство с R и RStudio. Начало работы. Объекты, функции, операторы.\nВизуализация данных: базовый R, lattice, ggplot2.\nТрансформация данных. «Опрятные» данные с dplyr и tidyverse.\nУсловия и циклы. Написание собственных функций. Итерации с purrr.\nИмпорт данных. Импорт данных из XML.\nВоспроизводимые исследования. RMarkdown. Quarto.\nРегулярные выражения: базовый R и stringr.\nHTML. Веб-скрапинг.\n\nЧасть 2. Методы анализа текста\n\nТокенизация. Морфологический и синтаксический анализ.\nАнализ эмоциональной тональности (метод словарей).\nРаспределения слов и анализ частотностей.\nТематическое моделирование (LDA).\nЛатентно-семантический анализ. Векторные модели.\nАнализ текста с помощью сетей (графов). Описание и анализ графов.\nПространство и время: геоданные и временные ряды.\n\nЧасть 3. Машинное обучение и нейросети\n\nОбучение без учителя: иерархическая кластеризация и метод k-средних.\nПростая и множественная линейная регрессия.\nАлгоритмы для бинарной и многоклассовой классификации.\n\nДеревья решений и правил. Бэггинг, случайные леса, бустинг.\nПротоколы проверки моделей. Проблема переобучения.\nКонструирование признаков. Методы снижения размерности.\nМетоды “черного ящика”: опорные векторы и нейросети.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#оценивание",
    "href": "index.html#оценивание",
    "title": "Компьютерный анализ текста",
    "section": "Оценивание",
    "text": "Оценивание\nДомашние задания выполняются в GitHub Classroom. Еженедельно выполняются небольшие задания, которые оцениваются по бинарной шкале (1/0), раз в месяц – консолидирующие задания на весь пройденный материал (оценка 0-10). Все необходимые ссылки вы найдете в чате курса в Telegram.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#благодарности",
    "href": "index.html#благодарности",
    "title": "Компьютерный анализ текста",
    "section": "Благодарности",
    "text": "Благодарности\nЗа помощь в разработке курса и подготовке датасетов к нему автор благодарит Георгия Мороза и Бориса Орехова.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#обратная-связь",
    "href": "index.html#обратная-связь",
    "title": "Компьютерный анализ текста",
    "section": "Обратная связь",
    "text": "Обратная связь\nЕсли вы заметили ошибку или опечатку, можно писать на адрес oalieva@hse.ru.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "start.html",
    "href": "start.html",
    "title": "1  Начало работы",
    "section": "",
    "text": "1.1 Установка R и RStudio\nМы будем использовать R, так что для занятий понадобятся:\nМы будем использовать следующую версию R:\nR version 4.3.3 (2024-02-29)\nНекоторые люди не любят устанавливать лишние программы себе на компьютер, несколько вариантов есть и для них:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#установка-r-и-rstudio",
    "href": "start.html#установка-r-и-rstudio",
    "title": "1  Начало работы",
    "section": "",
    "text": "R\n\nна Windows\nна Mac\nна Linux.\n\nRStudio — IDE для R (можно скачать здесь)\n\n\n\n\n\nRStudio cloud — полная функциональность RStudio с некоторыми ограничениями;\nwebR REPL — ограниченная версия компилятора R, которая работает в вашем браузере и не требует никаких установок на компьютер\nJupyter ноутбуки;\nGoogle Colab (нужно в настройках переключить ядро);\nVS Code — другое IDE, которое также позволяет работать с R;\nв принципе, в IDE нет нужды, можно работать из терминала, после установки, нужно всего лишь набрать R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#знакомство-с-rstudio",
    "href": "start.html#знакомство-с-rstudio",
    "title": "1  Начало работы",
    "section": "1.2 Знакомство с RStudio",
    "text": "1.2 Знакомство с RStudio\nRStudio — основная среда разработки (IDE) для R. После установки R и RStudio можно открыть RStudio и перед вами предстанет что-то похожее на изображение ниже:\n\n\n\nRStudio при первом открытии\n\n\nПосле нажатия на двойное окошко чуть левее надписи Environment откроется окно скрипта.\n\n\n\nПодокна RStudio\n\n\nВсе следующие команды можно:\n\nвводить в окне консоли, и тогда для исполнения следует нажимать клавишу Enter.\nвводить в окне скрипта, и тогда для исполнения следует нажимать клавиши Ctrl/Cmd + Enter или на команду Run на панели окна скрипта. Все, что введено в окне скрипта можно редактировать как в любом текстовом редакторе, в том числе сохранять Ctrl/Cmd + S.\n\nДля начала попробуйте получить информацию о сессии, введя в консоли такую команду:\n\nsessionInfo()\n\nsessionInfo() – это функция. О функциях можно думать как о глаголах (“сделай то-то!”). За названием функции всегда следуют круглые скобки, внутри которых могут находиться аргументы функции. Аргументы – это что-то вроде дополнений и обстоятельств. Аргументы могут быть обязательные и необязательные. Чтобы узнать, каких аргументов требует функция, надо вызывать help: ?mean(). В правой нижней панели появится техническая документация. Но также можно воспользоваться функцией args(). Попробуйте набрать в консоли args(round).\n\n\n\n\n\n\nВопрос\n\n\n\nСколько аргументов функции round() имеют значения по умолчанию?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#пакеты",
    "href": "start.html#пакеты",
    "title": "1  Начало работы",
    "section": "1.3 Пакеты",
    "text": "1.3 Пакеты\nПосле установки R вы получите доступ к уже готовым методам статистического анализа и инструментам для визуализации. Если в базовой инсталляции R нет нужного решения – надо поискать в библиотеке пакетов. Пакет – это набор функций и иногда датасетов, созданный пользователями. На 1 июля 2023 г. в репозитории CRAN доступно 19789 пакетов. И это далеко не все: многие пакеты доступны только на GitHub.\n\n\n\n\n\n\nНа заметку\n\n\n\nНекоторые функции, которые вы найдете в пакетах, частично дублируют друг друга – это нормально, как и в естественном языке, “сказать” что-то можно разными способами.\n\n\nПо технической документации и так называемым “виньеткам” можно понять, какой пакет вам нужен. Например, вот так выглядит виньетка пакета RPerseus, при помощи которого можно получить доступ к корпусу греческой и латинской литературы.\nБывают еще “пакеты пакетов”, то есть очень большие семейства функций, своего рода “диалекты” R. Таково семейство tidyverse, объединяемое идеологией “опрятных” данных. Про него мы еще будем говорить.\nПакеты для работы устанавливаются один раз, однако подключать их надо во время каждой сессии. Чтобы установить новый пакет, можно воспользоваться меню Tools &gt; Install Packages. Также можно устанавливать пакеты из консоли. Установим пакет с интерактивными уроками программирования на языке R:\n\ninstall.packages(\"swirl\")\n\nДля подключения используем функцию library(), которой передаем в качестве аргумента название пакета без кавычек:\n\nlibrary(swirl)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#рабочая-директория",
    "href": "start.html#рабочая-директория",
    "title": "1  Начало работы",
    "section": "1.4 Рабочая директория",
    "text": "1.4 Рабочая директория\nПеред началом работы проверьте свою рабочую директорию при помощи getwd(). Для смены можно использовать как абсолютный, так и относительный путь:\n\nsetwd(\"/Users/name/folder\")\n\n# искать в текущей директории\nsetwd(\"./folder\")\n\n# перейти на уровень вверх\nsetwd(\"../\")\n\nТакже для выбора рабочей директории можно использовать меню R Session &gt; Set Working Directory. А теперь – первое задание.\n\n\n\n\n\n\nЗадание\n\n\n\nУстановите курс программирования на R: install_course(\"R Programming\"). После этого привяжите пакет командой library(swirl) и наберите: swirl(). Укажите ваше имя. Пройдите урок 2 Workspace and Files.\n\n\n После выполнения ответьте на несколько вопросов на закрепление материала.\n\n\n\n\n\n\nВопрос\n\n\n\nКакие действия в рабочей директории можно совершать из консоли?\n\n\n\n\nсоздать директорию\n\n\nудалить директорию\n\n\nсоздать файл\n\n\nпереименовать файл\n\n\nкопировать файл\n\n\nудалить файл\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nЧтобы создать вложенную директорию при помощи функции dir.create(), аргументу recursive следует задать значение…\n\n\n\n\nTRUE\nFALSE\n\n\n\n\n\nЕсли все получилось, двигаемся дальше.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#r-как-калькулятор",
    "href": "start.html#r-как-калькулятор",
    "title": "1  Начало работы",
    "section": "1.5 R как калькулятор",
    "text": "1.5 R как калькулятор\nМожно использовать R как калькулятор. Для этого вводим данные рядом с символом приглашения &gt;, который называется prompt.\n\nsqrt(4) # квадратный корень\n\n[1] 2\n\n2^3 # степень\n\n[1] 8\n\nlog10(100) #логарифм\n\n[1] 2\n\n\nЕсли в начале консольной строки стоит +, значит предыдущий код не завершен. Например, вы забыли закрыть скобку функции. Ее можно дописать на следующей строке. Попробуйте набрать sqrt(2 в консоли.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#операторы-присваивания",
    "href": "start.html#операторы-присваивания",
    "title": "1  Начало работы",
    "section": "1.6 Операторы присваивания",
    "text": "1.6 Операторы присваивания\nЧтобы в окружении появился новый объект, надо присвоить результат вычислений какой-нибудь переменной при помощи оператора присваивания &lt;- (Alt + - (Windows) или Option + - (Mac)). Знак = также работает как оператор присваивания, но не во всех контекстах, поэтому им лучше не пользоваться.\n\nx &lt;- 2 + 2 # создаем переменную\ny &lt;- 0.1 # создаем еще одну переменную\nx &lt;- y # переназначаем  \nx + y\n\n[1] 0.2\n\n\nСочетание клавиш для оператора присваивания: Option/Alt + -. Имя переменной, как и имя функции, может содержать прописные и строчные буквы, точку и знак подчеркивания.\nТеперь небольшое упражнение.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(). Укажите ваше имя. Пройдите урок 1 Basic Building Blocks.\n\n\nЕсли все получилось, можно двигаться дальше! Но сначала зафиксируем несколько новых функций из этих первого урока.\n\n\n\n\n\n\nВопрос\n\n\n\nЧто вычисляет функция abs()?\n\n\n\n\nсреднее\n\n\nмодуль\n\n\nквадратный корень\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nСколько значений вернет функция, если разделить c(2, 4, 6) на 2?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nБуква “c” в названии функции c() означает…\n\n\n\n\ncover\n\n\ncollapse\n\n\nconcatenate",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#пайпы-конвееры",
    "href": "start.html#пайпы-конвееры",
    "title": "1  Начало работы",
    "section": "1.7 Пайпы (конвееры)",
    "text": "1.7 Пайпы (конвееры)\nВ нашем коде мы часто будем использовать знаки конвеера (или пайпы): |&gt; (в вашей версии он может выглядить иначе: %&gt;%; переключить оператор можно в Global Options). Они призваны показывать последовательность действий. Сочетание клавиш: Ctrl/Cmd + M.\n\nmean(sqrt(abs(sin(1:100))))\n\n[1] 0.7654264\n\n1:100 |&gt; \n  sin() |&gt; \n  abs() |&gt; \n  sqrt() |&gt; \n  mean()\n\n[1] 0.7654264",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#векторы",
    "href": "start.html#векторы",
    "title": "1  Начало работы",
    "section": "1.8 Векторы",
    "text": "1.8 Векторы\nВектор – это объект, предназначенный для хранения данных. К таким же объектам относятся также матрицы, списки, таблицы данных и др. Заметим, что в языке R нет скаляров (отдельных чисел). Числа считаются векторами из одного элемента.\n\nx &lt;- 2\nclass(x) # числовой вектор\n\n[1] \"numeric\"\n\nlength(x) # длина вектора\n\n[1] 1\n\n\nКак вы уже поняли, функция c() позволяет собрать несколько элементов в единый вектор:\n\nx &lt;- c(3, 5, 7)\nx_mean &lt;- mean(x) \nx_mean\n\n[1] 5\n\n\n Над векторами можно совершать арифметические операции, но будьте внимательны, применяя операции к векторам разной длины: в этом случае более короткий вектор будет переработан, то есть повторен до тех пор, пока его длина не сравняется с длиной вектора большей длины.\n\nx &lt;- 2\ny &lt;- c(10, 20, 30)\ny / x \n\n[1]  5 10 15\n\nx + y \n\n[1] 12 22 32\n\n\nВекторы можно индексировать, то есть забирать из них какие-то элементы:\n\nx &lt;- seq(1, 5, 0.5)\nx[4:5] # индексы начинаются с 1 (в отличие от Python)\n\n[1] 2.5 3.0\n\n\nВектор может хранить данные разных типов:\n\nцелое число (integer);\nчисло с плавающей точкой (numeric, также называются double, то есть число двойной точности);\nстроку (character);\nлогическую переменную (logical);\nкатегориальную переменную, или фактор (factor).\n\n\n# проверить тип данных \nx &lt;- sqrt(2)\nclass(x)\n\n[1] \"numeric\"\n\nis.integer(x)\n\n[1] FALSE\n\nis.numeric(x)\n\n[1] TRUE\n\n\nСоздавать векторы можно не только при помощи c(). Вот еще два способа.\n\nseq(1, 5, 0.5)\n\n[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0\n\nrep(\"foo\", 5)\n\n[1] \"foo\" \"foo\" \"foo\" \"foo\" \"foo\"\n\n\nНаучиться генерировать векторы поможет небольшое упражнение.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 3 Sequences of Numbers.\n\n\nПроверьте свои знания, прежде чем двигаться дальше.\n\n\n\n\n\n\nВопрос\n\n\n\nКакие числа вернет команда pi:10?\n\n\n\n\nнатуральные\n\n\nцелые\n\n\nрациональные\n\n\nвещественные\n\n\nкомплексные\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКакие функции могут использоваться для создания символьных векторов?\n\n\n\n\nseq()\n\n\nrep()\n\n\nc()\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nСколько значений вернет команда rep(c(0, 1, 2), times = 10)? Посчитайте в уме, не выполняя код.\n\n\n\n\n\n\n\n\n Факторы внешне похожи на строки, но в отличие от них хранят информацию об уровнях категориальных переменных. Уровень может обозначаться как числом (например, 1 и 0), так и строкой.\n\nt &lt;- factor(c(\"A\", \"B\", \"C\"), levels = c(\"A\", \"B\", \"C\"))\nt\n\n[1] A B C\nLevels: A B C\n\n\nВажно: вектор может хранить данные только одного типа. При попытке объединить в единый вектор данные разных типов они будут принудительно приведены к одному типу:\n\nx &lt;- c(TRUE, 1, 3, FALSE)\nx # логические значения приведены к числовым\n\n[1] 1 1 3 0\n\ny &lt;- c(1, \"a\", 2, \"лукоморье\") \ny # числа превратились в строки\n\n[1] \"1\"         \"a\"         \"2\"         \"лукоморье\"\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 4 Vectors. Это позволит больше узнать про логические и символьные векторы.\n\n\nНесколько вопросов для самопроверки.\n\n\n\n\n\n\nВопрос\n\n\n\nКакие значение вернет команда (3 &gt; 5) & (4 == 4)?\n\n\n\n\nTRUE\nFALSE\nNA\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКакие значения вернет команда (TRUE == TRUE) | (TRUE == FALSE)?\n\n\n\n\nTRUE\nFALSE\nNA\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКоманда paste(LETTERS, 1:4, sep = \"-\") вернет…\n\n\n\n\nчисловой вектор длиной 26\n\n\nсимвольный вектор длиной 26\n\n\nчисловой вектор длиной 4\n\n\nсимвольный вектор длиной 4\n\n\nошибку\n\n\n\n\n\n Логические векторы можно получить в результате применения логических операторов (== “равно”, != “не равно”, &lt;= “меньше или равно”) к данным других типов:\n\nx &lt;- c(1:10) # числа от 1 до 10\ny &lt;- x &gt; 5\ny # значения TRUE соответствуют единице, поэтому их можно складывать\n\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nsum(y)\n\n[1] 5\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗдесь можно запустить swirl() и пройти урок 8 Logic. Это не обязательно, но очень полезно, если хотите разобраться в операторах!\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nПопробуйте посчитать в уме: какое из выражений ниже вернет значение TRUE?\n\n\n\n\n7 == 9\n\n\n!(57 != 8)\n\n\n9 &gt;= 10\n\n\n-6 &gt; -7\n\n\n\n\n\nФункции all() и any() также возвращают логические значения:\n\nx &lt;- 10:20 \nany(x == 15)\n\n[1] TRUE\n\nall(x &gt; 9)\n\n[1] TRUE\n\n\nОтсутствие данных любого типа в R передается двумя способами. NULL означает, что значение не существует. Например, если мы создадим пустой вектор, то при попытке распечатать его получим NULL. А вот длина пустого вектора равна нулю!\n\ny &lt;- c() \ny \n\nNULL\n\nlength(y) \n\n[1] 0\n\n\nNA (not available) указывает на то, что значение существует, но оно неизвестно. Любые операции с NA приводят к появлению новых NA! Сравните:\n\nx &lt;- c(1, NA, 2)\nmean(x)\n\n[1] NA\n\ny &lt;- c(1, NULL, 2)\nmean(y)\n\n[1] 1.5\n\n\nКак проверить, есть ли в данных NA или NULL? Знак == здесь не подойдет.\n\nx &lt;- NA\nx == NA\n\n[1] NA\n\ny &lt;- NULL\ny == NULL\n\nlogical(0)\n\n\nДля этого есть специальные функции.\n\nis.na(x)\n\n[1] TRUE\n\nis.null(y)\n\n[1] TRUE\n\n\n\nWhen some people first get to R, they spend a lot of time trying to get rid of NAs. People probably did the same sort of thing when zero was invented. NA is a wonderful thing to have available to you. It is seldom pleasant when your data have missing values, but life if much better with NA than without.\nBurns (2012)\n\nКак избавиться от NA? В некоторых случаях достаточно аргумента функции.\n\nmean(c(1, NA, 2), na.rm=T) \n\n[1] 1.5\n\n\nЧуть более сложные способы вы узнаете из урока swirl ниже.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 5 Missing Values.\n\n\nГотово? Тогда попробуйте ответить на вопрос ниже, не выполняя вычислений в R.\n\n\n\n\n\n\nВопрос\n\n\n\nДан вектор x &lt;- c(44, NA, 5, NA). Сколько NA вернет команда x == NA?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 6 Subsetting Vectors.\n\n\nПроверьте, все ли вы поняли из этого урока.\n\n\n\n\n\n\nВопрос\n\n\n\nЕсли вектор x содержит числовые значения и некоторое количество NA, то что вернет команда x[is.na(x)]?\n\n\n\n\nвектор длиной 0\n\n\nвектор всех NA\n\n\nлогический вектор\n\n\nвектор без NA\n\n\nошибку\n\n\n\n\n\nЧто надо изменить в этом коде, чтобы получить все, кроме NA?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#списки",
    "href": "start.html#списки",
    "title": "1  Начало работы",
    "section": "1.9 Списки",
    "text": "1.9 Списки\nВ отличие от атомарных векторов, списки, или рекурсивные векторы, могут хранить данные разных типов.\n\nlist = list(a = c(\"a\", \"b\", \"c\"), b = c(1, 2, 3), c = c(T, F, T))\nlist\n\n$a\n[1] \"a\" \"b\" \"c\"\n\n$b\n[1] 1 2 3\n\n$c\n[1]  TRUE FALSE  TRUE\n\n\nМожно получить доступ как к элементам списка целиком, так и к их содержимому.\n\nlist$a # обращение к поименованным элементам \n\n[1] \"a\" \"b\" \"c\"\n\nlist[2] # одинарные квадратные скобки извлекают элемент списка целиком\n\n$b\n[1] 1 2 3\n\nclass(list[2])\n\n[1] \"list\"\n\nlist[[2]] #  элементы второго элемента \n\n[1] 1 2 3\n\nclass(list[[2]])\n\n[1] \"numeric\"\n\nlist$c[1]# первый элемент второго элемента\n\n[1] TRUE\n\n\nОбратите внимание, что list[2] и list[[2]] возвращают объекты разных классов. Нам это еще понадобится при работе с XML.\n\n\n\nИндексирование списка в R. Источник 🧂\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nУстановите библиотеку rcorpora и загрузите список с названиями хлеба и сладкой выпечки.\nlibrary(rcorpora)\nmy_list &lt;-  corpora(\"foods/breads_and_pastries\")\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nУзнайте длину my_list и введите ее в поле ниже.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nДостаньте из my_list элемент pastries и узнайте его длину.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nА теперь извлеките пятый элемент из pastries и введите ниже его название.\n\n\n\n\n\n\n\n\nСо списками покончено. Теперь можно пойти выпить кофе с my_list$pastries[13]. Дальше будет сложнее, но интереснее.\n\n\n\n\nBurns, Patrick. 2012. The R inferno. Lulu.com.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "tabular.html#работа-с-датафреймами",
    "href": "tabular.html#работа-с-датафреймами",
    "title": "2  Таблицы",
    "section": "2.4 Работа с датафреймами",
    "text": "2.4 Работа с датафреймами\n\n# узнать имена столбцов\ncolnames(curricula_df) \n\n[1] \"author\"     \"title\"      \"comment\"    \"curriculum\" \"id\"        \n[6] \"year\"       \"grade\"      \"priority\"  \n\n\n\n# извлечь ряд(ы) по значению\ncurricula_df[curricula_df$year == \"1919\", ]\n\n\n  \n\n\n\n\n# извлечь столбец \ncurricula_df$year |&gt; head()\n\n[1] \"1919\" \"1919\" \"1919\" \"1919\" \"1919\" \"1919\"\n\ncurricula_df[ , \"year\"] |&gt; head()\n\n[1] \"1919\" \"1919\" \"1919\" \"1919\" \"1919\" \"1919\"\n\ncurricula_df[ , 6] |&gt;  head()\n\n[1] \"1919\" \"1919\" \"1919\" \"1919\" \"1919\" \"1919\"\n\n\n\n# узнать тип данных в столбцах\nstr(curricula_df) \n\n'data.frame':   10306 obs. of  8 variables:\n $ author    : chr  \"Андреев Л.Н.\" \"Андреев Л.Н.\" \"Андреев Л.Н.\" \"Бальмонт К.Д.\" ...\n $ title     : chr  \"Жили-были\" \"Иуда\" \"Рассказ о семи повешенных\" \"\" ...\n $ comment   : chr  \"\" \"\" \"\" \"\" ...\n $ curriculum: chr  \"19 ИРЛ 2 ст\" \"19 ИРЛ 2 ст\" \"19 ИРЛ 2 ст\" \"19 ИРЛ 2 ст\" ...\n $ id        : int  1 1 1 1 1 1 1 1 1 1 ...\n $ year      : chr  \"1919\" \"1919\" \"1919\" \"1919\" ...\n $ grade     : int  9 9 9 9 9 8 8 8 8 8 ...\n $ priority  : chr  \"\" \"\" \"*\" \"*\" ...\n\n\n\n# преобразовать тип данных в столбцах\ncurricula_df$year &lt;- as.numeric(curricula_df$year)\n\n\n# вывести сводку\nsummary(curricula_df)\n\n    author             title             comment           curriculum       \n Length:10306       Length:10306       Length:10306       Length:10306      \n Class :character   Class :character   Class :character   Class :character  \n Mode  :character   Mode  :character   Mode  :character   Mode  :character  \n                                                                            \n                                                                            \n                                                                            \n                                                                            \n       id             year          grade          priority        \n Min.   : 1.00   Min.   :1919   Min.   : 5.000   Length:10306      \n 1st Qu.:13.00   1st Qu.:1946   1st Qu.: 8.000   Class :character  \n Median :31.00   Median :1966   Median :10.000   Mode  :character  \n Mean   :28.01   Mean   :1963   Mean   : 9.195                     \n 3rd Qu.:42.00   3rd Qu.:1981   3rd Qu.:10.000                     \n Max.   :50.00   Max.   :1991   Max.   :11.000                     \n                 NA's   :12                                        \n\n\nНебольшое упражнение на кодинг позволит закрепить навыки работы с матрицами и датафреймами.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 7 Matrices and Data Frames.\n\n\nВсе ли вы запомнили?\n\n\n\n\n\n\nВопрос\n\n\n\nДля чего нужна функция cbind()?\n\n\n\n\nдля добавления рядов\n\n\nдля добавления столбцов\n\n\nдля извлечения имен столбцов\n\n\nдля извлечения имен рядов\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nФункция colnames() позволяет как назначать новые имена таблице, так и извлекать существующие.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nПрактическое задание “Испанские писатели”.\n\n\n\n# устанавливаем и загружаем нужный пакет\ninstall.packages(\"languageR\")\nlibrary(languageR)\n\n# загружаем датасет\nmeta &lt;- spanishMeta\n\n# допишите ваш код ниже\n# посчитайте средний год публикации романов Камило Хосе Селы\n\n\n# вычислите суммарное число слов в романах Эдуардо Мендосы\n\n\n# извлеките ряды с текстами, опубликованными до 1980 г.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "tabular.html#обобщение-данных",
    "href": "tabular.html#обобщение-данных",
    "title": "2  Таблицы",
    "section": "2.8 Обобщение данных",
    "text": "2.8 Обобщение данных\nТеперь вернемся к датасету curricula и попробуем частично воспроизвести результаты, полученные авторами проекта “Список чтения”, упомянутого выше.\nУ каких авторов больше всего произведений (во всех программах)?\n\ncurricula_tbl |&gt; \n  group_by(author, title) |&gt; \n  summarise(n = n()) |&gt; \n  arrange(-n)\n\n\n  \n\n\n\nКакие произведения упоминаются в программах чаще всего?\n\ncurricula_tbl |&gt; \n  group_by(author, title) |&gt; \n  count() |&gt; \n  arrange(-n)\n\n\n  \n\n\n\nНа принятые в каких годах программы приходится больше всего произведений? (Объяснение здесь.)\n\ncurricula_tbl |&gt; \n  group_by(year) |&gt; \n  distinct(author, title) |&gt; \n  summarise(n = n()) |&gt; \n  arrange(-n)\n\n\n  \n\n\n\nВ заключение попробуйте сформулировать новые вопросы и ответить на них при помощи этого датасета.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Таблицы</span>"
    ]
  },
  {
    "objectID": "plot.html",
    "href": "plot.html",
    "title": "3  Визуализации",
    "section": "",
    "text": "3.1 Графические системы\nВ R есть несколько графических систем: базовый R, lattice и ggplot2. В этом курсе мы будем работать лишь с ggplot2 как с наиболее современной. Если вам интересны первые две, то вы можете обратиться к версии курса 2023/2024 г. и к интерактивным урокам swirl.\nНастоящая графическая сила R – это пакет ggplot2. В его основе лежит идея “грамматики графических элементов” Лиланда Уилкинсона (Мастицкий 2017) (отсюда “gg” в названии). С одной стороны, вы можете постепенно достраивать график, добавляя элемент за элементом (как в базовом R); с другой – множество параметров подбираются автоматически, как в Lattice.\nО различных видах графиков можно почитать по ссылке. В этом уроке мы научимся строить диаграмму рассеяния (scatter plot), столбиковую диаграмму (bar chart) и линейную диаграмму (line chart).\nВот к чему мы стремимся.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#графические-системы",
    "href": "plot.html#графические-системы",
    "title": "3  Визуализации",
    "section": "",
    "text": "Задание\n\n\n\nЗапустите swirl(); курс R Programming у вас уже установлен. Из него сделайте урок 15 Base Graphics. Также установите курс swirl::install_course(\"Exploratory Data Analysis\"). Из него можно пройти любые уроки: это необязательно, но поможет разобраться в теме.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#датасет-метаданные-романов-xix-xx-вв.",
    "href": "plot.html#датасет-метаданные-романов-xix-xx-вв.",
    "title": "3  Визуализации",
    "section": "3.2 Датасет: метаданные романов XIX-XX вв.",
    "text": "3.2 Датасет: метаданные романов XIX-XX вв.\nЗнакомиться с ggplot2 мы будем на примере датасета из коллекции “NovelTM Datasets for English-Language Fiction, 1700-2009”, подготовленного Тедом Андервудом, Патриком Кимутисом и Джессикой Уайт. Они собрали метаданные о 210,266 томах художественной прозы в HathiTrust Digital Library и составили из них несколько датасетов.\nМы возьмем небольшой датасет, который содержит провернные вручную метаданные, а также сведения о категории художественной прозы для 2,730 произведений, созданных в период 1799-2009 г. (равные выборки для каждого года). Об особенностях сбора и подготовки данных можно прочитать по ссылке. Нужный нам файл (в формате tsv) скопирован в репозиторий курса.\n\nurl &lt;- \"https://github.com/locusclassicus/text_analysis_2024/raw/main/files/manual_title_subset.tsv\"\ndownload.file(url, destfile = \"../files/manual_title_subset.tsv\")\n\nПрежде всего избавимся от лишних столбцов и посмотрим на данные.\n\nlibrary(tidyverse)\nnoveltm &lt;- read_tsv(\"../files/manual_title_subset.tsv\")\n\nnoveltm &lt;- noveltm |&gt; \n  select(author, inferreddate, latestcomp, gender, nationality, shorttitle, category)\n\nnoveltm\n\n\n  \n\n\n\nМы попробуем проверить наблюдение, сделанное Франко Моретти в статье “Корпорация стиля: размышления о 7 тысячах заглавий (британские романы 1740-1850)” (2009 г., рус. перевод в книге “Дальнее чтение”, 2016 г.). Моретти заметил, что на протяжении XVIII-XIX вв. названия становятся короче, причем уменьшается не только среднее, но и стандартное отклонение (т.е. разброс значений). В публикации он предлагает несколько возможных объяснений для этого тренда. В датасете NovelTM есть не только романы (и не только британские), но тем более интересно будет сравнить результат.\nВ наших данных сведения о публикации хранятся в столбце inferreddate, а названия – в столбце shorttitle. Количество слов в названии придется посчитать: для этого можно посчитать количество пробелов и добавить единицу.\n\nnoveltm &lt;- noveltm |&gt; \n  mutate(n_words = str_count(shorttitle, \" \"))\n\nnoveltm",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#слой-за-слоем",
    "href": "plot.html#слой-за-слоем",
    "title": "3  Визуализации",
    "section": "3.3 Слой за слоем",
    "text": "3.3 Слой за слоем\nФункция ggplot() имеет два основных аргумента: data и mapping. Аргумент mapping задает эстетические атрибуты геометрических объектов. Обычно используется в виде mapping = aes(x, y), где aes() означает aesthetics.\nПод “эстетикой” подразумеваются графические атрибуты, такие как размер, форма или цвет. Вы не увидите их на графике, пока не добавите какие-нибудь “геомы” – геометрические объекты (точки, линии, столбики и т.п.). Эти объекты могут слоями накладываться друг на друга (Wickham и Grolemund 2016). Попробуем.\n\nnoveltm |&gt; \n  ggplot(aes(inferreddate, n_words)) + \n  geom_point()\n\n\n\n\n\n\n\n\nУпс. Точек очень много, и они накладываются друг на друга, т.к. число слов – дискретная величина. Поступим так же, как Моретти, который отразил на графике среднее для каждого года. Для этого нам надо снова поколдовать над данными.\n\nnoveltm_summary &lt;- noveltm |&gt;\n  group_by(inferreddate) |&gt;\n  summarise(n = n(),\n            mean_w = mean(n_words, na.rm = TRUE)) |&gt; \n  filter(n &gt; 1)\n\nnoveltm_summary\n\n\n  \n\n\n\nСнова попробуем изобразить. Добавим линию тренда, изменим внешний вид точек и тему оформления, а также уберем подпись оси X.\n\nnoveltm_summary |&gt; \n  ggplot(aes(inferreddate, mean_w)) +\n  geom_point(color = \"steelblue\", alpha = 0.7, size = 2) +\n  geom_smooth(color = \"tomato\") + \n  theme_bw() +\n  xlab(NULL)\n\n\n\n\n\n\n\n\nХорошо прослеживается нисходящая тенденция.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#кодирование-категориальных-переменных",
    "href": "plot.html#кодирование-категориальных-переменных",
    "title": "3  Визуализации",
    "section": "3.4 Кодирование категориальных переменных",
    "text": "3.4 Кодирование категориальных переменных\nВ столбце nationality хранятся данные о происхождении писателя.\n\nnoveltm |&gt; \n  group_by(nationality) |&gt; \n  summarise(n = n()) |&gt; \n  arrange(-n)\n\n\n  \n\n\n\nОтберем только английских и американских авторов и сравним тенденции в этих двух группах.\n\nnoveltm_sel &lt;- noveltm |&gt; \n  filter(nationality %in% c(\"uk\", \"us\")) |&gt; \n  group_by(nationality, inferreddate) |&gt; \n  summarise(n = n(),\n            mean_w = mean(n_words, na.rm = TRUE)) |&gt; \n  filter(n &gt; 1) |&gt; \n  select(-n)\n\nnoveltm_sel\n\n\n  \n\n\n\nТеперь сравним две группы графически, а также добавим заголовок и подзаголовок.\n\nnoveltm_sel |&gt; \n  ggplot(aes(inferreddate, mean_w, color = nationality)) +\n  geom_point(alpha = 0.7, size = 1.5) +\n  geom_smooth() +\n  theme_bw() +\n  labs(\n    title = \"Title Length in UK and US\",\n    subtitle = \"NovelTM Data 1800-2009\",\n    x = NULL\n  )\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#оформление",
    "href": "plot.html#оформление",
    "title": "3  Визуализации",
    "section": "3.5 Оформление",
    "text": "3.5 Оформление\nGgplot2 дает возможность легко поменять цветовую палитру и шрифтовое оформление, а также добавить фон.\nШкалы ColorBrewer scale_color_brewer() и scale_fill_brewer() позволяют использовать специально подобранные палитры хорошо сочетаемых цветов. Посмотреть эти шкалы можно на сайте https://colorbrewer2.org.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс “Exploratory Data Analysis” и пройдите из него урок 7 Working with Colors. Это необязательно, но поможет лучше понять, как устроена работа с цветом в R.\n\n\nОбщее правило для выбора таково.\n\nЕсли дана качественная переменная с упорядоченными уровнями (например, “холодный”, “теплый”, “горячий”) или количественная переменная, и необходимо подчеркнуть разницу между высокими и низкими значениями, то для визуализации подойдет последовательная шкала.\nЕсли дана количественная переменная с осмысленным средним значением, например нулем, 50%, медианой, целевым показателем и т.п., то выбираем расходящуюся шкалу.\nЕсли дана качественная переменная, уровни которой невозможно упорядочить (названия городов, имена авторов и т.п.), ищем качественную шкалу.\n\n.\nУ нас две качественные группы, поэтому выбираем качественную шкалу. На рисунке они посредине (в R есть и другие шкалы, но пока о них не будет). Цвета можно задавать и вручную по названию или коду.\n\n\nnoveltm_sel |&gt; \n  ggplot(aes(inferreddate, mean_w, color = nationality)) +\n  geom_point(alpha = 0.7, size = 1.5) +\n  geom_smooth(se = FALSE) +\n  theme_bw() +\n  labs(\n    title = \"Title Length in UK and US\",\n    subtitle = \"NovelTM Data 1800-2009\",\n    x = NULL) +\n  scale_color_brewer(palette = \"Dark2\")\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nДобавим шрифтов.\n\nlibrary(showtext)\nfont_add_google(\"Special Elite\", family = \"special\")\nshowtext_auto()\n\nnoveltm_sel |&gt; \n  ggplot(aes(inferreddate, mean_w, color = nationality)) +\n  geom_point(alpha = 0.7, size = 1.5) +\n  geom_smooth(se = FALSE) +\n  theme_bw() +\n  labs(\n    title = \"Title Length in UK and US\",\n    subtitle = \"NovelTM Data 1800-2009\",\n    x = NULL) +\n  scale_color_brewer(palette = \"Dark2\") + \n  theme(\n    axis.title = element_text(family = \"special\"),\n    title = element_text(family = \"special\")\n  )\n\n\n\n\n\n\n\n\nФинальный штрих.\n\nlibrary(ggimage)\nurl &lt;- \"https://img.freepik.com/premium-photo/stack-old-books-white-background_427771-2463.jpg?w=1800\"\n\nfont_add_google(\"Special Elite\", family = \"special\")\nshowtext_auto()\n\n\ng &lt;- noveltm_sel |&gt; \n  ggplot(aes(inferreddate, mean_w, color = nationality)) +\n  geom_point(alpha = 0.5, size = 1.5) +\n  geom_smooth(se = FALSE) +\n  theme_bw() +\n  labs(\n    title = \"Title Length in UK and US\",\n    subtitle = \"NovelTM Data 1800-2009\",\n    x = NULL) +\n  scale_color_brewer(\"country\", palette = \"Dark2\") + \n  theme(\n    axis.title = element_text(family = \"special\", color = \"sienna\"),\n    title = element_text(family = \"special\", color = \"sienna\"),\n    axis.text = element_text(color = \"sienna\"),\n    axis.ticks = element_blank(),\n    plot.margin = unit(c(0.4, 2, 0.4, 0.4), \"inches\"), # t, r, b, l\n    panel.border = element_rect(color = \"sienna\"),\n    legend.position = c(0.8, 0.8),\n    #legend.box.background =  element_rect(color = \"sienna\")\n  )\n\nggbackground(g, url)\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс “Exploratory Data Analysis” и пройдите из него урок 9 GGPlot2 Part2.\n\n\nПравда или ложь?\n\n\n\n\n\n\nВопрос\n\n\n\nНа одной диаграмме может быть несколько геомов.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nВсе эстетические атрибуты для всех геомов задаются при вызове ggplot().\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nОтметьте все термины “грамматики графических элементов” ggplot2.\n\n\n\n\nданные\n\n\nгеометрические объекты\n\n\nстатистические преобразования\n\n\nшкалы\n\n\nсистемы координат\n\n\nфасеты",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#категоризованный-график",
    "href": "plot.html#категоризованный-график",
    "title": "3  Визуализации",
    "section": "3.8 Категоризованный график",
    "text": "3.8 Категоризованный график\nРазличные группы данных можно выделять не только цветом и формой, но и помещать каждую в свое окошко (facet).\nПока не расслабляемся, впереди еще один урок swirl.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс “Exploratory Data Analysis” и пройдите из него урок 10 GGPlot2 Extras.\n\n\nПравда или ложь?\n\n\n\n\n\n\nВопрос\n\n\n\nЧтобы построить диаграмму рассеяния, нужно добавить к графическому объекту, созданному функцией ggplot, геометрический объект под названием geom_scatterplot.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nФункция cut() позволяет преобразовать числовой вектор в фактор.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nПолуинтервал (0.2,0.5] включает 0.2 и не включает 0.5.\n\n\n\n\nПравда\nЛожь",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#экспорт-графиков-из-среды-r",
    "href": "plot.html#экспорт-графиков-из-среды-r",
    "title": "3  Визуализации",
    "section": "3.10 Экспорт графиков из среды R",
    "text": "3.10 Экспорт графиков из среды R\nСпособы:\n\nреализованные в R драйверы стандартных графических устройств;\nфункция ggsave()\nменю программы RStudio.\n\n\n# код сохранит pdf в рабочую директорию \npdf(file = \"plot.pdf\")\n \ng \n\ndev.off()\n\nЕще один способ сохранить последний график из пакета ggplot2.\n\nggsave(\n  filename = \"plot.png\",\n  plot = last_plot(),\n  device = \"png\",\n  scale = 1,\n  width = NA,\n  height = 500,\n  units = \"px\",\n  dpi = 300\n)\n\n\n\n\n\n\n\nЗадание\n\n\n\nПРАКТИЧЕСКОЕ ЗАДАНИЕ 2: СТАРОФРАНЦУЗСКАЯ ЛИТЕРАТУРА\n\n\n\n\n# загружаем нужные пакеты\nlibrary(languageR)\nlibrary(ggplot2)\n\n# загружаем датасет\nmeta &lt;- oldFrenchMeta\n\n# допишите ваш код ниже\n# постройте столбиковую диаграмму, \n# показывающую распределение произведений по темам; цветом закодируйте жанр; \n# уберите названия осей; \n# поверните координатную ось; \n# поменяйте тему оформления на черно-белую, \n# а шрифт -- на Palatino; \n# добавьте заголовок \"Plot by [Your Name]\"\n\n\n\n#  экспортируйте график в формате jpg \n# с раширением 300 dpi; \n# в названии файла должна быть \n# ваша фамилия и номер группы\n\n\n\n\n\nUnderwood, Ted. 2019. Distant Horizons: Digital Evidence and Literary Change. University of Chicago Press.\n\n\nWickham, Hadley, и Garrett Grolemund. 2016. R for Data Science. O’Reilly. https://r4ds.had.co.nz/index.html.\n\n\nМастицкий, Сергей. 2017. Визуализация данных с помощью ggplot2. ДМК.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#цветовые-шкалы",
    "href": "plot.html#цветовые-шкалы",
    "title": "3  Визуализации",
    "section": "3.5 Цветовые шкалы",
    "text": "3.5 Цветовые шкалы\nGgplot2 дает возможность легко поменять цветовую палитру и шрифтовое оформление, а также добавить фон.\nФункции scale_color_brewer() и scale_fill_brewer() позволяют использовать специально подобранные палитры хорошо сочетаемых цветов. Посмотреть эти палитры можно на сайте https://colorbrewer2.org.\nОбщее правило для выбора таково.\n\nЕсли дана качественная переменная с упорядоченными уровнями (например, “холодный”, “теплый”, “горячий”) или количественная переменная, и необходимо подчеркнуть разницу между высокими и низкими значениями, то для визуализации подойдет последовательная шкала.\nЕсли дана количественная переменная с осмысленным средним значением, например нулем, 50%, медианой, целевым показателем и т.п., то выбираем расходящуюся шкалу.\nЕсли дана качественная переменная, уровни которой невозможно упорядочить (названия городов, имена авторов и т.п.), ищем качественную шкалу.\n\n\n\n\nИсточник.\n\n\nВот основные (но не единственные!) цветовые шкалы в R. Также цвета можно задавать и вручную – по названию или коду.\n\n\nnoveltm_nation |&gt; \n  ggplot(aes(inferreddate, mean_w, color = nationality)) +\n  geom_point(alpha = 0.7, size = 1.5) +\n  geom_smooth(se = FALSE) +\n  theme_bw() +\n  labs(\n    title = \"Title Length in UK and US\",\n    subtitle = \"NovelTM Data 1800-2009\",\n    x = NULL) +\n  scale_color_brewer(palette = \"Dark2\")\n\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#шрифты",
    "href": "plot.html#шрифты",
    "title": "3  Визуализации",
    "section": "3.6 Шрифты",
    "text": "3.6 Шрифты\nПакет ggplot2 и расширения для него дают возможность использовать пользовательские шрифты.\n\nlibrary(showtext)\nfont_add_google(\"Special Elite\", family = \"special\")\nshowtext_auto()\n\nnoveltm_nation |&gt; \n  ggplot(aes(inferreddate, mean_w, color = nationality)) +\n  geom_point(alpha = 0.7, size = 1.5) +\n  geom_smooth(se = FALSE) +\n  theme_bw() +\n  labs(\n    title = \"Title Length in UK and US\",\n    subtitle = \"NovelTM Data 1800-2009\",\n    x = NULL) +\n  scale_color_brewer(palette = \"Dark2\") + \n  theme(\n    axis.title = element_text(family = \"special\"),\n    title = element_text(family = \"special\")\n  )",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#изображения",
    "href": "plot.html#изображения",
    "title": "3  Визуализации",
    "section": "3.7 Изображения",
    "text": "3.7 Изображения\nИзображения можно добавлять и в качестве фона, и вместо отдельных геомов, например точек. Поправим цвета, чтобы они лучше сочетались с цветом изображения.\n\nlibrary(ggimage)\nurl &lt;- \"./images/book.jpg\"\n\nfont_add_google(\"Special Elite\", family = \"special\")\nshowtext_auto()\n\n\ng &lt;- noveltm_nation |&gt; \n  ggplot(aes(inferreddate, mean_w, color = nationality)) +\n  geom_point(alpha = 0.7, size = 1.5) +\n  geom_smooth(se = FALSE) +\n  theme_bw() +\n  labs(\n    title = \"Title Length in UK and US\",\n    subtitle = \"NovelTM Data 1800-2009 \\n \",\n    x = NULL,\n    y = NULL) +\n  scale_color_manual(\"country\", values = c(\"#A03B37\", \"#50684E\")) + \n  theme(\n    axis.title = element_text(family = \"special\", color = \"#8B807C\"),\n    title = element_text(family = \"special\", color = \"#52211E\"),\n    axis.text = element_text(color = \"#52211E\"),\n    axis.ticks = element_blank(),\n    plot.margin = unit(c(0.4, 3, 0.4, 0.4), \"inches\"), # t, r, b, l\n    panel.border = element_rect(color = \"#8B807C\"),\n    legend.position = c(0.8, 0.8)\n  )\n\nggbackground(g, url)",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#зависимости",
    "href": "plot.html#зависимости",
    "title": "3  Визуализации",
    "section": "3.3 Зависимости",
    "text": "3.3 Зависимости\nФункция ggplot() имеет два основных аргумента: data и mapping. Аргумент mapping задает эстетические атрибуты геометрических объектов. Обычно используется в виде mapping = aes(x, y), где aes() означает aesthetics.\nПод “эстетикой” подразумеваются графические атрибуты, такие как размер, форма или цвет. Вы не увидите их на графике, пока не добавите какие-нибудь “геомы” – геометрические объекты (точки, линии, столбики и т.п.). Эти объекты могут слоями накладываться друг на друга (Wickham и Grolemund 2016). Диаграмма рассеяния создается при помощи geom_point(). Попробуем настройки по умолчанию.\n\nnoveltm |&gt; \n  ggplot(aes(inferreddate, n_words)) + \n  geom_point()\n\n\n\n\n\n\n\n\nУпс. Точек очень много, и они накладываются друг на друга, т.к. число слов – дискретная величина. Поступим так же, как Моретти, который отразил на графике среднее для каждого года. Для этого нам надо снова поколдовать над данными.\n\nnoveltm_summary &lt;- noveltm |&gt;\n  group_by(inferreddate) |&gt;\n  summarise(n = n(),\n            mean_w = mean(n_words, na.rm = TRUE)) |&gt; \n  filter(n &gt; 1)\n\nnoveltm_summary\n\n\n  \n\n\n\nСнова попробуем изобразить. Добавим линию тренда, изменим внешний вид точек и тему оформления, а также уберем подпись оси X.\n\nnoveltm_summary |&gt; \n  ggplot(aes(inferreddate, mean_w)) +\n  geom_point(color = \"steelblue\", alpha = 0.7, size = 2) +\n  geom_smooth(color = \"tomato\") + \n  theme_bw() +\n  xlab(NULL)\n\n\n\n\n\n\n\n\nХорошо прослеживается нисходящая тенденция, о которой писал Моретти.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс “Exploratory Data Analysis” и пройдите из него урок 9 GGPlot2 Part2.\n\n\nПравда или ложь?\n\n\n\n\n\n\nВопрос\n\n\n\nНа одной диаграмме может быть несколько геомов.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nВсе эстетические атрибуты для всех геомов задаются при вызове ggplot().\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nОтметьте все термины “грамматики графических элементов” ggplot2.\n\n\n\n\nданные\n\n\nгеометрические объекты\n\n\nстатистические преобразования\n\n\nшкалы\n\n\nсистемы координат\n\n\nфасеты",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#сравнение-двух-групп",
    "href": "plot.html#сравнение-двух-групп",
    "title": "3  Визуализации",
    "section": "3.4 Сравнение двух групп",
    "text": "3.4 Сравнение двух групп\nВ столбце nationality хранятся данные о происхождении писателя.\n\nnoveltm |&gt; \n  group_by(nationality) |&gt; \n  summarise(n = n()) |&gt; \n  arrange(-n)\n\n\n  \n\n\n\nОтберем только английских и американских авторов и сравним тенденции в этих двух группах.\n\nnoveltm_nation &lt;- noveltm |&gt; \n  filter(nationality %in% c(\"uk\", \"us\")) |&gt; \n  group_by(nationality, inferreddate) |&gt; \n  summarise(n = n(),\n            mean_w = mean(n_words, na.rm = TRUE)) |&gt; \n  filter(n &gt; 1) |&gt; \n  select(-n) |&gt; \n  arrange(-mean_w)\n\nnoveltm_nation\n\n\n  \n\n\n\nКатегориальную переменную (национальность) в нашем случае проще всего закодировать цветом. Также добавим заголовок и подзаголовок.\n\nnoveltm_nation |&gt; \n  ggplot(aes(inferreddate, mean_w, color = nationality)) +\n  geom_point(alpha = 0.7, size = 1.5) +\n  geom_smooth() +\n  theme_bw() +\n  labs(\n    title = \"Title Length in UK and US\",\n    subtitle = \"NovelTM Data 1800-2009\",\n    x = NULL\n  )\n\n\n\n\n\n\n\n\nДля разведывательного анализа данных вполне достаточно настроек по умолчанию, но для публикации вы, вероятно, захотите вручную поправить шрифтовое и цветовое оформление.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#распределения",
    "href": "plot.html#распределения",
    "title": "3  Визуализации",
    "section": "3.8 Распределения",
    "text": "3.8 Распределения\nДля визуализации распределений качественных переменных подходит стобиковая диаграмма, которая наглядно показывает число наблюдений в каждой группе.\nВ датасете NovelTM представлены следующие категории литературы.\n\nnoveltm |&gt; \n  ggplot(aes(category, fill = category)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nНас будет интересовать категория longfiction, т.к. именно сюда попадает популярный в XIX в. жанр романа. Известно, что примерно до 1840 г. почти половина романистов были женщинами, но к началу XX в. их доля снизилась (Underwood 2019, 133). Отчасти это объясняется тем, что после середины XIX в. профессия писателя становится более престижной, а его социальный статус повышается, что приводит к “джентрификации” романа. Посмотрим, что на этот счет могут сказать данные NovelTM. Переменная gender хранит данные о гендере автора.\n\nnoveltm |&gt; \n  ggplot(aes(gender, fill = gender)) + \n  geom_bar()\n\n\n\n\n\n\n\n\nОтберем лишь одну категорию и два гендера.\n\nnoveltm_lf &lt;- noveltm |&gt; \n  select(inferreddate, gender, category) |&gt; \n  filter(gender != \"u\", category == \"longfiction\") |&gt; \n  select(-category)\n\nnoveltm_lf\n\n\n  \n\n\n\nМожно предположить, что соотношение мужчин и женщин в разные десятилетия менялось. Чтобы это выяснить, нам надо преобразовать данные, указав для каждого года соответствующую декаду, и посчитать число мужчин и женщин в каждой декаде.\n\nnoveltm_decade &lt;- noveltm_lf |&gt; \n  mutate(decade = (inferreddate %/% 10) * 10) \n\nnoveltm_decade\n\n\n  \n\n\n\nЭтого уже достаточно для визуализации, но она будет не очень наглядная.\n\nnoveltm_decade |&gt; \n  ggplot(aes(decade, fill = gender)) +\n  geom_bar(position = \"dodge\")\n\n\n\n\n\n\n\n\nУзнаем, сколько всего наблюдений в каждом десятилетии. В 1790-х всего одно наблюдение, его удаляем.\n\ntotal &lt;- noveltm_decade |&gt; \n  group_by(decade) |&gt; \n  summarise(total = n()) |&gt; \n  filter(total &gt; 1)\n\ntotal\n\n\n  \n\n\n\n\nsummary &lt;- noveltm_decade |&gt; \n  group_by(decade, gender) |&gt; \n  summarise(counts = n()) |&gt; \n  filter(counts &gt; 1)\n\n`summarise()` has grouped output by 'decade'. You can override using the\n`.groups` argument.\n\nsummary\n\n\n  \n\n\n\nТеперь объединим две таблицы и посчитаем долю мужчин и женщин.\n\nnoveltm_share &lt;- summary |&gt; \n  left_join(total) |&gt; \n  mutate(share = counts / total) |&gt; \n  select(-counts, -total)\n\nJoining with `by = join_by(decade)`\n\nnoveltm_share\n\n\n  \n\n\n\nМожно визуализировать.\n\nnoveltm_share |&gt; \n  filter(gender == \"f\") |&gt; \n  ggplot(aes(decade, share, color = gender)) +\n  geom_line(show.legend = FALSE)\n\n\n\n\n\n\n\n\nГрафик, кажется, подтверждает, что доля женщин в литературе снижалась примерно до середины XX в. Однако при разделении данных на группы можно заметить другую тенденцию.\n\nnoveltm_nation &lt;- noveltm |&gt; \n  filter(category == \"longfiction\") |&gt; \n  select(inferreddate, gender, nationality) |&gt; \n  mutate(nationality = case_when(!nationality %in% c(\"uk\", \"us\") ~ \"other\",\n                                 .default = nationality)) |&gt; \n  filter(gender != \"u\") |&gt; \n  mutate(decade = (inferreddate %/% 10) * 10) \n\nnoveltm_nation\n\n\n  \n\n\ntotal_nation &lt;- noveltm_nation |&gt; \n  group_by(decade) |&gt; \n  summarise(total = n()) |&gt; \n  filter(total &gt; 1)\n\nsummary_nation &lt;- noveltm_nation |&gt; \n  group_by(decade, nationality, gender) |&gt; \n  summarise(counts = n()) |&gt; \n  filter(counts &gt; 1)\n\nsummary_nation\n\n\n  \n\n\nnoveltm_nation_share &lt;- summary_nation |&gt; \n  left_join(total) |&gt; \n  mutate(share = counts / total) |&gt; \n  select(-counts, -total)\n\nnoveltm_nation_share\n\n\n  \n\n\n\n\nnoveltm_nation_share |&gt; \n  filter(gender == \"f\") |&gt; \n  ggplot(aes(decade, share, color = nationality)) +\n  geom_line()\n\n\n\n\n\n\n\n\nДобавим название и немного поменяем оформление.\n\ng &lt;- noveltm_nation_share |&gt; \n  filter(gender == \"f\") |&gt; \n  ggplot(aes(decade, share, color = nationality)) +\n  geom_line(size = 2, alpha = 0.7) + \n  theme_minimal() + \n  labs(\n    title = \"Female Writers' Share\",\n    subtitle = \"NovelTM Data 1800-2009 \\n \",\n    x = NULL,\n    y = NULL) +\n  theme(text=element_text(size=14, family=\"serif\")) \n\nWarning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\nℹ Please use `linewidth` instead.\n\ng\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс “Exploratory Data Analysis” и пройдите из него урок 10 GGPlot2 Extras.\n\n\nПравда или ложь?\n\n\n\n\n\n\nВопрос\n\n\n\nЧтобы построить диаграмму рассеяния, нужно добавить к графическому объекту, созданному функцией ggplot, геометрический объект под названием geom_scatterplot.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nФункция cut() позволяет преобразовать числовой вектор в фактор.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nПолуинтервал (0.2,0.5] включает 0.2 и не включает 0.5.\n\n\n\n\nПравда\nЛожь",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#парадокс-симпсона",
    "href": "plot.html#парадокс-симпсона",
    "title": "3  Визуализации",
    "section": "3.9 Парадокс Симпсона",
    "text": "3.9 Парадокс Симпсона\nГрафик, кажется, подтверждает, что доля женщин в литературе снижалась примерно до середины XX в. Однако при разделении данных на группы можно заметить другую тенденцию. Это явление известно как “парадокс Симпсона”.\n\nnoveltm_nation &lt;- noveltm |&gt; \n  select(inferreddate, gender, nationality) |&gt; \n  mutate(nationality = case_when(!nationality %in% c(\"uk\", \"us\") ~ \"other\",\n                                 .default = nationality)) |&gt; \n  filter(gender != \"u\") |&gt; \n  mutate(decade = (inferreddate %/% 10) * 10) \n\nnoveltm_nation\n\n\n  \n\n\ntotal_nation &lt;- noveltm_nation |&gt; \n  group_by(decade) |&gt; \n  summarise(total = n()) |&gt; \n  filter(total &gt; 1)\n\nsummary_nation &lt;- noveltm_nation |&gt; \n  group_by(decade, nationality, gender) |&gt; \n  summarise(counts = n()) |&gt; \n  filter(counts &gt; 1)\n\n`summarise()` has grouped output by 'decade', 'nationality'. You can override\nusing the `.groups` argument.\n\nnoveltm_nation_share &lt;- summary_nation |&gt; \n  left_join(total) |&gt; \n  mutate(share = counts / total) |&gt; \n  select(-counts, -total)\n\nJoining with `by = join_by(decade)`\n\nnoveltm_nation_share\n\n\n  \n\n\nnoveltm_nation_share |&gt; \n  filter(gender == \"f\") |&gt; \n  ggplot(aes(decade, share, color = nationality)) +\n  geom_line()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс “Exploratory Data Analysis” и пройдите из него урок 10 GGPlot2 Extras.\n\n\nПравда или ложь?\n\n\n\n\n\n\nВопрос\n\n\n\nЧтобы построить диаграмму рассеяния, нужно добавить к графическому объекту, созданному функцией ggplot, геометрический объект под названием geom_scatterplot.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nФункция cut() позволяет преобразовать числовой вектор в фактор.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nПолуинтервал (0.2,0.5] включает 0.2 и не включает 0.5.\n\n\n\n\nПравда\nЛожь",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#диаграмма-рассеяния",
    "href": "plot.html#диаграмма-рассеяния",
    "title": "3  Визуализации",
    "section": "3.3 Диаграмма рассеяния",
    "text": "3.3 Диаграмма рассеяния\nФункция ggplot() имеет два основных аргумента: data и mapping. Аргумент mapping задает эстетические атрибуты геометрических объектов. Обычно используется в виде mapping = aes(x, y), где aes() означает aesthetics.\nПод “эстетикой” подразумеваются графические атрибуты, такие как размер, форма или цвет. Вы не увидите их на графике, пока не добавите какие-нибудь “геомы” – геометрические объекты (точки, линии, столбики и т.п.). Эти объекты могут слоями накладываться друг на друга (Wickham и Grolemund 2016).\nДиаграмма рассеяния, которая подходит для отражения связи между двумя переменными, делается при помощи geom_point(). Попробуем настройки по умолчанию.\n\nnoveltm |&gt; \n  ggplot(aes(inferreddate, n_words)) + \n  geom_point()\n\n\n\n\n\n\n\n\nУпс. Точек очень много, и они накладываются друг на друга, так как число слов – дискретная величина. Поступим так же, как Моретти, который отразил на графике среднее для каждого года. Для этого нам надо снова поколдовать над данными.\n\nnoveltm_summary &lt;- noveltm |&gt;\n  group_by(inferreddate) |&gt;\n  summarise(n = n(),\n            mean_w = mean(n_words, na.rm = TRUE)) |&gt; \n  filter(n &gt; 1)\n\nnoveltm_summary\n\n\n  \n\n\n\nСнова построим диаграмму рассеяния. Добавим линию тренда, изменим внешний вид точек и тему оформления, а также уберем подпись оси X.\n\nnoveltm_summary |&gt; \n  ggplot(aes(inferreddate, mean_w)) +\n  geom_point(color = \"steelblue\", alpha = 0.7, size = 2) +\n  geom_smooth(color = \"tomato\") + \n  theme_bw() +\n  xlab(NULL)\n\n\n\n\n\n\n\n\nНисходящая тенденция, о которой писал Моретти, хорошо прослеживается. Но, возможно, она характерна не для всех стран?",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#столбиковая-диаграмма",
    "href": "plot.html#столбиковая-диаграмма",
    "title": "3  Визуализации",
    "section": "3.8 Столбиковая диаграмма",
    "text": "3.8 Столбиковая диаграмма\nДля визуализации распределений качественных переменных подходит стобиковая диаграмма, которая наглядно показывает число наблюдений в каждой группе. В датасете NovelTM представлены следующие категории литературы.\n\nnoveltm |&gt; \n  ggplot(aes(category, fill = category)) +\n  geom_bar()\n\n\n\n\n\n\n\n\nНас будет интересовать категория longfiction, т.к. именно сюда попадает популярный в XIX в. жанр романа. Известно, что примерно до 1840 г. почти половина романистов были женщинами, но к началу XX в. их доля снизилась (Underwood 2019, 133). Отчасти это объясняется тем, что после середины XIX в. профессия писателя становится более престижной, а его социальный статус повышается, что приводит к “джентрификации” романа. Посмотрим, что на этот счет могут сказать данные NovelTM. Переменная gender хранит данные о гендере автора.\n\nnoveltm |&gt; \n  ggplot(aes(gender, fill = gender)) + \n  geom_bar()\n\n\n\n\n\n\n\n\nОтберем лишь одну категорию и два гендера.\n\nnoveltm_lf &lt;- noveltm |&gt; \n  select(inferreddate, gender, category) |&gt; \n  filter(gender != \"u\", category == \"longfiction\") |&gt; \n  select(-category)\n\nnoveltm_lf\n\n\n  \n\n\n\nМожно предположить, что соотношение мужчин и женщин в разные десятилетия менялось. Чтобы это выяснить, нам надо преобразовать данные, указав для каждого года соответствующую декаду, и посчитать число мужчин и женщин в каждой декаде.\n\nnoveltm_decade &lt;- noveltm_lf |&gt; \n  mutate(decade = (inferreddate %/% 10) * 10) \n\nnoveltm_decade\n\n\n  \n\n\n\nЭтого уже достаточно для визуализации, но она будет не очень наглядная.\n\nnoveltm_decade |&gt; \n  ggplot(aes(decade, fill = gender)) +\n  geom_bar(position = \"dodge\")\n\n\n\n\n\n\n\n\nУзнаем, сколько всего наблюдений в каждом десятилетии. В 1790-х всего одно наблюдение, его удаляем.\n\ntotal &lt;- noveltm_decade |&gt; \n  group_by(decade) |&gt; \n  summarise(total = n()) |&gt; \n  filter(total &gt; 1)\n\ntotal\n\n\n  \n\n\n\n\nsummary &lt;- noveltm_decade |&gt; \n  group_by(decade, gender) |&gt; \n  summarise(counts = n()) |&gt; \n  filter(counts &gt; 1)\n\nsummary\n\n\n  \n\n\n\nТеперь объединим две таблицы и посчитаем долю мужчин и женщин.\n\nnoveltm_share &lt;- summary |&gt; \n  left_join(total) |&gt; \n  mutate(share = counts / total) |&gt; \n  select(-counts, -total)\n\nJoining with `by = join_by(decade)`\n\nnoveltm_share\n\n\n  \n\n\n\n\nnoveltm_share |&gt; \n  ggplot(aes(decade, share, fill = gender)) +\n  geom_bar(stat = \"identity\")\n\n\n\n\n\n\n\n\nПопробуем развернуть диаграмму - так ее будет легче читать.\n\nnoveltm_share |&gt; \n  ggplot(aes(decade, share, fill = gender)) +\n  geom_bar(stat = \"identity\") + \n  coord_flip() + \n  xlab(NULL) + \n  ylab(NULL)\n\n\n\n\n\n\n\n\nПоскольку нас интересует доля женщин, логично поменять группы местами. Также поменяем порядок, в котором идут года (от меньшего к большему).\n\nnoveltm_share |&gt; \n  ggplot(aes(as.factor(decade), share, fill = gender)) +\n  geom_bar(stat = \"identity\", position = position_fill(reverse = TRUE)) + \n  scale_x_discrete(limits = rev) +\n  coord_flip() + \n  ylab(NULL) + \n  xlab(NULL) + \n  theme_minimal()\n\n\n\n\n\n\n\n\nУбавим цвет в мужской части диаграммы и добавим заголовки.\n\nnoveltm_share |&gt; \n  ggplot(aes(as.factor(decade), share, fill = gender)) +\n  geom_bar(stat = \"identity\", \n           position = position_fill(reverse = TRUE),\n           color = \"grey\",\n           show.legend = FALSE) + \n  scale_x_discrete(limits = rev) +\n  scale_fill_manual(values = c(\"lightcoral\", \"white\")) +\n  coord_flip() + \n  ylab(NULL) + \n  xlab(NULL) + \n  theme_minimal() +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"Women Share per Decade\",\n    subtitle = \"NovelTM Data 1800-2009\"\n  ) + \n  theme(text=element_text(size=12, family=\"serif\")) \n\n\n\n\n\n\n\n\nСтоит подвинуть заголовок, убрать просветы между столбцами и добавить подписи.\n\nlabel_data &lt;- noveltm_share |&gt; \n  filter(gender == \"f\") |&gt; \n  mutate(share = round(share, 2))\n\nnoveltm_share |&gt; \n  ggplot(aes(as.factor(decade), share, fill = gender)) +\n  geom_bar(stat = \"identity\", \n           position = position_fill(reverse = TRUE),\n           color = \"darkred\",\n           show.legend = FALSE,\n           width = 1) + \n  scale_x_discrete(limits = rev) +\n  scale_fill_manual(values = c(\"#f5b2b2\", \"white\")) +\n  coord_flip() + \n  ylab(NULL) + \n  xlab(NULL) + \n  theme_minimal() +\n  labs(\n    x = NULL,\n    y = NULL,\n    title = \"Women Share per Decade\",\n    subtitle = \"NovelTM Data 1800-2009\"\n  ) + \n  geom_text(data = label_data, aes(label = share), \n            hjust = 1.2, \n            color = \"darkred\",\n            family = \"serif\") +\n  theme(text=element_text(size=12, family=\"serif\", color = \"darkred\"),\n        plot.title.position = \"plot\",\n        axis.text = element_text(color = \"darkred\"),\n        )",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#линейная-диаграмма",
    "href": "plot.html#линейная-диаграмма",
    "title": "3  Визуализации",
    "section": "3.9 Линейная диаграмма",
    "text": "3.9 Линейная диаграмма\nДанные о доли женщин-писателей можно представить и в виде линии: в нашем случае это не лишено смысла, поскольку ось x – это временная шкала.\n\nnoveltm_share |&gt; \n  filter(gender == \"f\") |&gt; \n  ggplot(aes(decade, share, color = gender)) +\n  geom_line(show.legend = FALSE)\n\n\n\n\n\n\n\n\nПо умолчанию ось y усекается, и создается впечатление, что доля женщин ок. 1900 падает чуть ли не до нуля. Поправим вручную границы оси.\n\nnoveltm_share |&gt; \n  filter(gender == \"f\") |&gt; \n  ggplot(aes(decade, share, color = gender)) +\n  geom_line(show.legend = FALSE) +\n  expand_limits(y = 0)\n\n\n\n\n\n\n\n\nГрафик, кажется, подтверждает, что доля женщин в литературе снижалась примерно до середины XX в. Однако при разделении данных на группы можно заметить другую тенденцию.\n\nnoveltm_nation &lt;- noveltm |&gt; \n  filter(category == \"longfiction\") |&gt; \n  select(inferreddate, gender, nationality) |&gt; \n  mutate(nationality = case_when(!nationality %in% c(\"uk\", \"us\") ~ \"other\",\n                                 .default = nationality)) |&gt; \n  filter(gender != \"u\") |&gt; \n  mutate(decade = (inferreddate %/% 10) * 10)\n\nnoveltm_nation\n\n\n  \n\n\ntotal_nation &lt;- noveltm_nation |&gt; \n  group_by(decade) |&gt; \n  summarise(total = n()) |&gt; \n  filter(total &gt; 1)\n\nsummary_nation &lt;- noveltm_nation |&gt; \n  group_by(decade, nationality, gender) |&gt; \n  summarise(counts = n()) |&gt; \n  filter(counts &gt; 1)\n\nsummary_nation\n\n\n  \n\n\nnoveltm_nation_share &lt;- summary_nation |&gt; \n  left_join(total) |&gt; \n  mutate(share = counts / total) |&gt; \n  select(-counts, -total)\n\nnoveltm_nation_share\n\n\n  \n\n\n\n\nnoveltm_nation_share |&gt; \n  filter(gender == \"f\") |&gt; \n  ggplot(aes(decade, share, color = nationality)) +\n  geom_line() \n\n\n\n\n\n\n\n\nДобавим название и немного поменяем оформление.\n\nnoveltm_nation_share |&gt; \n  filter(gender == \"f\") |&gt; \n  ggplot(aes(decade, share, color = nationality)) +\n  geom_line(linewidth = 2, alpha = 0.7) + \n  theme_minimal() + \n  labs(\n    title = \"Female Writers' Share\",\n    subtitle = \"NovelTM Data 1800-2009 \\n \",\n    x = NULL,\n    y = NULL) +\n  theme(text=element_text(size=14, family=\"serif\")) + \n  scale_color_viridis_d()\n\n\n\n\n\n\n\n\nМожно добавить темную рамку и переместить легенду.\n\ng &lt;- noveltm_nation_share |&gt; \n  filter(gender == \"f\") |&gt; \n  ggplot(aes(decade, share, color = nationality)) +\n  geom_line(linewidth = 2, alpha = 0.7) + \n  theme_light() + \n  labs(\n    title = \"Female Writers' Share\",\n    subtitle = \"NovelTM Data 1800-2009\",\n    x = NULL,\n    y = NULL) +\n  theme(text=element_text(size=14, family=\"serif\"),\n        axis.text = element_text(color = \"white\"),\n        legend.position = c(0.5, 0.84), \n        legend.direction = \"horizontal\",\n        legend.title = element_blank(),\n        legend.text = element_text(color = \"#440151FF\"),\n        legend.background = element_blank(),\n        plot.title = element_text(hjust=0.5, color = \"white\"),\n        plot.subtitle = element_text(hjust=0.5, color = \"white\"),\n        plot.background = element_rect(fill = \"#440151FF\"),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        panel.grid.major.y = element_line(linewidth = 0.5)) + \n  scale_color_viridis_d()\n\ng",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "iterate.html",
    "href": "iterate.html",
    "title": "4  Циклы, условия, функции",
    "section": "",
    "text": "4.1 Циклы и их аналоги\nХорошая новость: многие функции в R уже векторизованы, и если необходимо применить функцию к каждому элементу вектора, в большинстве случаев достаточно просто вызвать функцию. Это называется векторизация.\nНапример, у нас есть символьный вектор, и мы хотим узнать количество символов в каждом слове.\nhomer &lt;- c(\"в\", \"мысли\", \"ему\", \"то\", \"вложила\", \"богиня\", \"державная\", \"гера\")\nДля каждого компонента вектора необходимо выполнить одну итерацию цикла, в нашем случае – применить функцию nchar(). В некоторых языках программирования это делается как-то так:\nfor(i in homer) print(nchar(i))\n\n[1] 1\n[1] 5\n[1] 3\n[1] 2\n[1] 7\n[1] 6\n[1] 9\n[1] 4\nМы написали цикл for, который считает количество букв для каждого слова в векторе. Как видно, все сработало. Но в R это избыточно, потому что nchar() уже векторизована:\nnchar(homer)\n\n[1] 1 5 3 2 7 6 9 4\nЭто относится не только ко многим встроенным функциям R, но и к даже к операторам. x + 4 в действительности представляет собой +(x, 4):\nx &lt;- c(1.2, 2.51, 3.8)\n\n`+`(x, 4) \n\n[1] 5.20 6.51 7.80\nКлючевую роль здесь играет переработка данных, о которой мы говорили в первом уроке: короткий вектор повторяется до тех пор, пока его длина не сравняется с длиной более длинного вектора. Как-то так:\n\\[ \\left(\n    \\begin{array}{c}\n      1.2 \\\\\n      2.51 \\\\\n      3.8\n    \\end{array}\n  \\right) + \\left(\n    \\begin{array}{c}\n      4 \\\\\n      4 \\\\\n      4\n    \\end{array}\n  \\right) \\]\nЛишний цикл может замедлить вычисления. Проверим. Дан вектор x &lt;- c(3, 5, 7, 13). Необходимо возвести в квадрат каждое число, а из результата вычесть 100. Выполним двумя способами.\nlibrary(tictoc)\nx &lt;- c(2, 3, 5, 7, 11, 13)\n\n# способ первый\ntic()\nfor (i in x) print(i^2 - 100)\n\n[1] -96\n[1] -91\n[1] -75\n[1] -51\n[1] 21\n[1] 69\n\ntoc()\n\n0.001 sec elapsed\n\n# способ второй \ntic()\nx^2 - 100\n\n[1] -96 -91 -75 -51  21  69\n\ntoc()\n\n0.001 sec elapsed\nДля работы со списками циклы тоже чаще всего избыточны. Снова воспользуемся списком печенек из коллекции rcorpora.\nlibrary(rcorpora)\nmy_list &lt;-  corpora(\"foods/breads_and_pastries\")\npaste(\"Длина списка:\", length(my_list))\n\n[1] \"Длина списка: 3\"\n\nnames(my_list)\n\n[1] \"description\" \"breads\"      \"pastries\"\nКак узнать длину каждого вложенного в список вектора? Попробуем цикл (снова заметим время):\ntic()\nfor (i in 1:length(my_list)) print(length(my_list[[i]]))\n\n[1] 1\n[1] 35\n[1] 20\n\ntoc()\n\n0.002 sec elapsed\nНо в базовом R для таких случаев существуют функционалы lapply() и sapply(). Они принимают на входе список и функцию и применяют функцию к каждому элементу списка. Получается быстрее:\ntic()\nlapply(my_list, length)\n\n$description\n[1] 1\n\n$breads\n[1] 35\n\n$pastries\n[1] 20\n\ntoc()\n\n0.001 sec elapsed\nФункция sapply() упростит результат до вектора (s означает simplify):\ntic()\nsapply(my_list, length)\n\ndescription      breads    pastries \n          1          35          20 \n\ntoc()\n\n0.001 sec elapsed\nЕсли в виде списка хранится корпус, то так можно сделать, например, случайную выборку. Заметьте, как переданы аргументы функции sample().\nlapply(my_list[2:3], sample, 5, replace = TRUE)\n\n$breads\n[1] \"casalinga\"    \"tortilla\"     \"pumpernickel\" \"fruit bread\"  \"flatbread\"   \n\n$pastries\n[1] \"croissant\"     \"mille-feuille\" \"morning bun\"   \"rugelach\"     \n[5] \"croissant\"\nМожет быть, с датафреймами будут полезны циклы? Например, так.\ndf &lt;- data.frame(author=c(\"Joe\",\"Jane\"), year=c(1801,1901), reprints=c(TRUE,FALSE))\ndf\ntic()\nfor (i in seq_along(df)) {\n print(class(df[,i]))\n}\n\n[1] \"character\"\n[1] \"numeric\"\n[1] \"logical\"\n\ntoc()\n\n0.002 sec elapsed\nНо и здесь можно ускориться. Второй аргумент apply означает, что мы работаем со столбцами (1 - строки).\ntic()\napply(df, 2, class)\n\n     author        year    reprints \n\"character\" \"character\" \"character\" \n\ntoc()\n\n0.002 sec elapsed\nЕсть еще vapply(), tapply() и mapply(), но и про них мы не будем много говорить, потому что все их с успехом заменяет семейство map_() из пакета purrr в tidyverse.\nТем не менее, перед освоением семейства map_() стоит потренироваться работать с обычными циклами, особенно если вам не приходилось иметь с ними дела (например, на Python). Несмотря на все недостатки, цикл for интуитивно понятен и часто проще начинать именно с него. Поэтому, прежде чем двинуться дальше, сделаем несколько упражнений из (Wickham и Grolemund 2016, 316).\n# стоит заглянуть в документацию к функции\nout &lt;- \"\"\nfor (x in letters) {\n  out &lt;- stringr::str_c(out, x)\n}\n\n# ответ - всего пять символов...\nx &lt;- sample(100)\nsd &lt;- 0\nfor (i in seq_along(x)) {\n  sd &lt;- sd + (x[i] - mean(x)) ^ 2\n}\nsd &lt;- sqrt(sd / (length(x) - 1))\n\n# надо понять, что тут происходит \nx &lt;- runif(100)\nout &lt;- vector(\"numeric\", length(x))\nout[1] &lt;- x[1]\nfor (i in 2:length(x)) {\n  out[i] &lt;- out[i - 1] + x[i]\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Циклы, условия, функции</span>"
    ]
  },
  {
    "objectID": "iterate.html#циклы-и-их-аналоги",
    "href": "iterate.html#циклы-и-их-аналоги",
    "title": "4  Циклы, условия, функции",
    "section": "",
    "text": "На заметку\n\n\n\nВ циклах часто используется буква i. Но никакой особой магии в ней нет, имя переменной можно изменить.\n\n\n\n\n\n\n\n\n\n\n\nОдин из главных принципов программирования на R гласит, что следует обходиться без циклов, а если это невозможно, то циклы должны быть простыми.\n— Нормат Мэтлофф\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nПройдите урок 10 lapply and sapply и урок 11 vapply and tapply из курса R Programming в swirl.\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\n\nПосчитайте среднее для всех столбцов в mtcars.\nОпределите тип данных во всех столбцах nycflights13::flights.\nПосчитайте число уникальных значений в каждом столбце iris.\nСгенерируйте 10 случайных чисел из нормального распределения - это делает функция rnorm() - со средним -10, 0, 10.\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nПопробуйте избавиться от цикла 😜.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Циклы, условия, функции</span>"
    ]
  },
  {
    "objectID": "iterate.html#условия",
    "href": "iterate.html#условия",
    "title": "4  Циклы, условия, функции",
    "section": "4.2 Условия",
    "text": "4.2 Условия\nИногда необходимо ограничить выполнение функции неким условием. Короткие условия можно писать в одну строку без фигурных скобок.\n\ny &lt;-  \"Эйяфьятлайокудль\"\n\nif(nchar(y) &gt; 10) print(\"много букв\")\n\n[1] \"много букв\"\n\n\nБолее сложные и множественные условия требуют фигурных скобок. Можно сравнить это с условным периодом: протасис (всегда либо TRUE, либо FALSE) в круглых скобках, аподосис в фигурных.\n\nif (nchar(y) &gt; 10) {\n  print(\"много букв\")\n} else if (nchar(y) &lt; 5) {\n  print(\"мало букв\")\n} else {\n  print(\"норм букв\")\n}\n\n[1] \"много букв\"\n\n\nТакже в R можно использовать специальную функцию:\n\nifelse(nchar(y) &gt; 10, \"много букв\", \"мало букв\")\n\n[1] \"много букв\"\n\n\nПрописывая условие, не забывайте, что применение булева оператора к вектору возвращает логический вектор:\n\nx &lt;- c(1:10)\nx &gt;= 5\n\n [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\nТакое условие вернет ошибку.\n\nif (x &gt;= 5) print(\"все сломалось\")\n\nError in if (x &gt;= 5) print(\"все сломалось\"): the condition has length &gt; 1\n\n\nМожно скорректировать код так:\n\nif (any(x &gt;= 5)) print(\"все сработало\")\n\n[1] \"все сработало\"\n\n\nПо той же причине внутри условия не надо использовать логические операторы | (“или”) или & (“и”), потому что они векторизованы:\n\nx &lt; 3 | x &gt; 7\n\n [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Циклы, условия, функции</span>"
    ]
  },
  {
    "objectID": "iterate.html#функции",
    "href": "iterate.html#функции",
    "title": "4  Циклы, условия, функции",
    "section": "4.3 Функции",
    "text": "4.3 Функции\nФункция и код – не одно и то же. Чтобы стать функцией, кусок кода должен получить имя. Но зачем давать имя коду, который и так работает?\nВот три причины, которые приводит Хадли Уикхем:\n\nу функции есть выразительное имя, которое облегчает понимание кода;\nпри изменении требований необходимо обновлять код только в одном месте, а не во многих;\nменьше вероятность случайных ошибок при копировании (например, обновление имени переменной в одном месте, но не в другом)\n\n\nWriting good functions is a lifetime journey.\n— Hadley Wickham\n\nМашине все равно, как вы назовете функцию, но тем, кто будет читать код, не все равно. Имена должны быть информативы (поэтому функция f() – плохая идея). Также не стоит переписывать уже существующие в R имена!\nДалее следует определить формальные аргументы и, при желании, значения по умолчанию. Тело функции пишется в фигурных скобках. В конце кода функции располагается команда return(); если ее нет, то функция возвращает последнее вычисленное значение (см. здесь о том, когда что предпочесть).\nНаписание функций – навык, который можно бесконечно совершенствовать. Начать проще всего с обычного кода. Убедившись, что он работает как надо, вы можете упаковать его в функцию.\nНапример, нам нужна функция, которая ищет совпадения в двух векторах и возвращает совпавшие элементы. Сначала решим задачу для двух векторов.\n\nline1 &lt;- c(\"гнев\", \"богиня\", \"воспой\")\nline2 &lt;- c(\"в\", \"мысли\", \"ему\", \"то\", \"вложила\", \"богиня\", \"державная\", \"гера\")\nidx &lt;- which(line2 %in% line1) # 2\nline2[idx]\n\n[1] \"богиня\"\n\n\nТеперь заменяем фактические переменные на формальные.\n\ncommon_words &lt;- function(x, y){\n  idx &lt;- which(x %in% y)\n  x[idx]\n}\n\nИ применяем к новым данным.\n\nline3 &lt;- c(\"лишь\", \"явилась\", \"заря\", \"розоперстая\", \"вестница\", \"утра\")\nline4 &lt;- c(\"вестница\", \"утра\", \"заря\", \"на\", \"великий\", \"олимп\", \"восходила\")\ncommon_words(line4, line3)\n\n[1] \"вестница\" \"утра\"     \"заря\"    \n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗагрузите библиотеку swirl, выберите курс R Programming и пройдите из него урок 9 Functions.\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nДля просмотра исходного кода любой функции необходимо…\n\n\n\n\n\n\nиспользовать специальную функцию для просмотра кода\n\n\nнабрать имя функции без аргументов и без скобок\n\n\nединственный способ — найти код функции в репозитории на GitHub\n\n\nвызвать help к функции\n\n\n\n\n\n\n\nНапишем функцию, которая будет центрировать данные, то есть вычитать среднее из каждого значения (забудем на время, что это уже делает базовая scale()):\n\ncenter &lt;- function(x){ \n  n = x - mean(x)\n  return(n) \n}\n\nx &lt;- c(5, 10, 15)\ncenter(x) \n\n[1] -5  0  5\n\n\nВнутри нашей функции есть переменная n, которую не видно в глобальном окружении. Это локальная переменная. Область ее видимости – тело функции. Когда функция возвращает управление, переменная исчезает. Обратное неверно: глобальные переменные доступны в теле функции.\nФункция может принимать произвольное число аргументов. Доработаем наш код:\n\ncenter &lt;- function(x, na.rm = F){\n  if(na.rm) { x &lt;- x[!is.na(x)]} # добавим условие\n  x - mean(x) # на этот раз без return()\n}\n\nx &lt;- c(5, 10, NA)\ncenter(x)\n\n[1] NA NA NA\n\n\nЧто произошло? Почему следующий код выдает другой результат?\n\ncenter(x, na.rm = T)\n\n[1] -2.5  2.5\n\n\nВычисления в R ленивы, то есть они откладываются до тех пор, пока не понадобится результат. Если вы зададите аргумент, который не нужен в теле функции, ошибки не будет.\n\ncenter &lt;- function(x, na.rm = F, what_is_your_name){\n  if(na.rm) { x &lt;- x[!is.na(x)]} # добавим условие\n  x - mean(x) # на этот раз без return()\n}\n\ncenter(x, na.rm = T)\n\n[1] -2.5  2.5\n\ncenter(x, na.rm = T, what_is_your_name = \"Locusclassicus\")\n\n[1] -2.5  2.5\n\n\nЧасто имеет смысл добавить условие остановки или сообщение, которое будет распечатано в консоль при выполнении.\n\ncenter &lt;- function(x){\n  if (length(x) == 1) {stop(\"Отстань, старушка, я в печали.\")}\n  x - mean(x) # на этот раз без return()\n}\n\nx &lt;- 10\ncenter(x) # вернет ошибку\n\n\n\n\n\n\n\nЗадание\n\n\n\nНапишите функцию awesome_plot, которая будет принимать в качестве аргументов два вектора, трансформировать их в тиббл и строить диаграмму рассеяния при помощи ggplot(). Задайте цвет и прозрачность точек, а в подзаголовке выведите коэффициент корреляции.\n\n\n\n\n\n\n\n\nЗадание\n\n\n\n\nНапишите код, который распечатает стихи детской песни “Alice the Camel”.\nПревратите детскую потешку “Ted in the Bed” в функцию. Обобщите до любого числа спящих.\nЗапишите в виде функции текст песни “99 Bottles of Beer on the Wall”. Обобщите до любого числа любых напитков на любой поверхности.\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nНапишите функцию, которая будет говорить “доброе утро”, “добрый день” или “добрый вечер” в зависимости от времени суток. Используйте lubridate::now() в качестве значения аргумента по умолчанию.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Циклы, условия, функции</span>"
    ]
  },
  {
    "objectID": "iterate.html#purrr",
    "href": "iterate.html#purrr",
    "title": "4  Циклы, условия, функции",
    "section": "4.4 Purrr",
    "text": "4.4 Purrr\nПо-настоящему мощный инструмент для итераций – это пакет purrr из семейства tidyverse. Разработчики предупреждают, что потребуется время, чтобы овладеть этим инструментом (Wickham и Grolemund 2016).\n\nYou should never feel bad about using a loop instead of a map function. The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work.\n— Hadley Wickham & Garrett Grolemund\n\nВ семействе функций map_ из этого пакета всего 23 вариации. Вот основные из них:\n\nmap()\nmap_lgl()\nmap_int()\nmap_dbl()\nmap_chr()\n\nВсе они принимают на входе данные и функцию (или формулу), которую следует к ним применить, и возвращают результат в том виде, который указан после подчеркивания. Просто map() вернет список, а map_int() – целочисленный вектор, и т.д.\nВоспользуемся возможностями purrr, чтобы исследовать датасет starwars из пакета dplyr. Для начала узнаем число отсутствующих значений в каждом столбце. Косая черта (\\) указывает на то, что мы используем анонимную функцию\n\nlibrary(tidyverse)\nstarwars &lt;- starwars\nmap_int(starwars, \\(x) sum(is.na(x)))\n\n      name     height       mass hair_color skin_color  eye_color birth_year \n         0          6         28          5          0          0         44 \n       sex     gender  homeworld    species      films   vehicles  starships \n         4          4         10          4          0          0          0 \n\n\nОбратите внимание, что map_int, как и map_dbl возвращает именованный вектор. Чтобы избавиться от имен, можно использовать unname():\n\nmap_chr(starwars, class) |&gt; \n  unname()\n\n [1] \"character\" \"integer\"   \"numeric\"   \"character\" \"character\" \"character\"\n [7] \"numeric\"   \"character\" \"character\" \"character\" \"character\" \"list\"     \n[13] \"list\"      \"list\"     \n\n\n\nИспользуйте map_dbl и n_distinct, чтобы узнать число уникальных наблюдений в каждом столбце.\n\nЕсли функция принимает дополнительные аргументы, их можно задать после названия функции. В таком случае для каждого вызова функции будет использовано это значение аргумента. В примере ниже это аргумент na.rm.\n\nstarwars |&gt; \n  select(mass, height) |&gt; \n  map(mean, na.rm = TRUE)\n\n$mass\n[1] 97.31186\n\n$height\n[1] 174.6049\n\n\nПри вызове map_df есть дополнительная возможность сохранить названия столбцов, используя аргумент .id:\n\nstarwars |&gt; \n  map_df(~data.frame(unique_values = n_distinct(.x),\n                     col_class = class(.x)),\n         .id = \"variable\"\n         )\n\n\n  \n\n\n\nФункции map можно передать пользовательскую функцию. Для примера создадим функцию describe_vec(), которая возвращает строку с длиной и классом вектора, и применим ее к хлебо-булочному списку из примеров выше.\n\n# пользовательская функция\ndescribe_vec &lt;- function(vec){\n  l = paste(\"Длина вектора: \", length(vec))\n  c = paste(\"Класс вектора: \", class(vec))\n  result = paste(l, c, sep = \" | \")\n  return(result)\n}\n\nmap_chr(my_list, describe_vec) |&gt; \n  unname()\n\n[1] \"Длина вектора:  1 | Класс вектора:  character\" \n[2] \"Длина вектора:  35 | Класс вектора:  character\"\n[3] \"Длина вектора:  20 | Класс вектора:  character\"\n\n\nКроме того, мы можем передать map анонимную функцию (вместо function можно поставить \\):\n\nmap_chr(my_list, \n        function(x) paste(\"Длина вектора: \", length(x))\n        )\n\n         description               breads             pastries \n \"Длина вектора:  1\" \"Длина вектора:  35\" \"Длина вектора:  20\" \n\n\nЕсли необходимо несколько раз вызывать одну и ту же функцию с двумя аргументами, используется функция map2(). Аргументы, которые меняются при каждом вызове, пишутся до функции; аргументы, которые остаются неизменны, – после.\n\nmean = list(5, 10, -3)\nsd = list(1, 5, 50)\nmap2(mean, sd, rnorm, n = 5)\n\n[[1]]\n[1] 5.606236 6.674324 7.120550 4.269691 5.646766\n\n[[2]]\n[1] 18.812590 18.821804 12.961582  8.766922 12.555786\n\n[[3]]\n[1]  28.12704  50.88303 -99.55774  19.01899  49.18838\n\n\n\n\n\n\n_Как работает map2()_\n\n\n\nЭто можно обобщить следующим образом (источник):\n\nМожно было бы предположить, что должны быть и map3(), map4() и т.д., но во всех случаеях, когда у функции больше двух аргументов, используется pmap().\n\n\n\n\n\n\nЗадание\n\n\n\nУстановите курс swirl::install_course(\"Advanced R Programming\") и пройдите из него урок 3 Functional Programming with purrr.\n\n\nНесколько вопросов для самопроверки.\n\n\n\n\n\n\nВопрос\n\n\n\nФункции-предикаты (predicate functions) возвращают TRUE или FALSE. Выберите из списка все функции-предикаты.\n\n\n\n\nevery()\n\n\nsome()\n\n\nnone()\n\n\nhas_element()\n\n\nis.factor()\n\n\nkeep()\n\n\ndiscard()\n\n\nis.numeric()\n\n\ndetect()\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКакие из функций ниже принимают в качестве аргумента функции-предикаты?\n\n\n\n\nevery()\n\n\nsome()\n\n\nnone()\n\n\nhas_element()\n\n\nis.factor()\n\n\nkeep()\n\n\ndiscard()\n\n\nis.numeric()\n\n\ndetect()",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Циклы, условия, функции</span>"
    ]
  },
  {
    "objectID": "iterate.html#чтение-файлов-с-purrr",
    "href": "iterate.html#чтение-файлов-с-purrr",
    "title": "4  Циклы, условия, функции",
    "section": "4.5 Чтение файлов с purrr",
    "text": "4.5 Чтение файлов с purrr\nВы уже поняли, что благодаря циклам можно прочитать сразу несколько файлов. Та же задача решается и при помощи map. Мы потренируемся на датасете, который в 2023 г. был доступен на сайте Британской библиотеки (https://www.bl.uk/), но потом оттуда исчез. Однако у нас сохранилась копия.\nДатасет представляет собой набор файлов .csv, содержащих метаданные о ресурсах, связанных с Гарри Поттером, из коллекций Британской библиотеки. Первоначально он был выпущен к 20-летию публикации книги «Гарри Поттер и философский камень» 26 июня 2017 года и с тех пор ежегодно обновлялся. Всего в датасете пять файлов, каждый из которых содержит разное представление данных.\nСкачаем архив.\n\nmy_url &lt;- \"https://github.com/locusclassicus/text_analysis_2024/raw/main/files/HP.zip\"\ndownload.file(url = my_url, destfile = \"HP.zip\")\n\nПосле этого переходим в директорию с архивом и распаковываем его.\n\nunzip(\"HP.zip\")\n\n\n\n\n\n\n\nЗадание\n\n\n\nПрактическое задание “Гарри Поттер”\n\n\n\n# сохраните список всех файлов с расширением .csv, \n# используя подходящую функцию из base R\n\n# ваш код здесь\n# my_files &lt;- \n\n# напишите цикл, который:\n# 1) прочитает все файлы из my_files, используя для этого функцию read_csv() из пакета readr\n# (аргумент show_col_types установите на FALSE);\n# 2) для каждого датасета выяснит количество рядов _без_ NA в столбце BNB Number;\n# 3) разделит число таких рядов на общее число рядов;\n# 4) вернет таблицу c четырьми столбцами: \n# - название файла (id), \n# - число рядов (total), \n# - число рядов без NA (complete), \n# - доля полных рядов (ratio)\n\nmy_df &lt;- data.frame(id = my_files, \n                    total = rep(0, length(my_files)),\n                    complete = rep(0, length(my_files)),\n                    ratio = rep(0, length(my_files)))\n\nfor (i in 1:length(my_files)) {\n  # ваш код здесь\n}\n\nУзнаем имена файлов в директории и прочитаем их все одним вызовом функции.\n\n# чтение файлов \nlibrary(readr)\n\nfiles &lt;- list.files(\"../files/HP\", pattern = \".csv\", full.names = TRUE)\n\nHP &lt;- map(files, read_csv, col_types = cols())\n\nОбъект HP – это список. В нем пять элементов, так как на входе у нас было пять файлов. Для удобства назначим имена элементам списка. Пока можно не вникать, что здесь происходит – регулярные выражения мы рассмотрим в одном из следующих уроков.\n\nlibrary(stringr) \nnames(HP) &lt;- str_extract(files, \"\\\\w+(?=.csv)\")\nnames(HP)\n\n[1] \"classification\" \"names\"          \"records\"        \"titles\"        \n[5] \"topics\"        \n\n\nНачнем с простого: при помощи map можно извлечь столбцы (по имени) или ряды (по условию) из всех пяти таблиц. Прежде чем выполнить код ниже, подумайте, как будет выглядеть результат.\n\n# извлечь столбцы\nmap(HP, select, `BNB number`)\n\n# извлечь ряды\nmap(HP, filter, !(is.na(`BNB number`)))\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nИзвлеките все уникальные названия (столбец Title) из всех пяти таблиц в HP. Используйте функцию distinct.\n\n\n\nЧто, если мы не знаем заранее, какие столбцы есть во всех пяти таблицах, и хотим это выяснить? Для этого подойдет функция reduce() из того же purrr. Она принимает на входе вектор (или список) и функцию и применяет функцию последовательно к каждой паре значений.\n\n\n\nИсточник.\n\n\n\nВоспользуемся этим, чтобы найти общие для всех таблиц имена столбцов.\n\nmap(HP, colnames) |&gt; \n  reduce(intersect)\n\n [1] \"Dewey classification\"       \"BL record ID\"              \n [3] \"Type of resource\"           \"Content type\"              \n [5] \"Material type\"              \"BNB number\"                \n [7] \"ISBN\"                       \"ISSN\"                      \n [9] \"Name\"                       \"Dates associated with name\"\n[11] \"Type of name\"               \"Role\"                      \n[13] \"Title\"                      \"Series title\"              \n[15] \"Number within series\"       \"Country of publication\"    \n[17] \"Place of publication\"       \"Publisher\"                 \n[19] \"Date of publication\"        \"Edition\"                   \n[21] \"Physical description\"       \"BL shelfmark\"              \n[23] \"Genre\"                      \"Languages\"                 \n[25] \"Notes\"                     \n\n\nЕще одна неочевидная возможность функции reduce - объединение нескольких таблиц в одну одним вызовом. Например, так:\n\nHP_joined &lt;- HP |&gt; \n  reduce(left_join)\n\nТеперь можно почистить данные и построить несколько разведывательных графиков.\n\nlibrary(ggplot2)\nlibrary(tidyr)\ndata_sum &lt;- HP_joined |&gt; \n  separate(`Date of publication`, into = c(\"year\", NA)) |&gt; \n  separate(`Country of publication`, into = c(\"country\", NA), sep = \";\") |&gt;\n  mutate(country = str_squish(country)) |&gt; \n  mutate(country = \n           case_when(country == \"England\" ~ \"United Kingdom\",\n                     country == \"Scotland\" ~ \"United Kingdom\",\n                     TRUE ~ country)) |&gt; \n  group_by(year, country) |&gt; \n  summarise(n = n()) |&gt; \n  filter(!is.na(year)) |&gt; \n  filter(!is.na(country)) \n  \n\n# график\ndata_sum |&gt; \n  ggplot(aes(year, n, fill = country)) + \n  geom_col() + \n  xlab(NULL) +\n  theme(axis.text.x = element_text(angle = 90))\n\n\n\n\n\n\n\n\nВ качестве небольшого бонуса к этому уроку построим облако слов. Вектор слов возьмем из столбца Topic.\n\nlibrary(tidyr)\ndata_topics &lt;- HP_joined |&gt; \n  filter(!is.na(Topics)) |&gt; \n  separate(Topics, into = c(\"topic\", NA)) |&gt; \n  mutate(topic = tolower(topic)) |&gt; \n  group_by(topic) |&gt; \n  summarise(n = n()) |&gt; \n  filter(!topic %in% c(\"harry\", \"rowling\", \"potter\", \"children\", \"literary\"))\n\n\npal &lt;- c(\"#f1c40f\", \"#34495e\", \n         \"#8e44ad\", \"#3498db\",\n         \"#2ecc71\")\n\nlibrary(wordcloud)\n\nLoading required package: RColorBrewer\n\npar(mar = c(1, 1, 1, 1))\nwordcloud(data_topics$topic, \n          data_topics$n,\n          min.freq = 3,\n          #max.words = 50, \n          scale = c(3, 0.8),\n          colors = pal, \n          random.color = T, \n          rot.per = .2,\n          vfont=c(\"script\",\"plain\")\n          )\n\n\n\n\n\n\n\n\nИнтерактивное облако слов можно построить с использованием пакета wordcloud2. Сделаем облако в форме шляпы волшебника!\n\n# devtools::install_github(\"lchiffon/wordcloud2\")\nlibrary(wordcloud2)\n\n\nwordcloud2(data_topics, \n           figPath = \"./images/hat.png\",\n           size = 1.5,\n           color=\"random-light\", \n           fontWeight = \"normal\",\n           backgroundColor=\"black\"\n           )\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nПрактическое задание “Алиса в стране чудес”\n\n\n\n\n# постройте облако слов для \"Алисы в стране чудес\"\n\nlibrary(languageR)\nlibrary(dplyr)\nlibrary(tidytext)\n\n# вектор с \"Алисой\"\nalice &lt;- tolower(alice)\n\n# частотности для слов\nfreq &lt;- as_tibble(table(alice)) |&gt; \n  rename(word = alice)\n\n# удалить стоп-слова\nfreq_tidy &lt;- freq |&gt; \n  anti_join(stop_words) \n# возможно, вы захотите произвести и другие преобразования\n\n# облако можно строить в любой библиотеке\n\n\n\n\n\nWickham, Hadley, и Garrett Grolemund. 2016. R for Data Science. O’Reilly. https://r4ds.had.co.nz/index.html.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Циклы, условия, функции</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "Литература",
    "section": "",
    "text": "Burns, Patrick. 2012. The R\ninferno. Lulu.com.\n\n\nUnderwood, Ted. 2019. Distant Horizons: Digital\nEvidence and Literary Change. University of Chicago Press.\n\n\nWickham, Hadley, and Garrett Grolemund. 2016. R\nfor Data Science. O’Reilly. https://r4ds.had.co.nz/index.html.\n\n\nМастицкий, Сергей. 2017. Визуализация Данных с Помощью Ggplot2.\nДМК.",
    "crumbs": [
      "Литература"
    ]
  },
  {
    "objectID": "iterate.html#гарри-поттер-цикл-vs.-map_",
    "href": "iterate.html#гарри-поттер-цикл-vs.-map_",
    "title": "4  Циклы, условия, функции",
    "section": "4.5 Гарри Поттер: цикл vs. map_()",
    "text": "4.5 Гарри Поттер: цикл vs. map_()\nКак вы уже поняли, одни и те же задачи можно решать при помощи циклов и при помощи map_. Мы потренируемся на датасете, который в 2023 г. был доступен на сайте Британской библиотеки (https://www.bl.uk/), но потом оттуда исчез (но у нас сохранилась копия).\nДатасет представляет собой набор файлов .csv, содержащих метаданные о ресурсах, связанных с Гарри Поттером, из коллекций Британской библиотеки. Первоначально он был выпущен к 20-летию публикации книги «Гарри Поттер и философский камень» 26 июня 2017 года и с тех пор ежегодно обновлялся. Всего в датасете пять файлов, каждый из которых содержит разное представление данных.\nСкачаем архив.\n\nmy_url &lt;- \"https://github.com/locusclassicus/text_analysis_2024/raw/main/files/HP.zip\"\ndownload.file(url = my_url, destfile = \"../files/HP.zip\")\n\nПосле этого переходим в директорию с архивом и распаковываем его.\n\nunzip(\"../files/HP.zip\")\n\nСохраним список всех файлов с расширением .csv, используя подходящую функцию из base R.\n\nmy_files &lt;- list.files(\"../files/HP\", pattern = \".csv\", full.names = TRUE)\nmy_files\n\n[1] \"../files/HP/classification.csv\" \"../files/HP/names.csv\"         \n[3] \"../files/HP/records.csv\"        \"../files/HP/titles.csv\"        \n[5] \"../files/HP/topics.csv\"        \n\n\n\n4.5.1 Цикл\nТеперь напишем цикл, который\n\nпрочитает все файлы из my_files, используя для этого функцию read_csv() из пакета readr;\nдля каждого датасета выяснит количество рядов без NA в столбце BNB Number;\nразделит число таких рядов на общее число рядов; (@)) вернет таблицу c четырьми столбцами:\n\n\nназвание файла (id),\nчисло рядов (total),\nчисло рядов без NA (complete),\nдоля полных рядов (ratio).\n\nСначала создаем таблицу, в которую будем складывать результат.\n\nmy_files_short &lt;- list.files(\"../files/HP\", pattern = \".csv\")\n\nmy_df &lt;- data.frame(id = my_files_short, \n                    total = rep(0, length(my_files)),\n                    complete = rep(0, length(my_files)),\n                    ratio = rep(0, length(my_files)))\n\nmy_df\n\n\n  \n\n\n\nТеперь тело цикла:\n\nfor (i in 1:length(my_files)) {\n\n  # читаем очередной файл из my_files\n  current_file &lt;- my_files[i]\n  current_df &lt;- readr::read_csv(current_file, show_col_types = FALSE) \n\n  # выявляем общее число рядов и число рядов без NA в BNB number\n  # из-за пробела в названии столбца BNB number нужно использовать\n  # с бэктиками ``, а не с \"такими\" или 'такими' кавычками \n  current_total &lt;- nrow(current_df)\n  current_complete &lt;- sum(!is.na(current_df$`BNB number`))\n    \n\n  # помещаем значения в нужное место в заранее созданном my_df вместо нулей\n  my_df$total[i] &lt;- current_total  \n  my_df$complete[i] &lt;- current_complete\n  my_df$ratio[i] &lt;- current_complete / current_total\n}\n\nСмотрим на результат.\n\nmy_df\n\n\n  \n\n\n\n\n\n4.5.2 map_()\nТеперь исследуем датасет при помощи функционалов. Прочитаем все файлы одним вызовом функции.\n\n# чтение файлов \nHP &lt;- map(my_files, read_csv, col_types = cols())\n\nОбъект HP – это список. В нем пять элементов, так как на входе у нас было пять файлов. Для удобства назначим имена элементам списка.\n\nnames(HP) &lt;- my_files_short\n\n\nНачнем с простого: при помощи map можно извлечь столбцы (по имени) или ряды (по условию) из всех пяти таблиц. Прежде чем выполнить код ниже, подумайте, как будет выглядеть результат.\n\n# извлечь столбцы\nmap(HP, select, `BNB number`)\n\n# извлечь ряды\nmap(HP, filter, !(is.na(`BNB number`)))\n\n\n\n\n\n\n\nЗадание\n\n\n\nИзвлеките все уникальные названия (столбец Title) из всех пяти таблиц в HP. Используйте функцию distinct.\n\n\nЧто, если мы не знаем заранее, какие столбцы есть во всех пяти таблицах, и хотим это выяснить? Для этого подойдет функция reduce() из того же purrr. Она принимает на входе вектор (или список) и функцию и применяет функцию последовательно к каждой паре значений.\n\n\n\nИсточник.\n\n\n\nВоспользуемся этим, чтобы найти общие для всех таблиц имена столбцов.\n\nmap(HP, colnames) |&gt; \n  reduce(intersect)\n\n [1] \"Dewey classification\"       \"BL record ID\"              \n [3] \"Type of resource\"           \"Content type\"              \n [5] \"Material type\"              \"BNB number\"                \n [7] \"ISBN\"                       \"ISSN\"                      \n [9] \"Name\"                       \"Dates associated with name\"\n[11] \"Type of name\"               \"Role\"                      \n[13] \"Title\"                      \"Series title\"              \n[15] \"Number within series\"       \"Country of publication\"    \n[17] \"Place of publication\"       \"Publisher\"                 \n[19] \"Date of publication\"        \"Edition\"                   \n[21] \"Physical description\"       \"BL shelfmark\"              \n[23] \"Genre\"                      \"Languages\"                 \n[25] \"Notes\"                     \n\n\nЕще одна неочевидная возможность функции reduce - объединение нескольких таблиц в одну одним вызовом. Например, так:\n\nHP_joined &lt;- HP |&gt; \n  reduce(left_join)\n\nHP_joined\n\n\n  \n\n\n\n\n\n4.5.3 EDA\nТеперь можно почистить данные и построить несколько разведывательных графиков.\n\nlibrary(ggplot2)\nlibrary(tidyr)\n\ndata_sum &lt;- HP_joined |&gt; \n  separate(`Date of publication`, into = c(\"year\", NA)) |&gt; \n  separate(`Country of publication`, into = c(\"country\", NA), sep = \";\") |&gt;\n  mutate(country = str_squish(country)) |&gt; \n  mutate(country = \n           case_when(country == \"England\" ~ \"United Kingdom\",\n                     country == \"Scotland\" ~ \"United Kingdom\",\n                     TRUE ~ country)) |&gt; \n  filter(!is.na(year)) |&gt; \n  filter(!is.na(country)) |&gt; \n  group_by(year, country) |&gt; \n  summarise(n = n()) |&gt; \n  arrange(-n)\n  \n\ndata_sum\n\n\n  \n\n\n\n\ndata_sum |&gt; \n  ggplot(aes(year, n, fill = country)) + \n  geom_col() + \n  xlab(NULL) +\n  theme(axis.text.x = element_text(angle = 90))\n\n\n\n\n\n\n\n\nВ качестве небольшого бонуса к этому уроку построим облако слов. Вектор слов возьмем из столбца Topic.\n\ndata_topics &lt;- HP_joined |&gt; \n  filter(!is.na(Topics)) |&gt; \n  separate(Topics, into = c(\"topic\", NA)) |&gt; \n  mutate(topic = tolower(topic)) |&gt; \n  group_by(topic) |&gt; \n  summarise(n = n()) |&gt; \n  filter(!topic %in% c(\"harry\", \"rowling\", \"potter\", \"children\", \"literary\"))\n\n\npal &lt;- c(\"#f1c40f\", \"#34495e\", \n         \"#8e44ad\", \"#3498db\",\n         \"#2ecc71\")\n\nlibrary(wordcloud)\n\nLoading required package: RColorBrewer\n\npar(mar = c(1, 1, 1, 1))\nwordcloud(data_topics$topic, \n          data_topics$n,\n          min.freq = 3,\n          #max.words = 50, \n          scale = c(3, 0.8),\n          colors = pal, \n          random.color = T, \n          rot.per = .2,\n          vfont=c(\"script\",\"plain\")\n          )\n\n\n\n\n\n\n\n\nИнтерактивное облако слов можно построить с использованием пакета wordcloud2. Сделаем облако в форме шляпы волшебника!\n\n# devtools::install_github(\"lchiffon/wordcloud2\")\nlibrary(wordcloud2)\n\n\nwordcloud2(data_topics, \n           figPath = \"./book/images/Wizard-Hat.png\",\n           size = 1.5,\n           backgroundColor=\"black\",\n           color=\"random-light\", \n           fontWeight = \"normal\",\n)\n\n\nТеперь попробуйте сами.\n\n\n\n\n\n\nЗадание\n\n\n\nПрактическое задание “Алиса в стране чудес”\n\n\n\n# постройте облако слов для \"Алисы в стране чудес\"\n\nlibrary(languageR)\nlibrary(dplyr)\nlibrary(tidytext)\n\n# вектор с \"Алисой\"\nalice &lt;- tolower(alice)\n\n# частотности для слов\nfreq &lt;- as_tibble(table(alice)) |&gt; \n  rename(word = alice)\n\n# удалить стоп-слова\nfreq_tidy &lt;- freq |&gt; \n  anti_join(stop_words) \n# возможно, вы захотите произвести и другие преобразования\n\n# облако можно строить в любой библиотеке\n\n\n\n\n\nWickham, Hadley, и Garrett Grolemund. 2016. R for Data Science. O’Reilly. https://r4ds.had.co.nz/index.html.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Циклы, условия, функции</span>"
    ]
  },
  {
    "objectID": "import.html",
    "href": "import.html",
    "title": "5  Импорт",
    "section": "",
    "text": "5.1 JSON\nФормат JSON (JavaScript Object Notation) предназначен для представления структурированных данных. JSON имеет шесть основных типов данных. Четыре из них - скаляры:\nСтроки, числа и булевы значения в JSON очень похожи на символьные, числовые и логические векторы в R. Основное отличие заключается в том, что скаляры JSON могут представлять только одно значение. Для представления нескольких значений необходимо использовать один из двух оставшихся типов: массивы и объекты.\nИ массивы, и объекты похожи на списки в R, разница заключается в том, именованы они или нет. Массив подобен безымянному списку и записывается через []. Например, [1, 2, 3] - это массив, содержащий 3 числа, а [null, 1, \"string\", false] - массив, содержащий ноль, число, строку и булево значение.\nОбъект подобен именованному списку и записывается через {}. Имена (ключи в терминологии JSON) являются строками, поэтому должны быть заключены в кавычки. Например, {“x”: 1, “y”: 2} - это объект, который сопоставляет x с 1, а y – с 2.\nЗагрузим небольшой файл TBBT.json, хранящий данные о сериале “Теория большого взрыва” (источник). Скачать лучше из репозитория курса ссылка.\nlibrary(jsonlite)\n\npath &lt;- \"../files/TBBT.json\"\ntbbt &lt;- fromJSON(txt =  path,\n                 simplifyVector = T)\nФункция fromJSON() вернула нам список, в предпросмотре он выглядит так.\nВыборочно преобразуем список в тиббл:\nlibrary(tidyverse)\n\ncast_tbl &lt;- tbbt$casting |&gt; \n  transpose() |&gt; \n  map(as.character) |&gt; \n  as_tibble()\n\ncast_tbl\nПроделаем то же самое для списка эпизодов, но немного другим способом.\nepisodes_tbl &lt;- tibble(\n  episode_id = map_chr(tbbt$episode_list, pluck, \"episode_id\"),\n  title = map_chr(tbbt$episode_list, pluck, \"title\"))\n\nepisodes_tbl",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Импорт</span>"
    ]
  },
  {
    "objectID": "import.html#json",
    "href": "import.html#json",
    "title": "5  Импорт",
    "section": "",
    "text": "cамый простой тип - null (нуль), который играет ту же роль, что и NA в R. Он представляет собой отсутствие данных;\ncтрока (string) похожа на строку в R, но в ней всегда должны использоваться двойные кавычки;\nчисло аналогично числам в R, при этом поддерживается целочисленная (например, 123), десятичная (например, 123.45) или научная (например, 1,23e3) нотация. JSON не поддерживает Inf, -Inf или NaN;\nлогическое значение аналогично TRUE и FALSE в R, но использует строчные буквы true и false.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nСамостоятельно создайте тиббл, в котором будет храниться количество серий для каждого сезона.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Импорт</span>"
    ]
  },
  {
    "objectID": "import.html#xml",
    "href": "import.html#xml",
    "title": "5  Импорт",
    "section": "5.2 XML",
    "text": "5.2 XML\nXML (от англ. eXtensible Markup Language) — расширяемый язык разметки. Слово “расширяемый” означает, что список тегов не зафиксирован раз и навсегда: пользователи могут вводить свои собственные теги и создавать так называемые настраиваемые языки разметки (Холзнер 2004, 29). Один из таких настраиваемых языков – это TEI (Text Encoding Initiative), о котором будет сказано дальше.\nНазначение языков разметки заключается в описании структурированных документов. Структура документа представляется в виде набора вложенных в друг друга элементов (дерева XML). У элементов есть открывающие и закрывающие теги.\nВсе составляющие части документа обобщаются в пролог и корневой элемент. Корневой элемент — обязательная часть документа, в которую вложены все остальные элементы. Пролог может включать объявления, инструкции обработки, комментарии.\nВ правильно сформированном XML открывающий и закрывающий тег вложенного элемента всегда находятся внутри одного родительского элемента.\nСоздадим простой XML из строки. Сначала идет инструкция по обработке XML (со знаком вопроса), за ней следует объявление типа документа (с восклицательным знаком) и открывающий тег корневого элемента. В этот корневой элемент вложены все остальные элементы.\n\nstring_xml &lt;- '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;!DOCTYPE recipe&gt;\n&lt;recipe name=\"хлеб\" preptime=\"5min\" cooktime=\"180min\"&gt;\n   &lt;title&gt;\n      Простой хлеб\n   &lt;/title&gt;\n   &lt;composition&gt;\n      &lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n      &lt;ingredient amount=\"0.25\" unit=\"грамм\"&gt;Дрожжи&lt;/ingredient&gt;\n      &lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n   &lt;/composition&gt;\n   &lt;instructions&gt;\n     &lt;step&gt;\n        Смешать все ингредиенты и тщательно замесить. \n     &lt;/step&gt;\n     &lt;step&gt;\n        Закрыть тканью и оставить на один час в тёплом помещении. \n     &lt;/step&gt;\n     &lt;step&gt;\n        Замесить ещё раз, положить на противень и поставить в духовку.\n     &lt;/step&gt;\n   &lt;/instructions&gt;\n&lt;/recipe&gt;'\n\nДля работы с xml понадобится установить одноименную библиотеку. Функция xmlTreeParse() создаст R-структуру, представляющую дерево XML.\n\nlibrary(XML)\ndoc &lt;- xmlTreeParse(string_xml)\nclass(doc)\n\n[1] \"XMLDocument\"         \"XMLAbstractDocument\"\n\n\nФункция xmlRoot позволяет извлечь корневой элемент вместе со всеми детьми.\n\nrootnode &lt;- xmlRoot(doc)\nrootnode\n\n&lt;recipe name=\"хлеб\" preptime=\"5min\" cooktime=\"180min\"&gt;\n &lt;title&gt;Простой хлеб&lt;/title&gt;\n &lt;composition&gt;\n  &lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n  &lt;ingredient amount=\"0.25\" unit=\"грамм\"&gt;Дрожжи&lt;/ingredient&gt;\n  &lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n &lt;/composition&gt;\n &lt;instructions&gt;\n  &lt;step&gt;Смешать все ингредиенты и тщательно замесить.&lt;/step&gt;\n  &lt;step&gt;Закрыть тканью и оставить на один час в тёплом помещении.&lt;/step&gt;\n  &lt;step&gt;Замесить ещё раз, положить на противень и поставить в духовку.&lt;/step&gt;\n &lt;/instructions&gt;\n&lt;/recipe&gt;\n\n\nЕсли документ большой, бывает удобнее не распечатывать все дерево, а вывести имена дочерних элементов.\n\nnames(xmlChildren(rootnode))\n\n[1] \"title\"        \"composition\"  \"instructions\"\n\n\nРазмер узла – это число вложенных в него “детей”. Его можно узнать, применив к узлу функцию xmlSize() – или подсчитав число “детей”.\n\nxmlSize(rootnode) == length(xmlChildren(rootnode))\n\n[1] TRUE\n\n\nРаботать с xml можно как с обычным списком, то есть индексировать узлы по имени или по номеру элемента при помощи квадратных скобок. Так мы достаем узел по имени:\n\nrootnode[[\"composition\"]]\n\n&lt;composition&gt;\n &lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n &lt;ingredient amount=\"0.25\" unit=\"грамм\"&gt;Дрожжи&lt;/ingredient&gt;\n &lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n&lt;/composition&gt;\n\n\nА так – по индексу:\n\nrootnode[[2]]\n\n&lt;composition&gt;\n &lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n &lt;ingredient amount=\"0.25\" unit=\"грамм\"&gt;Дрожжи&lt;/ingredient&gt;\n &lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n&lt;/composition&gt;\n\n\nКак и с обычными списками, мы можем использовать последовательности квадратных скобок:\n\ningr_node &lt;- rootnode[[2]][[\"ingredient\"]]\ningr_node\n\n&lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n\n\nНо обычно нам нужен не элемент как таковой, а его содержание (значение). Чтобы добраться до него, используем функцию xmlValue():\n\nxmlValue(ingr_node)\n\n[1] \"Мука\"\n\n\nМожно уточнить атрибуты узла при помощи xmlAttrs():\n\nxmlAttrs(ingr_node)\n\n  amount     unit \n     \"3\" \"стакан\" \n\n\nЧтобы извлечь значение атрибута, используем функцию xmlGetAttr(). Первым аргументом функции передаем xml-узел, вторым – имя атрибута.\n\nxmlGetAttr(ingr_node, \"unit\")\n\n[1] \"стакан\"\n\n\nКак насчет того, чтобы применить функцию к набору узлов – например, ко всем инредиентам? Вспоминаем функции для работы со списками – sapply() из базового R или map() из пакета purrr:\n\ningr_nodes &lt;- xmlChildren(rootnode[[2]])\n\nsapply(ingr_nodes, xmlValue)\n\n   ingredient    ingredient    ingredient \n       \"Мука\"      \"Дрожжи\" \"Тёплая вода\" \n\n\n\nsapply(ingr_nodes, xmlGetAttr, \"unit\")\n\ningredient ingredient ingredient \n  \"стакан\"    \"грамм\"   \"стакан\" \n\n\nДобраться до узлов определенного уровня можно также при помощи синтаксиса XPath. XPath – это язык запросов к элементам XML-документа. С его помощью можно описать “путь” до нужного узла: абсолютный (начиная с корневого элемента) или относительный. В пакете XML синтаксис XPath поддерживает функция getNodeSet().\n\n# абсолютный путь\ningr_nodes &lt;- getNodeSet(rootnode, \"/recipe//composition//ingredient\")\n\ningr_nodes\n\n[[1]]\n&lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n\n[[2]]\n&lt;ingredient amount=\"0.25\" unit=\"грамм\"&gt;Дрожжи&lt;/ingredient&gt;\n\n[[3]]\n&lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n\n\n\n# относительный путь\ningr_nodes &lt;- getNodeSet(rootnode, \"//composition//ingredient\")\n\ningr_nodes\n\n[[1]]\n&lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n\n[[2]]\n&lt;ingredient amount=\"0.25\" unit=\"грамм\"&gt;Дрожжи&lt;/ingredient&gt;\n\n[[3]]\n&lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n\n\n\n\n\n\n\n\n\nНа заметку\n\n\n\nВ большинстве случаев функция getNodeSet() требует задать пространство имен (namespace), но в нашем случае оно не определено, поэтому пока передаем только дерево и путь до узла. С пространством имен встретимся чуть позже!\n\n\n\nСинтаксис XPath позволяет отбирать узлы с определенными атрибутами. Допустим, нам нужны только те узлы, где значение атрибута unit = “стакан”:\n\ngetNodeSet(rootnode, \"//composition//ingredient[@unit='стакан']\")\n\n[[1]]\n&lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n\n[[2]]\n&lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n\n\nПри работе с xml в большинстве случаев наша задача – извлечь значения определеннных узлов или их атрибутов и сохранить их в прямоугольном формате.\nВ нашем простом примере это можно сделать несколькими способами. Первый: просто связать воедино несколько векторов.\n\ntitle &lt;- xmlValue(rootnode[[\"title\"]])\ningredients &lt;- map_chr(xmlChildren(rootnode[[\"composition\"]]), xmlValue)\nunit &lt;- map_chr(xmlChildren(rootnode[[\"composition\"]]), xmlGetAttr, \"unit\")\namount &lt;- map_chr(xmlChildren(rootnode[[\"composition\"]]), xmlGetAttr, \"amount\")\n\n\ntibble(title, ingredients, unit, amount)\n\n\n  \n\n\n\nВ некоторых случаях бывает удобно также воспользоваться функциями из пакета xml2 в сочетании с функциями семейства unnest_ из tidyr.\n\nlibrary(xml2)\n\ndoc &lt;- as_list(read_xml(string_xml))\n\n# попробуем достать атрибуты\ndoc |&gt; \n  as_tibble() |&gt; \n  unnest_longer(recipe) |&gt; \n  filter(recipe_id == \"ingredient\") |&gt; \n  mutate(unit = map_chr(recipe, attr, \"unit\")) |&gt; \n  mutate(amount = map_chr(recipe, attr, \"amount\")) |&gt; \n  select(-recipe_id) |&gt; \n  unnest_longer(recipe)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Импорт</span>"
    ]
  },
  {
    "objectID": "import.html#tei",
    "href": "import.html#tei",
    "title": "5  Импорт",
    "section": "5.3 TEI",
    "text": "5.3 TEI\nБольшая часть размеченных литературных корпусов хранится именно в формате XML. Это очень удобно, и вот почему: документы в формате XML, как и документы в формате HTML, содержат данные, заключенные в теги, но если в формате HTML теги определяют оформление данных, то в формате XML теги нередко определяют структуру и смысл данных. С их помощью мы можем достать из документа именно то, что нам интересно: определенную главу, речи конкретных персонажей, слова на иностранных языках и т.п.\nДобавлять и удалять разметку может любой пользователь в редакторе XML кода или даже в простом текстовом редакторе. При этом в качестве универсального языка разметки в гуманитарных дисциплинах используется язык TEI (Скоринкин 2016). Корневой элемент в документах TEI называется TEI, внутри него располагается элемент teiHeader с метаинформацией о документе и элемент text. Последний содержит текст документа с элементами, определяющими его структурное членение.\n&lt;TEI&gt;\n  &lt;teiHeader&gt;&lt;/teiHeader&gt;\n  &lt;text&gt;&lt;/text&gt;\n&lt;/TEI&gt;\nПример оформления документа можно посмотреть по ссылке.\nУ teiHeader есть четыре главных дочерних элемента:\n\nfileDesc (описание документа c библиографической информацией)\nencodingDesc (описание способа кодирование первоисточника)\nprofileDesc (“досье” на текст, например отправитель и получатель для писем, жанр, используемые языки, обстоятельства создания, место написания и т.п.)\nrevisionDesc (история изменений документа)\n\nВ самом тексте язык TEI дает возможность представлять разные варианты (авторские, редакторские, корректорские и др.) Основным средством параллельного представления является элемент choice. Например, в тексте Лукреция вы можете увидеть такое:\nsic calor atque &lt;choice&gt;&lt;reg&gt;aer&lt;/reg&gt;&lt;orig&gt;aër&lt;/orig&gt;&lt;/choice&gt; et venti caeca potestas\nЗдесь reg указывает на нормализованное написание, а orig – на оригинальное.\nВ качестве примера загрузим датасет “Пушкинского дома”, подготовленный Д.А. Скоринкиным: “Персонажи «Войны и мира» Л. Н. Толстого: вхождения в тексте, прямая речь и семантические роли”.\n\nfilename = \"../files/War_and_Peace.xml\"\ndoc &lt;- xmlTreeParse(filename, useInternalNodes = T)\nrootnode &lt;- xmlRoot(doc)\n\nТеперь можно внимательнее взглянуть на структуру xml. Корневой элемент расходится на две ветви. Полностью они нам пока не нужны, узнаем только имена:\n\nnames(xmlChildren(rootnode)) \n\n[1] \"teiHeader\" \"text\"     \n\n\nОчевидно, что что-то для нас интересное будет спрятано в ветке text, глядим на нее:\n\nnames(xmlChildren(rootnode[[\"text\"]])) \n\n[1] \"div\" \"div\" \"div\" \"div\" \"div\"\n\n\nИтак, текст делится на какие-то пять частей. Функция xmlGetAttr() позволяет узнать значение атрибута type: как выясняется, это четыре тома и эпилог.\n\n# это список\ndivs &lt;-  rootnode[[\"text\"]][\"div\"]\n\nsapply(divs, xmlGetAttr, \"type\")\n\n       div        div        div        div        div \n  \"volume\"   \"volume\"   \"volume\"   \"volume\" \"epilogue\" \n\n\nКак мы уже знаем, добраться до определенного узла можно не только путем индексирования, но и – гораздо удобнее – при помощи синтаксиса XPath. Для этого просто указываем путь до узла. Попробуем спуститься на два уровня ниже: там тоже будет тег div, но с другим атрибутом. Как легко убедиться, теперь это главы, всего их 358.\n\ndivs &lt;- getNodeSet(doc, \"/tei:TEI//tei:text//tei:div//tei:div//tei:div\",\n                     namespaces = c(tei = \"http://www.tei-c.org/ns/1.0\")) \n\nlength(divs)\n\n[1] 358\n\nunique(sapply(divs, xmlGetAttr, \"type\"))\n\n[1] \"chapter\"\n\n\nОбратите внимание, что в данном случае надо прямо прописать пространство имен (namespaces). Это можно посмотреть в самом xml, а можно воспользоваться специальной функцией:\n\nxmlNamespace(rootnode)\n\n[1] \"http://www.tei-c.org/ns/1.0\"\nattr(,\"class\")\n[1] \"XMLNamespace\"\n\n\nЗабрать конкретную главу можно путем индексации, но лучше – по значению соответствующего атрибута.\n\nidx &lt;- which(map(divs, xmlGetAttr, \"xml:id\") == \"chapter1part1Volume1\")\nch1 &lt;- divs[[idx]]\n\nЧтобы извлечь текст, понадобится функция xmlValue.\n\nchapter_1 &lt;- xmlValue(ch1)\n\nРаспечатывать весь текст первой главы не будем (это очень длинный вектор); разобъем текст на параграфы и выведем первый и последний:\n\nlibrary(stringr)\nchapter_lines &lt;- str_split(chapter_1, pattern = \"\\n\")\n\nchapter_lines[[1]][[5]]\n\n[1] \"        — Eh bien, mon prince. Gênes et Lueques ne sont plus que des apanages, des поместья, de la famille Buonaparte. Non, je vous préviens que si vous ne me dites pas que nous avons la guerre, si vous vous permettez encore de pallier toutes les infamies, toutes les atrocités de cet Antichrist (ma parole, j'y crois) — je ne vous connais plus, vous n'êtes plus mon ami, vous n'êtes plus мой верный раб, comme vous dites. Ну, здравствуйте, здравствуйте. Je vois que je vous fais peur, садитесь и рассказывайте.\"\n\nchapter_lines[[1]][[838]]\n\n[1] \"       Ce sera dans votre famille que je ferai mon apprentissage de vieille fille.\"\n\n\nПервая и последняя реплика по-французски: все правильно!\n\n\n\n\n\n\nЗадание\n\n\n\nСкачайте по ссылке “Горе от ума” Грибоедова и преобразуйте xml в прямоугольный формат таким образом, чтобы для каждой реплики был указан акт, сцена и действующее лицо.\n\n\nПодбробнее о структуре XML документов и способах работы с ними вы можете прочитать в книгах: (Nolan и Lang 2014) и (Холзнер 2004).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Импорт</span>"
    ]
  },
  {
    "objectID": "import.html#бонус-gutenbergr",
    "href": "import.html#бонус-gutenbergr",
    "title": "5  Импорт",
    "section": "5.4 Бонус: GutenbergR",
    "text": "5.4 Бонус: GutenbergR\nПакет GutenbergR поможет достать тексты из библиотеки Gutenberg, но будьте осторожны: распознаны они не всегда хорошо и порой содержат много разного шума, например примечания редактора, номера страниц и т.п. В билингвах источник и перевод могут идти вперемешку. И если в XML подобные элементы будут окружены соответствующими тегами, которые позволят их легко отбросить при анализе, то Gutenberg дает вам сырой текст. Часто его надо хорошенько чистить при помощи регулярных выражений или даже вручную.\nРаботать с метаданными GutenbergR вы уже научились, теперь можете пользоваться пакетом и для скачивания текстов. Сначала узнаем id нужных текстов^ [https://cran.r-project.org/web/packages/gutenbergr/vignettes/intro.html]\n\nlibrary(gutenbergr)\n\ncaesar &lt;- gutenberg_works(author == \"Caesar, Julius\", languages = \"la\") \n\ncaesar \n\n\n  \n\n\n\nЧтобы извлечь отдельный текст (тексты):\n\nde_bello_gallico &lt;- gutenberg_download(218, meta_fields = \"title\", mirror = \"ftp://mirrors.xmission.com/gutenberg/\")\nde_bello_gallico\n\n\n  \n\n\n\n\n\n\n\n\n\nНа заметку\n\n\n\nСуществует несколько зеркал библиотеки Gutenberg, и, если при выполнении функции gutenberg_download() возникает ошибка “could not download a book at http://aleph.gutenberg.org/”, то следует использовать аргумент mirror. Список зеркал доступен по ссылке: https://www.gutenberg.org/MIRRORS.ALL\n\n\n\n\n\n\nNolan, D., и D. T. Lang. 2014. XML and Web Technologies for Data Science with R. Springer.\n\n\nСкоринкин, Даниил. 2016. «Электронное представление текста с помощью стандарта разметки TEI», 90–108.\n\n\nХолзнер, Стивен. 2004. Энциклопедия XML. Питер.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Импорт</span>"
    ]
  },
  {
    "objectID": "share.html",
    "href": "share.html",
    "title": "6  Публикация",
    "section": "",
    "text": "6.1 О воспроизводимости\nПолученный в результате количественных исследований результат должен быть проверяем и воспроизводим. Это значит, что в большинстве случаев недостаточно просто рассказать, что вы проделали. Теоретически читатель должен иметь возможность проделать тот же путь, что и автор: вопроизвести его результаты, но в обратном направлении.\nДля этого должны выполняться три основных требования:\nУже на этапе планирования исследования очень важно продумать, как вы будете его документировать. Важно помнить, что код пишется не только для машин, но и для людей, поэтому стоит документировать не только то, что вы делали, но и почему. R дает для этого множество возможностей, главная из которых – это Markdown.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Публикация</span>"
    ]
  },
  {
    "objectID": "share.html#о-воспроизводимости",
    "href": "share.html#о-воспроизводимости",
    "title": "6  Публикация",
    "section": "",
    "text": "На заметку\n\n\n\nВоспроизводимость (reproducibility) – это не то же, что повторяемость (replicability). Ученый, который повторяет исследование, проводит его заново на новых данных. Воспроизведение – гораздо более скромная задача, не требующая таких ресурсов, как повторение (Winter 2020, 47).\n\n\n\n\nдоступность данных и метаданных;\nдоступность компьютерного кода;\nдоступность программного обеспечения.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Публикация</span>"
    ]
  },
  {
    "objectID": "share.html#markdown",
    "href": "share.html#markdown",
    "title": "6  Публикация",
    "section": "6.2 Markdown",
    "text": "6.2 Markdown\nMarkdown – это облегчённый язык разметки. Он позволяет создавать документы разного формата – не только HTML (веб-страницы), но и PDF и Word. Markdown дает возможность создания полностью воспроизводимых документов, сочетающих код и поясняющий текст. Этот язык используется для создания сайтов, статей, книг, презентаций, отчетов, дашбордов и т.п. Этот курс написан с использованием Markdown.\nЧтобы начать работать с документами .rmd, нужен пакет rmarkdown; в RStudio он уже предустановлен. Создание нового документа .rmd происходит из меню.\nПо умолчанию документ .rmd снабжен шапкой yaml. Она не обязательна. Здесь содержатся данные об авторе, времени создания, формате, сведения о файле с библиографией и т.п.\n---\ntitle: \"Demo\"\nauthor: \"My name\"\ndate: \"2024-08-17\"\noutput: html_document\n---\nТакже в документе .rmd скорее всего будет простой текст и блоки кода. Чтобы “сшить” html (pdf, doc), достаточно нажать кнопку knit либо запустить в консоли код: rmarkdown::render(\"Demo.Rmd\"). После этого в рабочей директории появится новый файл (html, pdf, или doc), которым можно поделиться с коллегами, грантодателями или друзьями.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Публикация</span>"
    ]
  },
  {
    "objectID": "share.html#quarto",
    "href": "share.html#quarto",
    "title": "6  Публикация",
    "section": "6.3 Quarto",
    "text": "6.3 Quarto\nРаботать с маркдауном мы будем, используя издательскую систему Quarto с открытым исходным кодом. Она позволяет создавать и публиковать статьи, презентации, информационные панели, веб-сайты, блоги и книги в HTML, PDF, MS Word, ePub и других форматах. В общем, обычный Markdown тоже позволяет все это делать, но чуть сложнее. Quarto объединяет различные пакеты из экосистемы R Markdown воедино и значительно упрощает работу с ними.\n\n\n\n\n\n\nЗадание\n\n\n\nСоздайте новый .qmd документ. Потренируйтесь запускать код и сшивать документ в .html, .pdf, .docx.\n\n\nДля .pdf может понадобиться установка LaTeX.\n\n# install.packages(\"tinytex\")\ntinytex::install_tinytex()\n# to uninstall TinyTeX, run\n# tinytex::uninstall_tinytex()\n\nМожно указать сразу несколько форматов для файла, как показано здесь, и “сшить” их одновременно:\n\nquarto::quarto_render(\n  \"untitled.qmd\", \n  output_format = c(\"pdf\", \"html\", \"docx\")\n)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Публикация</span>"
    ]
  },
  {
    "objectID": "share.html#шапка-yaml",
    "href": "share.html#шапка-yaml",
    "title": "6  Публикация",
    "section": "6.4 Шапка YAML",
    "text": "6.4 Шапка YAML\nОсновные параметры документа хранятся в YAML-шапке. К ним относятся format, title, subtitle, date, date-format, author, abstract, lang, toc, number-sections и другие.\nПопробуйте изменить шапку своего .qmd-документа и заново его сшить. Сравните с предыдущей версией.\n---\ntitle: \"Заголовок\"\nsubtitle: \"Подзаголовок\"\nformat: html\nauthor: locusclassicus\ndate: today\ndate-format: D.MM.YYYY\nabstract: Значенье бублика нам непонятно.\nlang: ru\ntoc: true\nnumber-sections: true\n---\n\nПоле execute позволяет задать параметры всех фрагментов кода в документе, например:\n---\nexecute:\n  echo: false\n  fig-width: 9\n---\n  \nНо для отдельных кусков кода эти настройки можно поменять:\n```\n#| echo: true\n\nsqrt(16)\n```\nПараметр df-print позволяет выбрать один из возможных способов отображения датафреймов:\n\ndefault — стандартный, как в консоли;\ntibble — стандартный, как в консоли, но в формате tibble;\nkable — минималистичный вариант, подходит для всех видов документов;\npaged — интерактивная таблица, подходит для html страниц.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Публикация</span>"
    ]
  },
  {
    "objectID": "share.html#синтаксис-markdown",
    "href": "share.html#синтаксис-markdown",
    "title": "6  Публикация",
    "section": "6.5 Синтаксис Markdown",
    "text": "6.5 Синтаксис Markdown\n\n6.5.1 Заголовки\nЗаголовки разного уровня задаются при помощи решетки:\n# Заголовок первого уровня\n## Заголовок второго уровня\n### Заголовок третьего уровня\n#### Заголовок четвёртого уровня\nПример заголовка третьего уровня:\n\n\n6.5.2 Форматирование\n*курсив*  \n_курсив_\n\n**полужирный**  \n__полужирный__\n\n***полужирный курсив***  \n___полужирный курсив___\n\n~~зачеркнутый~~\n\n&lt;mark&gt;выделение&lt;/mark&gt;\nПример:\nкурсив\nполужирный\nуж и не знаю как выделить\nзачеркнутый\nвыделение\n\n\n6.5.3 Списки\nНумерованный список\n1. Пункт первый\n2. Пункт второй\n3. Пункт третий\nПример:\n\nПункт первый\nПункт второй\nПункт третий\n\nМаркированный список\n- Пункт первый\n- Пункт второй\n- Пункт третий\nПример:\n\nПункт первый\nПункт второй\nПункт третий\n\nТакже Markdown позволяет делать вложенные списки:\n1. Пункт первый\n    - Подпункт первый\n    - Подпункт второй\n2. Пункт второй\nПример:\n\nПункт первый\n\nПодпункт первый\nПодпункт второй\n\nПункт второй\n\nСамое удобное, что элементы списка не обязательно нумеровать:\n(@) Пункт первый.\n(@) Пункт не знаю какой.\n\nПункт первый.\nПункт не знаю какой.\n\n\n\n6.5.4 Ссылки\n[Текст ссылки](http://antibarbari.ru/)\nПример:\nТекст ссылки\n\n\n6.5.5 Изображения\n![Текст описания](http://antibarbari.ru/wp-content/uploads/2023/03/corderius-656x300.png)\nПример:\n\n\n\nМоя картинка\n\n\nДва нюанса:\n\nможно давать ссылки на локальные файлы (то есть такие файлы, которые хранятся на компьютере), но имейте в виду, что такой код не будет работать у другого пользователя;\nизображения можно вставлять, пользуясь непосредственно разметкой html.\n\n&lt;img src=\"images/my_image.jpg\" width=40%&gt;\n\n\n6.5.6 Блоки кода\nМожно вставлять непосредственно в текст; для этого код выделяют одинарным обратным апострофом (грависом). Но чаще код дают отдельным блоком. Эти блоки можно именовать; тогда в случае ошибки будет сразу понятно, где она случилась.\n```{}\nsome code here\n```\nВ фигурных скобках надо указать язык, например {r}, только в этом случае код будет подсвечиваться и выполняться.\nТам же в фигурных скобках можно задать следующие параметры:\n\neval = FALSE код будет показан, но не будет выполняться;\ninclude = FALSE код будет выполнен, но ни код, ни результат не будут показаны;\necho = FALSE код будет выполнен, но не показан, результаты при этом видны;\nmessage = FALSE или warning = FALSE прячет сообщения или предупреждения;\nresults = 'hide' не распечатывает результат, а fig.show = 'hide' прячет графики;\nerror = TRUE “сшивание” продолжается, даже если этот блок вернул ошибку.\n\n\n\n6.5.7 Цитаты\n&gt; Omnia praeclara rara.\nПример:\n\nOmnia praeclara rara.\n\nЦитата с подписью может быть оформлена так:\n&gt; Omnia praeclara rara.\n&gt;\n&gt; --- Cicero\nПример:\n\nOmnia praeclara rara.\n— Cicero\n\n\n\n6.5.8 Разделители\nЧтобы создать горизонтальную линию, можно использовать ---, *** или ___.\nПример:\n\n\n\n6.5.9 Таблицы\nТаблицы можно задать вручную при помощи дефисов - и вертикальных линий |; идеальная точность при этом не нужна. Перед таблицей обязательно оставляйте пустую строку, иначе волшебство не сработает.\n\n| Фрукты   | Калории  |\n| -----  | ---- |\n| Яблоко   | 52  |\n| Апельсин | 47  |\nПример:\n\n\n\nФрукты\nКалории\n\n\n\n\nЯблоко\n52\n\n\nАпельсин\n47\n\n\n\nПо умолчанию Markdown распечатывает таблицы так, как они бы выглядели в консоли.\n\ndata(\"iris\")\nhead(iris)\n\n\n  \n\n\n\nДля дополнительного форматирования можно использовать функцию knitr::kable():\n\nknitr::kable(iris[1:6, ], caption = \"Таблица knitr\")\n\n\nТаблица knitr\n\n\nSepal.Length\nSepal.Width\nPetal.Length\nPetal.Width\nSpecies\n\n\n\n\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n5.4\n3.9\n1.7\n0.4\nsetosa\n\n\n\n\n\nИнтерактивную таблицу можно создать так:\n\nDT::datatable(iris[1:6,])\n\n\n\n\n\n\n\n6.5.10 Чек-листы\n- [x] Таблицы\n- [ ] Графики\nПример:\n\nТаблицы\nГрафики\n\n\n\n6.5.11 Внутренние ссылки\nУдобны для навигации по документу. К названию любого раздела можно добавить {#id}.\n[Вернуться к чек-листам](#id)\nПример:\nВернуться к чек-листам\n\n\n6.5.12 Графики\nMarkdown позволяет встраивать любые графики.\n\nlibrary(ggplot2)\nggplot(aes(x = Sepal.Length, y = Petal.Length, col = Species), data = iris) +\n  geom_point(show.legend = F)\n\n\n\n\n\n\n\n\nДля интерактивных графиков понадобится пакет plotly:\n\nlibrary(plotly)\nplot_ly(data=iris, x = ~Sepal.Length, y = ~Petal.Length, color = ~Species)\n\n\n\n\n\nПодробное руководство по созданию интерактивных графиков можно найти на сайте https://plotly.com/r/.\n\n\n6.5.13 Математические формулы\nПишутся с использованием синтаксиса LaTeX, о котором можно прочитать подробнее здесь.\nФормулы заключаются в одинарный $, если пишутся в строку, и в двойной $$, если отдельным блоком.\n\\cos (2\\theta) = \\cos^2 \\theta - \\sin^2 \\theta\nВот так это выглядит в тексте: \\(\\cos (2\\theta) = \\cos^2 \\theta - \\sin^2 \\theta\\).\nА вот так – блоком:\n\\[\\cos (2\\theta) = \\cos^2 \\theta - \\sin^2 \\theta\\]\n\n\n6.5.14 Смайлы\nУдобнее вставлять через визуальный редактор (“шестеренка” &gt; Use Visual Editor), но можно и без него:\n\n# devtools::install_github(\"hadley/emo\")\nlibrary(emo)\nemo::ji(\"apple\")\n\n🍎 \n\n\nКод можно записать в строку, тогда смайл появится в тексте: 💀.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Публикация</span>"
    ]
  },
  {
    "objectID": "share.html#библиография",
    "href": "share.html#библиография",
    "title": "6  Публикация",
    "section": "6.6 Библиография",
    "text": "6.6 Библиография\nMarkdown позволяет добавлять библиографию в формате BibTeX. BibTeX — программное обеспечение для создания форматированных списков библиографии; обычно используется совместно с LaTeX’ом. Многие сайты, например GoogleScholar, позволяют экспортировать библиографические записи в формате BibTeX. При необходимости запись можно исправить вручную.\nКаждая запись имеет следующую форму.\n@book{winter2020,\n  author = {Bodo Winter},\n  title = \"{Statistics for Linguists: An Introduction Using R}\",\n  year = {2020},\n  publisher = {Routledge}\n}\nЗдесь book — тип записи («книга»), winter2020 — метка-идентификатор записи, дальше список полей со значениями.\nОдна запись описывает ровно одну публикацию статью, книгу, диссертацию, и т. д. Подробнее о типах записей можно посмотреть вот здесь.\nПодобные записи хранятся в текстовом файле с расширением .bib. Чтобы привязать библиографию, нужно указать имя файла в шапке yaml.\n---\nbibliography: bibliography.bib\n---\nДальше, чтобы добавить ссылку, достаточно ввести ключ публикации после @ (в квадратных скобках, чтобы публикация отражалась в круглых): [@wickham2016].\nПример:\n(Wickham и Grolemund 2016).\nМожно интегрировать BibTex с Zotero или другим менеджером библиографии. Для этого придется установить специальное расширение.\nЧтобы изменить стиль цитирования, необходимо добавить в шапку yaml название csl-файла (CSL - Citation Style Language), например:\n---\noutput: html_document\nbibliography: references.bib\ncsl: archiv-fur-geschichte-der-philosophie.csl\n---\nНайти необходимый csl-файл можно, например, в репозитории стилей Zotero.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Публикация</span>"
    ]
  },
  {
    "objectID": "share.html#публикация-html",
    "href": "share.html#публикация-html",
    "title": "6  Публикация",
    "section": "6.7 Публикация html",
    "text": "6.7 Публикация html\nДля публикации на RPubs понадобится установить пакеты packrat, rsconnect.\n\n\n\n\nWickham, Hadley, и Garrett Grolemund. 2016. R for Data Science. O’Reilly. https://r4ds.had.co.nz/index.html.\n\n\nWinter, Bodo. 2020. Statistics for Linguists: An Introduction Using R. Routledge.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Публикация</span>"
    ]
  },
  {
    "objectID": "share.html#footnotes",
    "href": "share.html#footnotes",
    "title": "6  Публикация",
    "section": "",
    "text": "https://rmarkdown.rstudio.com/↩︎\nhttps://docs.posit.co/how-to-guides/rsc/publish-rmd/↩︎\nhttps://www.markdownguide.org/basic-syntax/↩︎\nhttps://r4ds.had.co.nz/r-markdown.html#chunk-name↩︎\nhttps://github.com/hadley/emo↩︎",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Публикация</span>"
    ]
  }
]