[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Компьютерный анализ текста",
    "section": "",
    "text": "Введение",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#об-этом-курсе",
    "href": "index.html#об-этом-курсе",
    "title": "Компьютерный анализ текста",
    "section": "Об этом курсе",
    "text": "Об этом курсе\nЭтот сайт содержит материалы к курсу “Компьютерный анализ текста в R” для магистерской программы НИУ ВШЭ “Цифровые методы в гуманитарных науках”. Предыдущую версию курса можно найти здесь.\nИ тексты, и инструменты для работы с ними подобраны таким образом, чтобы помочь студентам гуманитарных специальностей (филологам, философам, историкам и др.) как можно быстрее, но с полным пониманием дела перейти к применению количественных методов в собственной работе.\nЧтобы лучше понимать, какие из этих методов более всего востребованы в научной работе, преподаватели магистратуры “Цифровые методы в гуманитарных науках” – Б.В. Орехов, А.А. Осмоловская и О.В. Алиева – организовали в 2024 г. серию встреч с ведущими представителями отрасли. Видео этих встреч и литературу к семинарам можно найти на сайте http://criticaldh.ru/.\nТам мы собрали именно теоретические обсуждения и литературу к ним, а в этом курсе предлагаем приступить к практике DH (на языке R). Оба этих аспекта, в нашем представлении и в программе магистратуры тесно связаны: одного программирования не хватит, чтобы стать “цифровым гуманистом”, а теории недостаточно, чтобы судить об успешности тех или иных цифровых проектов. Поэтому этот курс старается стоять на двух ногах и соединять кодинг с теоретической рефлексией. Это почти невыполнимая задача но когда нам это мешало.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#ресурсы",
    "href": "index.html#ресурсы",
    "title": "Компьютерный анализ текста",
    "section": "Ресурсы",
    "text": "Ресурсы\nИ в теоретическом, и в практическом плане курс опирается на огромную работу, уже проделанную преподавателями магистратуры ЦМГН. Важнейшие наши достижения собрал Б.В. Орехов: https://github.com/nevmenandr/awesome-dh-hse. Здесь вы найдете ссылки на видео, научно-популярные и научные публикации и датасеты.\nЕсли вдруг вам не хватит практических заданий по R, то в качестве дополнения к оффлайн-курсу можно рекомендовать онлайн-курс Георгия Мороза “Введение в анализ данных на R для гуманитарных и социальных наук”. К этому курсу прилагается онлайн-ноутбук (https://agricolamz.github.io/daR4hs/) с комментариями и всем кодом, и он полностью открыт. Надо иметь в виду, однако, что онлайн-курс рассчитан всего на 9 недель, в то время как наш – на два семестра, так что его можно использовать лишь как вспомогательный ресурс, но не замену.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#программа",
    "href": "index.html#программа",
    "title": "Компьютерный анализ текста",
    "section": "Программа",
    "text": "Программа\nКурс 2024/2025 г. включает в себя три основных блока и 22 темы (некоторые темы рассчитаны на 2-3 недели, всего 32 недели). Программа носит предварительный характер и может быть чуть изменена.\nЧасть 1. Основы работы в R\n\nЗнакомство с R и RStudio. Начало работы. Объекты, функции, операторы.\nВизуализация данных: базовый R, lattice, ggplot2.\nТрансформация данных. «Опрятные» данные с dplyr и tidyverse.\nУсловия и циклы. Написание собственных функций. Итерации с purrr.\nИмпорт данных. Импорт данных из XML.\nВоспроизводимые исследования. RMarkdown. Quarto.\nРегулярные выражения: базовый R и stringr.\nHTML. Веб-скрапинг.\n\nЧасть 2. Методы анализа текста\n\nТокенизация. Морфологический и синтаксический анализ.\nАнализ эмоциональной тональности (метод словарей).\nРаспределения слов и анализ частотностей.\nТематическое моделирование (LDA).\nЛатентно-семантический анализ. Векторные модели.\nАнализ текста с помощью сетей (графов). Описание и анализ графов.\nПространство и время: геоданные и временные ряды.\n\nЧасть 3. Машинное обучение и нейросети\n\nОбучение без учителя: иерархическая кластеризация и метод k-средних.\nПростая и множественная линейная регрессия.\nАлгоритмы для бинарной и многоклассовой классификации.\n\nДеревья решений и правил. Бэггинг, случайные леса, бустинг.\nПротоколы проверки моделей. Проблема переобучения.\nКонструирование признаков. Методы снижения размерности.\nМетоды “черного ящика”: опорные векторы и нейросети.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#оценивание",
    "href": "index.html#оценивание",
    "title": "Компьютерный анализ текста",
    "section": "Оценивание",
    "text": "Оценивание\nДомашние задания выполняются в GitHub Classroom. Еженедельно выполняются небольшие задания, которые оцениваются по бинарной шкале (1/0), раз в месяц – консолидирующие задания на весь пройденный материал (оценка 0-10). Все необходимые ссылки вы найдете в чате курса в Telegram.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#благодарности",
    "href": "index.html#благодарности",
    "title": "Компьютерный анализ текста",
    "section": "Благодарности",
    "text": "Благодарности\nЗа помощь в разработке курса и подготовке датасетов к нему автор благодарит Георгия Мороза и Бориса Орехова.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "index.html#обратная-связь",
    "href": "index.html#обратная-связь",
    "title": "Компьютерный анализ текста",
    "section": "Обратная связь",
    "text": "Обратная связь\nЕсли вы заметили ошибку или опечатку, можно писать на адрес oalieva@hse.ru.",
    "crumbs": [
      "Введение"
    ]
  },
  {
    "objectID": "start.html",
    "href": "start.html",
    "title": "1  Начало работы",
    "section": "",
    "text": "1.1 Установка R и RStudio\nМы будем использовать R, так что для занятий понадобятся:\nМы будем использовать следующую версию R:\nR version 4.3.3 (2024-02-29)\nНекоторые люди не любят устанавливать лишние программы себе на компьютер, несколько вариантов есть и для них:",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#установка-r-и-rstudio",
    "href": "start.html#установка-r-и-rstudio",
    "title": "1  Начало работы",
    "section": "",
    "text": "R\n\nна Windows\nна Mac\nна Linux.\n\nRStudio — IDE для R (можно скачать здесь)\n\n\n\n\n\nRStudio cloud — полная функциональность RStudio с некоторыми ограничениями;\nwebR REPL — ограниченная версия компилятора R, которая работает в вашем браузере и не требует никаких установок на компьютер\nJupyter ноутбуки;\nGoogle Colab (нужно в настройках переключить ядро);\nVS Code — другое IDE, которое также позволяет работать с R;\nв принципе, в IDE нет нужды, можно работать из терминала, после установки, нужно всего лишь набрать R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#знакомство-с-rstudio",
    "href": "start.html#знакомство-с-rstudio",
    "title": "1  Начало работы",
    "section": "1.2 Знакомство с RStudio",
    "text": "1.2 Знакомство с RStudio\nRStudio — основная среда разработки (IDE) для R. После установки R и RStudio можно открыть RStudio и перед вами предстанет что-то похожее на изображение ниже:\n\n\n\nRStudio при первом открытии\n\n\nПосле нажатия на двойное окошко чуть левее надписи Environment откроется окно скрипта.\n\n\n\nПодокна RStudio\n\n\nВсе следующие команды можно:\n\nвводить в окне консоли, и тогда для исполнения следует нажимать клавишу Enter.\nвводить в окне скрипта, и тогда для исполнения следует нажимать клавиши Ctrl/Cmd + Enter или на команду Run на панели окна скрипта. Все, что введено в окне скрипта можно редактировать как в любом текстовом редакторе, в том числе сохранять Ctrl/Cmd + S.\n\nДля начала попробуйте получить информацию о сессии, введя в консоли такую команду:\n\nsessionInfo()\n\nsessionInfo() – это функция. О функциях можно думать как о глаголах (“сделай то-то!”). За названием функции всегда следуют круглые скобки, внутри которых могут находиться аргументы функции. Аргументы – это что-то вроде дополнений и обстоятельств. Аргументы могут быть обязательные и необязательные. Чтобы узнать, каких аргументов требует функция, надо вызывать help: ?mean(). В правой нижней панели появится техническая документация. Но также можно воспользоваться функцией args(). Попробуйте набрать в консоли args(round).\n\n\n\n\n\n\nВопрос\n\n\n\nСколько аргументов функции round() имеют значения по умолчанию?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#пакеты-и-виньетки",
    "href": "start.html#пакеты-и-виньетки",
    "title": "1  Начало работы",
    "section": "1.3 Пакеты и виньетки",
    "text": "1.3 Пакеты и виньетки\nПосле установки R вы получите доступ к уже готовым методам статистического анализа и инструментам для визуализации. Если в базовой инсталляции R нет нужного решения – надо поискать в библиотеке пакетов. Пакет – это набор функций и иногда датасетов, созданный пользователями. На 1 июля 2023 г. в репозитории CRAN доступно 19789 пакетов. И это далеко не все: многие пакеты доступны только на GitHub.\n\n\n\n\n\n\nНа заметку\n\n\n\nНекоторые функции, которые вы найдете в пакетах, частично дублируют друг друга – это нормально, как и в естественном языке, “сказать” что-то можно разными способами.\n\n\nПо технической документации и так называемым “виньеткам” можно понять, какой пакет вам нужен. Например, вот так выглядит виньетка пакета RPerseus, при помощи которого можно получить доступ к корпусу греческой и латинской литературы.\nБывают еще “пакеты пакетов”, то есть очень большие семейства функций, своего рода “диалекты” R. Таково, например, семейство tidyverse, объединяемое идеологией “опрятных” данных. Про него мы еще будем говорить.\nА если нигде нет нужной функции? Ее следует просто написать. Писать код, как и другие тексты, надо аккуратно и понятно. Рекомендуется использовать пояснения при помощи знака # (как в Python).\n\n# случайный набор чисел 1-1000\nx &lt;- sample(1000, 10)\nx\n\n [1] 302 643 986 188 816 931 316 778 836  44\n\n\nВ этом примере код, правда, настолько простой, что не требует особых пояснений. Но в больших проектах от “читабельности” кода зависит не только то, поймет ли вас потенциальный рецензент, но и сможете ли вы сами вспомнить, какая строчка за что отвечает. Также это позволит вернуться к проекту через некоторое время и быстро вспомнить, что там происходит.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#порядок",
    "href": "start.html#порядок",
    "title": "1  Начало работы",
    "section": "1.4 Порядок",
    "text": "1.4 Порядок\nУточнить свою рабочую директорию (в которой R будет искать и сохранять файлы) можно при помощи функции getwd() без аргументов. Установить рабочую директорию можно при помощи функции setwd(), указав в качестве аргумента путь к рабочей директории на вашем компьютере (в кавычках, так как это символьный вектор).\n\nsetwd(\"/Users/Joe/R_Workflow/\")\n\nТакже для выбора рабочей директории можно использовать меню R Session &gt; Set Working Directory.\nПакеты для работы устанавливаются один раз, однако подключать их надо во время каждой сессии. Чтобы установить новый пакет, можно воспользоваться меню Tools &gt; Install Packages. Также можно устанавливать пакеты из консоли. Установим пакет с интерактивными уроками программирования на языке R:\n\ninstall.packages(\"swirl\")\n\nДля подключения используем функцию library(), которой передаем в качестве аргумента название пакета без кавычек:\n\nlibrary(swirl)\n\nА теперь – первое задание.\n\nУстановите курс программирования на R: install_course(\"R Programming\"). После этого привяжите пакет командой library(swirl) и выполните следующую команду: swirl(). Укажите ваше имя. Пройдите урок 2 Workspace and Files.\n\n После выполнения ответьте на несколько вопросов на закрепление материала.\n\n\n\n\n\n\nВопрос\n\n\n\nКакие действия в рабочей директории можно совершать из консоли?\n\n\n\n\nсоздать директорию\n\n\nудалить директорию\n\n\nсоздать файл\n\n\nпереименовать файл\n\n\nкопировать файл\n\n\nудалить файл\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nЧтобы создать вложенную директорию при помощи функции dir.create(), аргументу recursive следует задать значение…\n\n\n\n\nTRUE\nFALSE\n\n\n\n\n\nЕсли все получилось, двигаемся дальше.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#r-как-калькулятор",
    "href": "start.html#r-как-калькулятор",
    "title": "1  Начало работы",
    "section": "1.4 R как калькулятор",
    "text": "1.4 R как калькулятор\nМожно использовать R как калькулятор. Для этого вводим данные рядом с символом приглашения &gt;, который называется prompt.\n\nsqrt(4) # квадратный корень\n\n[1] 2\n\n2^3 # степень\n\n[1] 8\n\nlog10(100) #логарифм\n\n[1] 2\n\n\nЕсли в начале консольной строки стоит +, значит предыдущий код не завершен. Например, вы забыли закрыть скобку функции. Ее можно дописать на следующей строке. Попробуйте набрать sqrt(2 в консоли.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#операторы-присваивания",
    "href": "start.html#операторы-присваивания",
    "title": "1  Начало работы",
    "section": "1.5 Операторы присваивания",
    "text": "1.5 Операторы присваивания\nЧтобы в окружении появился новый объект, надо присвоить результат вычислений какой-нибудь переменной при помощи оператора присваивания &lt;- (Alt + - (Windows) или Option + - (Mac)). Знак = также работает как оператор присваивания, но не во всех контекстах, поэтому им лучше не пользоваться.\n\nx &lt;- 2 + 2 # создаем переменную\ny &lt;- 0.1 # создаем еще одну переменную\nx &lt;- y # переназначаем  \nx + y\n\n[1] 0.2\n\n\nСочетание клавиш для оператора присваивания: Option/Alt + -. Имя переменной, как и имя функции, может содержать прописные и строчные буквы, точку и знак подчеркивания.\nТеперь небольшое упражнение.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(). Укажите ваше имя. Пройдите урок 1 Basic Building Blocks.\n\n\nЕсли все получилось, можно двигаться дальше! Но сначала зафиксируем несколько новых функций из этих первого урока.\n\n\n\n\n\n\nВопрос\n\n\n\nЧто вычисляет функция abs()?\n\n\n\n\nсреднее\n\n\nмодуль\n\n\nквадратный корень\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nСколько значений вернет функция, если разделить c(2, 4, 6) на 2?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nБуква “c” в названии функции c() означает…\n\n\n\n\ncover\n\n\ncollapse\n\n\nconcatenate",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#пайпы-конвееры",
    "href": "start.html#пайпы-конвееры",
    "title": "1  Начало работы",
    "section": "1.10 Пайпы (конвееры)",
    "text": "1.10 Пайпы (конвееры)\nВ нашем коде мы часто будем использовать знаки конвеера (или пайпы): |&gt; (в вашей версии он может выглядить иначе: %&gt;%; переключить оператор можно в Global Options). Они призваны показывать последовательность действий. Сочетание клавиш: Ctrl/Cmd + M.\n\nmean(sqrt(abs(sin(1:100))))\n\n[1] 0.7654264\n\n1:100 |&gt; \n  sin() |&gt; \n  abs() |&gt; \n  sqrt() |&gt; \n  mean()\n\n[1] 0.7654264",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#векторы",
    "href": "start.html#векторы",
    "title": "1  Начало работы",
    "section": "1.6 Векторы",
    "text": "1.6 Векторы\nВектор – это объект, предназначенный для хранения данных. К таким же объектам относятся также матрицы, списки, таблицы данных и др. Заметим, что в языке R нет скаляров (отдельных чисел). Числа считаются векторами из одного элемента.\n\nx &lt;- 2\nclass(x) # числовой вектор\n\n[1] \"numeric\"\n\nlength(x) # длина вектора\n\n[1] 1\n\n\nКак вы уже поняли, функция c() позволяет собрать несколько элементов в единый вектор:\n\nx &lt;- c(3, 5, 7)\nx_mean &lt;- mean(x) \nx_mean\n\n[1] 5\n\n\n Над векторами можно совершать арифметические операции, но будьте внимательны, применяя операции к векторам разной длины: в этом случае более короткий вектор будет переработан, то есть повторен до тех пор, пока его длина не сравняется с длиной вектора большей длины.\n\nx &lt;- 2\ny &lt;- c(10, 20, 30)\ny / x \n\n[1]  5 10 15\n\nx + y \n\n[1] 12 22 32\n\n\nВекторы можно индексировать, то есть забирать из них какие-то элементы:\n\nx &lt;- seq(1, 5, 0.5)\nx[4:5] # индексы начинаются с 1 (в отличие от Python)\n\n[1] 2.5 3.0\n\n\nВектор может хранить данные разных типов:\n\nцелое число (integer);\nчисло с плавающей точкой (numeric, также называются double, то есть число двойной точности);\nстроку (character);\nлогическую переменную (logical);\nкатегориальную переменную, или фактор (factor).\n\n\n# проверить тип данных \nx &lt;- sqrt(2)\nclass(x)\n\n[1] \"numeric\"\n\nis.integer(x)\n\n[1] FALSE\n\nis.numeric(x)\n\n[1] TRUE\n\n\nСоздавать векторы можно не только при помощи c(). Вот еще два способа.\n\nseq(1, 5, 0.5)\n\n[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0\n\nrep(\"foo\", 5)\n\n[1] \"foo\" \"foo\" \"foo\" \"foo\" \"foo\"\n\n\nНаучиться генерировать векторы поможет небольшое упражнение.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 3 Sequences of Numbers.\n\n\nПроверьте свои знания, прежде чем двигаться дальше.\n\n\n\n\n\n\nВопрос\n\n\n\nКакие числа вернет команда pi:10?\n\n\n\n\nнатуральные\n\n\nцелые\n\n\nрациональные\n\n\nвещественные\n\n\nкомплексные\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКакие функции могут использоваться для создания символьных векторов?\n\n\n\n\nseq()\n\n\nrep()\n\n\nc()\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nСколько значений вернет команда rep(c(0, 1, 2), times = 10)? Посчитайте в уме, не выполняя код.\n\n\n\n\n\n\n\n\n Факторы внешне похожи на строки, но в отличие от них хранят информацию об уровнях категориальных переменных. Уровень может обозначаться как числом (например, 1 и 0), так и строкой.\n\nt &lt;- factor(c(\"A\", \"B\", \"C\"), levels = c(\"A\", \"B\", \"C\"))\nt\n\n[1] A B C\nLevels: A B C\n\n\nВажно: вектор может хранить данные только одного типа. При попытке объединить в единый вектор данные разных типов они будут принудительно приведены к одному типу:\n\nx &lt;- c(TRUE, 1, 3, FALSE)\nx # логические значения приведены к числовым\n\n[1] 1 1 3 0\n\ny &lt;- c(1, \"a\", 2, \"лукоморье\") \ny # числа превратились в строки\n\n[1] \"1\"         \"a\"         \"2\"         \"лукоморье\"\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 4 Vectors. Это позволит больше узнать про логические и символьные векторы.\n\n\nНесколько вопросов для самопроверки.\n\n\n\n\n\n\nВопрос\n\n\n\nКакие значение вернет команда (3 &gt; 5) & (4 == 4)?\n\n\n\n\nTRUE\nFALSE\nNA\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКакие значения вернет команда (TRUE == TRUE) | (TRUE == FALSE)?\n\n\n\n\nTRUE\nFALSE\nNA\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКоманда paste(LETTERS, 1:4, sep = \"-\") вернет…\n\n\n\n\nчисловой вектор длиной 26\n\n\nсимвольный вектор длиной 26\n\n\nчисловой вектор длиной 4\n\n\nсимвольный вектор длиной 4\n\n\nошибку\n\n\n\n\n\n Логические векторы можно получить в результате применения логических операторов (== “равно”, != “не равно”, &lt;= “меньше или равно”) к данным других типов:\n\nx &lt;- c(1:10) # числа от 1 до 10\ny &lt;- x &gt; 5\ny # значения TRUE соответствуют единице, поэтому их можно складывать\n\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nsum(y)\n\n[1] 5\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗдесь можно запустить swirl() и пройти урок 8 Logic. Это не обязательно, но очень полезно, если хотите разобраться в операторах!\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nПопробуйте посчитать в уме: какое из выражений ниже вернет значение TRUE?\n\n\n\n\n7 == 9\n\n\n!(57 != 8)\n\n\n9 &gt;= 10\n\n\n-6 &gt; -7\n\n\n\n\n\nФункции all() и any() также возвращают логические значения:\n\nx &lt;- 10:20 \nany(x == 15)\n\n[1] TRUE\n\nall(x &gt; 9)\n\n[1] TRUE\n\n\nОтсутствие данных любого типа в R передается двумя способами. NULL означает, что значение не существует. Например, если мы создадим пустой вектор, то при попытке распечатать его получим NULL. А вот длина пустого вектора равна нулю!\n\ny &lt;- c() \ny \n\nNULL\n\nlength(y) \n\n[1] 0\n\n\nNA (not available) указывает на то, что значение существует, но оно неизвестно. Любые операции с NA приводят к появлению новых NA! Сравните:\n\nx &lt;- c(1, NA, 2)\nmean(x)\n\n[1] NA\n\ny &lt;- c(1, NULL, 2)\nmean(y)\n\n[1] 1.5\n\n\nКак проверить, есть ли в данных NA или NULL? Знак == здесь не подойдет.\n\nx &lt;- NA\nx == NA\n\n[1] NA\n\ny &lt;- NULL\ny == NULL\n\nlogical(0)\n\n\nДля этого есть специальные функции.\n\nis.na(x)\n\n[1] TRUE\n\nis.null(y)\n\n[1] TRUE\n\n\n\nWhen some people first get to R, they spend a lot of time trying to get rid of NAs. People probably did the same sort of thing when zero was invented. NA is a wonderful thing to have available to you. It is seldom pleasant when your data have missing values, but life if much better with NA than without.\nBurns (2012)\n\nКак избавиться от NA? В некоторых случаях достаточно аргумента функции.\n\nmean(c(1, NA, 2), na.rm=T) \n\n[1] 1.5\n\n\nЧуть более сложные способы вы узнаете из урока swirl ниже.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 5 Missing Values.\n\n\nГотово? Тогда попробуйте ответить на вопрос ниже, не выполняя вычислений в R.\n\n\n\n\n\n\nВопрос\n\n\n\nДан вектор x &lt;- c(44, NA, 5, NA). Сколько NA вернет команда x == NA?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 6 Subsetting Vectors.\n\n\nПроверьте, все ли вы поняли из этого урока.\n\n\n\n\n\n\nВопрос\n\n\n\nЕсли вектор x содержит числовые значения и некоторое количество NA, то что вернет команда x[is.na(x)]?\n\n\n\n\nвектор длиной 0\n\n\nвектор всех NA\n\n\nлогический вектор\n\n\nвектор без NA\n\n\nошибку\n\n\n\n\n\nЧто надо изменить в этом коде, чтобы получить все, кроме NA?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#типы-данных",
    "href": "start.html#типы-данных",
    "title": "1  Начало работы",
    "section": "1.7 Типы данных",
    "text": "1.7 Типы данных\nОсновные типы данных, с которыми мы будем работать, следующие:\n\nцелое число (integer)\nчисло с плавающей точкой (numeric, также называются double, то есть число двойной точности)\nстрока (character)\nлогическая переменная (logical)\nкатегориальная переменная, или фактор (factor)\n\n\n# проверить тип данных \nx &lt;- sqrt(2)\nclass(x)\n\n[1] \"numeric\"\n\nis.integer(x)\n\n[1] FALSE\n\nis.numeric(x)\n\n[1] TRUE\n\n\nДля начала мы научимся генерировать векторы. Например, так.\n\nseq(1, 5, 0.5)\n\n[1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0\n\nrep(\"foo\", 5)\n\n[1] \"foo\" \"foo\" \"foo\" \"foo\" \"foo\"\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 3 Sequences of Numbers.\n\n\nПроверьте свои знания, прежде чем двигаться дальше.\n\n\n\n\n\n\nВопрос\n\n\n\nКакие числа вернет команда pi:10?\n\n\n\n\nнатуральные\n\n\nцелые\n\n\nрациональные\n\n\nвещественные\n\n\nкомплексные\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКакие функции могут использоваться для создания символьных векторов?\n\n\n\n\nseq()\n\n\nrep()\n\n\nc()\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nСколько значений вернет команда rep(c(0, 1, 2), times = 10)? Посчитайте в уме, не выполняя код.\n\n\n\n\n\n\n\n\n Факторы внешне похожи на строки, но в отличие от них хранят информацию об уровнях категориальных переменных. Уровень может обозначаться как числом (например, 1 и 0), так и строкой.\n\nt &lt;- factor(c(\"A\", \"B\", \"C\"), levels = c(\"A\", \"B\", \"C\"))\nt\n\n[1] A B C\nLevels: A B C\n\n\nПри попытке объединить в единый вектор данные разных типов они будут принудительно приведены к одному типу:\n\nx &lt;- c(TRUE, 1, 3, FALSE)\nx # логические значения переработаны в числовые\n\n[1] 1 1 3 0\n\ny &lt;- c(1, \"a\", 2, \"лукоморье\") # строки всегда в кавычках\ny # числа превратились в строки\n\n[1] \"1\"         \"a\"         \"2\"         \"лукоморье\"\n\n\n Логические векторы можно получить в результате применения логических операторов (== “равно”, != “не равно”, &lt;= “меньше или равно”) к данным других типов:\n\nx &lt;- c(1:10) # числа от 1 до 10\ny &lt;- x &gt; 5\ny # значения TRUE соответствуют единице, поэтому их можно складывать\n\n [1] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE\n\nsum(y)\n\n[1] 5\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗдесь можно запустить swirl() и пройти урок 8 Logic. Это не обязательно, но очень полезно, если хотите разобраться в операторах!\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nПопробуйте посчитать в уме: какое из выражений ниже вернет значение TRUE?\n\n\n\n\n7 == 9\n\n\n!(57 != 8)\n\n\n9 &gt;= 10\n\n\n-6 &gt; -7\n\n\n\n\n\nФункции all() и any() также возвращают логические значения:\n\nx &lt;- 10:20 \nany(x == 15)\n\n[1] TRUE\n\nall(x &gt; 9)\n\n[1] TRUE\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 4 Vectors. Это позволит больше узнать про логические и символьные векторы.\n\n\nНесколько вопросов для самопроверки.\n\n\n\n\n\n\nВопрос\n\n\n\nКакие значение вернет команда (3 &gt; 5) & (4 == 4)?\n\n\n\n\nTRUE\nFALSE\nNA\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКакие значения вернет команда (TRUE == TRUE) | (TRUE == FALSE)?\n\n\n\n\nTRUE\nFALSE\nNA\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКоманда paste(LETTERS, 1:4, sep = \"-\") вернет…\n\n\n\n\nчисловой вектор длиной 26\n\n\nсимвольный вектор длиной 26\n\n\nчисловой вектор длиной 4\n\n\nсимвольный вектор длиной 4\n\n\nошибку",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#отсутствующие-значения",
    "href": "start.html#отсутствующие-значения",
    "title": "1  Начало работы",
    "section": "1.8 Отсутствующие значения",
    "text": "1.8 Отсутствующие значения\nNULL означает, что значение не существует. Например, если мы создадим пустой вектор, то при попытке распечатать его получим NULL. А вот длина пустого вектора равна нулю!\n\ny &lt;- c() \ny \n\nNULL\n\nlength(y) \n\n[1] 0\n\n\nNA (not available) указывает на то, что значение существует, но оно неизвестно. Любые операции с NA приводят к появлению новых NA! Сравните:\n\nx &lt;- c(1, NA, 2)\nmean(x)\n\n[1] NA\n\ny &lt;- c(1, NULL, 2)\nmean(y)\n\n[1] 1.5\n\n\nКак проверить, есть ли в данных NA или NULL? Знак ==, который вы встречали в уроке swirl, здесь не подойдет.\n\nx &lt;- NA\nx == NA\n\n[1] NA\n\ny &lt;- NULL\ny == NULL\n\nlogical(0)\n\n\nДля этого есть специальные функции.\n\nis.na(x)\n\n[1] TRUE\n\nis.null(y)\n\n[1] TRUE\n\n\n\nWhen some people first get to R, they spend a lot of time trying to get rid of NAs. People probably did the same sort of thing when zero was invented. NA is a wonderful thing to have available to you. It is seldom pleasant when your data have missing values, but life if much better with NA than without.\nBurns (2012)\n\nКак избавиться от NA? В некоторых случаях достаточно аргумента функции.\n\nmean(c(1, NA, 2), na.rm=T) \n\n[1] 1.5\n\n\nЧуть более сложные способы вы узнаете из урока swirl ниже.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 5 Missing Values.\n\n\nГотово? Тогда попробуйте ответить на вопрос ниже, не выполняя вычислений в R.\n\n\n\n\n\n\nВопрос\n\n\n\nДан вектор x &lt;- c(44, NA, 5, NA). Сколько NA вернет команда x == NA?\n\n\n\n\n\n\n\n\n\nТеперь мы знакомы с основными типами данных и готовы вернутья к объектам, которые их хранят. Поговорим о списках.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#списки",
    "href": "start.html#списки",
    "title": "1  Начало работы",
    "section": "1.7 Списки",
    "text": "1.7 Списки\nВ отличие от атомарных векторов, списки, или рекурсивные векторы, могут хранить данные разных типов.\n\nlist = list(a = c(\"a\", \"b\", \"c\"), b = c(1, 2, 3), c = c(T, F, T))\nlist\n\n$a\n[1] \"a\" \"b\" \"c\"\n\n$b\n[1] 1 2 3\n\n$c\n[1]  TRUE FALSE  TRUE\n\n\nМожно получить доступ как к элементам списка целиком, так и к их содержимому.\n\nlist$a # обращение к поименованным элементам \n\n[1] \"a\" \"b\" \"c\"\n\nlist[2] # одинарные квадратные скобки извлекают элемент списка целиком\n\n$b\n[1] 1 2 3\n\nclass(list[2])\n\n[1] \"list\"\n\nlist[[2]] #  элементы второго элемента \n\n[1] 1 2 3\n\nclass(list[[2]])\n\n[1] \"numeric\"\n\nlist$c[1]# первый элемент второго элемента\n\n[1] TRUE\n\n\nОбратите внимание, что list[2] и list[[2]] возвращают объекты разных классов. Нам это еще понадобится при работе с XML.\n\n\n\nИндексирование списка в R. Источник 🧂\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nУстановите библиотеку rcorpora и загрузите список с названиями хлеба и сладкой выпечки.\nlibrary(rcorpora)\nmy_list &lt;-  corpora(\"foods/breads_and_pastries\")\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nУзнайте длину my_list и введите ее в поле ниже.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nДостаньте из my_list элемент pastries и узнайте его длину.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nА теперь извлеките пятый элемент из pastries и введите ниже его название.\n\n\n\n\n\n\n\n\nСо списками покончено. Теперь можно пойти выпить кофе с my_list$pastries[13]. Дальше будет сложнее, но интереснее.\n\n\n\n\nBurns, Patrick. 2012. The R inferno. Lulu.com.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#матрицы",
    "href": "start.html#матрицы",
    "title": "1  Начало работы",
    "section": "1.12 Матрицы",
    "text": "1.12 Матрицы\nМатрица – это вектор, который имеет два дополнительных атрибута: количество строк и количество столбцов. Из этого следует, что матрица, как и вектор, может хранить данные одного типа. Проверим.\n\nM = matrix(c(1, 2, 3, 4), nrow = 2)\nM # все ок\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nM = matrix(c(1, 2, 3, \"a\"), nrow = 2)\nM # все превратилось в строку! \n\n     [,1] [,2]\n[1,] \"1\"  \"3\" \n[2,] \"2\"  \"a\" \n\n\nВ матрице есть ряды и столбцы. Их количество определяет размер (порядок) матрицы. Выше мы создали матрицу 2 x 2. Элементы матрицы, как и элементы вектора, можно извлекать по индексу. Сначала указывается номер ряда (строки), потом номер столбца.\n\nM = matrix(c(1, 2, 3, 4), nrow = 2)\nM[1, ] # первая строка полностью\n\n[1] 1 3\n\nM[,2] # второй столбец полностью\n\n[1] 3 4\n\nM[1,1] # одно значение\n\n[1] 1\n\n\nОбратите внимание, как меняется размерность при индексировании.\n\nM = matrix(c(1, 2, 3, 4), nrow = 2)\nclass(M)\n\n[1] \"matrix\" \"array\" \n\ndim(M) # функция для извлечения измерений\n\n[1] 2 2\n\nclass(M[1, ]) # первая строка полностью\n\n[1] \"numeric\"\n\ndim(M[1, ]) \n\nNULL\n\n\nПопытка узнать измерения вектора возвращает NULL, потому что с точки зрения R векторы не являются матрицами из одного столбца или одной строки, и потому не имеют измерений. С другой стороны, можно создать матрицу, в которой будет одна строка или один столбцец. При выводе они выглядят не так, как обычные векторы. Хотя казалось бы.\n\n# вектор-строка\nC = matrix(c(1, 2, 3), nrow = 1)\nC\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n\n# вектор-столбец\nD = matrix(c(1, 2, 3), nrow = 3)\nD\n\n     [,1]\n[1,]    1\n[2,]    2\n[3,]    3\n\n\nНад числовыми матрицами в R можно совершать разные операции из линейной алгебры (А. Буховец и П. Москалев 2015); многие из них нам понадобятся, когда мы будем говорить о латентно-семантическом анализе. Ниже несколько полезных функций (но пока их можно пропустить).\n\n# в квадратной матрице есть главная и побочная диагонали\nM = matrix(c(1, 2, 3, 4), nrow = 2) # ее мы распечатывали выше\ndiag(M)\n\n[1] 1 4\n\n# если поставить матрицу на бок, то получится транспонированная матрица\nt(M)\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\n# матрицу можно умножить на скаляр, то есть на обычное число. \nM * 3\n\n     [,1] [,2]\n[1,]    3    9\n[2,]    6   12\n\n# матрицы одного размера можно складывать\nM + M\n\n     [,1] [,2]\n[1,]    2    6\n[2,]    4    8\n\n\nЕсли хотите, можете посмотреть видео. Упражнений на матрицы пока не будет! (Они настигнут вас позже.)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#таблицы",
    "href": "start.html#таблицы",
    "title": "1  Начало работы",
    "section": "1.13 Таблицы",
    "text": "1.13 Таблицы\nТаблицы (кадры данных, data frames) – это двумерные объекты (как и матрицы). Датафреймы отличаются от матриц тем, что их столбцы могут хранить данные разного типа.\n\n\n\n\n\n\nНа заметку\n\n\n\nЕсли списки являются разнородными аналогами векторов в одном измерении, кадры данных являются разнородными аналогами матриц для двумерных данных (Мэтлофф 2019, 134).\n\n\n\n\n# создание датафрейма\ndf &lt;- data.frame(names = c(\"A\", \"B\"), age = c(10, 11))\ndf\n\n\n  \n\n\n# извлечение элементов\ndf$names # забирает весь столбец\n\n[1] \"A\" \"B\"\n\ndf[,\"names\"] # то же самое, другой способ\n\n[1] \"A\" \"B\"\n\ndf[1, ] # забирает ряд\n\n\n  \n\n\n\nПотренируемся на датасете с данными о гапаксах1 в диалогах Платона. Датасет можно скачать по ссылке. Файл имеет расширение .Rdata; щелкнув на него правой кнопкой мыши, можете открыть его сразу в RStudio и потренироваться.\nЭтот датасет позволяет перепроверить выводы Льюиса Кэмпбелла, профессора Сент-Эндрюсского университета в Шотландии. Еще 1867 г., впервые применив количественный метод для датировки диалогов Платона, он пришел к выводу, что для “позднего” стиля Платона, среди прочего, характерно обилие редкой лексики (Campbell 1867, xxxi).\nВ корпус подлинных диалогов Кэмпбелл включал 26 текстов, которые делил на три хронологические группы. Свои вычисления он делал вручную, а мы можем попробовать все пересчитать в R.\n\nhead(hapax_plato)\n\n\n  \n\n\n\nВот так выглядят наши данные. Функция class() позволяет убедиться, что это датафрейм.\n\nclass(hapax_plato)\n\n[1] \"data.frame\"\n\n\nПотренируемся работать с данными в таблицах.\n\n# узнать имена столбцов\ncolnames(hapax_plato) \n\n[1] \"dialogue\" \"words\"    \"hapax\"    \"ratio\"    \"group\"   \n\n\n\n# извлечь ряд(ы) по значению\nhapax_plato[hapax_plato$dialogue == \"Parmenides\", ]\n\n\n  \n\n\n\n\n# узнать тип данных в столбцах\nstr(hapax_plato) \n\n'data.frame':   26 obs. of  5 variables:\n $ dialogue: chr  \"Apology\" \"Charmides\" \"Cratylus\" \"Critias\" ...\n $ words   : chr  \"8745\" \"8311\" \"17944\" \"4950\" ...\n $ hapax   : chr  \"36\" \"31\" \"122\" \"104\" ...\n $ ratio   : chr  \"0.004\" \"0.004\" \"0.007\" \"0.021\" ...\n $ group   : num  1 1 1 3 1 1 1 1 1 1 ...\n\n\n\n# преобразовать тип данных в столбцах\nhapax_plato$group &lt;- as.factor(hapax_plato$group)\nhapax_plato[,2:4] &lt;- sapply(hapax_plato[,2:4],as.numeric) # подробнее о функции `sapply()` в уроке про итерации\n\n\n# отобрать ряды по количеству слов\nhapax_plato[hapax_plato$words &gt; 10000, ]\n\n\n  \n\n\n\nИ еще с датафреймами полезна функция summary():\n\nsummary(hapax_plato)\n\n   dialogue             words            hapax            ratio          group \n Length:26          Min.   :  4024   Min.   : 12.00   Min.   :0.001000   1:16  \n Class :character   1st Qu.:  7154   1st Qu.: 31.25   1st Qu.:0.004000   2: 4  \n Mode  :character   Median : 15590   Median : 94.50   Median :0.007000   3: 6  \n                    Mean   : 19364   Mean   :146.69   Mean   :0.007154         \n                    3rd Qu.: 17907   3rd Qu.:136.75   3rd Qu.:0.008000         \n                    Max.   :103193   Max.   :914.00   Max.   :0.021000         \n\n\nПоследнее упражнение на кодинг в этой главе!\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 7 Matrices and Data Frames.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#практическое-задание",
    "href": "start.html#практическое-задание",
    "title": "1  Начало работы",
    "section": "1.11 Практическое задание",
    "text": "1.11 Практическое задание\nНапоследок небольшое практическое задание. Код для его выполнения сохраните в виде файла с расширением .R. Его надо будет отправить преподавателю.\n\n\n\n\n\n\n\nЗадание\n\n\n\nПРАКТИЧЕСКОЕ ЗАДАНИЕ 1: ИСПАНСКИЕ ПИСАТЕЛИ\n\n\n\n\n# устанавливаем и загружаем нужный пакет\ninstall.packages(\"languageR\")\nlibrary(languageR)\n\n# загружаем датасет\nmeta &lt;- spanishMeta\n\n# допишите ваш код ниже\n# посчитайте средний год публикации романов Камило Хосе Селы\n\n\n# вычислите суммарное число слов в романах Эдуардо Мендосы\n\n\n# извлеките ряды с текстами, опубликованными до 1980 г.\n\nПоздравляем! С этой главой вы справились. Дальше будет сложнее, но интереснее.\n\n\n\n\n\nBurns, Patrick. 2012. The R inferno. Lulu.com.\n\n\nМэтлофф, Норман. 2019. Искусство программирования на R. Питер.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#footnotes",
    "href": "start.html#footnotes",
    "title": "1  Начало работы",
    "section": "",
    "text": "Гапакс – это слово, которое встречается один раз в корпусе или тексте.↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "plot.html",
    "href": "plot.html",
    "title": "2  Визуализации",
    "section": "",
    "text": "2.1 Базовый R\nВ R существуют три основные системы построения графиков, которые могут быть полезны для достижения разных целей. Базовый R – это самая старая система, и в ее основе лежит концепция палитры художника2.\nИдея заключается в том, что у вас есть чистый холст, на который вы добавляете что-то одно за другим: например, сначала вы создаете диаграмму рассеяния с несколькими точками, затем добавляете метки, линию регрессии, заголовки и т.п. Каждая деталь графика занимает еще одну строчку кода.\nЭто интуитивно понятная модель, потому что часто в самом начале, исследуя данные, мы часто не знаем, какой график мы хотим построить. Обычно мы начинаем это построение с функции plot(), а затем добавляем функции, которые аннотируют график. Вот простой пример на данных о гапаксах у Платона, которые мы видели раньше.\nЧтобы построить диаграмму рассеяния (scatter plot), нужно передать функции plot() в качестве аргументов названия тех столбцов, которые мы хотим изобразить по осям x и y. Это можно записать так: plot(x, y). Или так: plot(y ~ x). Знак ~ (тильда) указывает на функцию.\nattach(hapax_plato)\nplot(hapax ~ words)\nЭто можно записать и иначе: plot(hapax_plato$hapax ~ hapax_plato$words). Результат будет одинаковый.\nТеперь беремся за палитру. Данные скучились в левом нижнем углу и потому плохо читаются. Мы можем пожертвовать двумя очень длинными диалогами (это “Государство” и “Законы”) и сделать zoom in, указав вручную границы осей.\nattach(hapax_plato)\nplot(hapax ~ words, xlim = c(0, 30000), ylim = c(0, 500))\nНо так мы все-таки теряем какую-то информацию – а вдруг она важная? Еще один способ справиться со слипшимися данными – преобразовать их. Применим логарифмическое преобразование. Обратите внимание, как меняются значения на осях.\nattach(hapax_plato)\noptions(scipen=999) # избавляет от научной нотации\nplot(words, hapax, log = \"xy\")  \n# добавим текст\ntext(hapax ~ words, labels = dialogue, pos = 2, cex = 0.7)\nУже гораздо интереснее! Попробуем обозначить цветом и формой пересказанные и прямые диалоги. Форма задается внутри функции plot() при помощи атрибута pch. Числовые значения этого атрибута соответствуют следующим значкам. Мы используем 2, 3 и 5.\nПерестраиваем наш график.\nattach(hapax_plato)\noptions(scipen=999) # избавляет от научной нотации\nplot(words, hapax, log = \"xy\", col = c(\"darkblue\", \"darkgreen\", \"darkred\")[group], \n     pch = c(2, 3, 5)[group])\ntext(hapax ~ words, labels = dialogue, \n     pos = 2, cex = 0.7, col = c(\"darkblue\", \"darkgreen\", \"darkred\")[group])\nНекоторые названия перекрываютcя (с этим мы научимся бороться позже), но все равно намного понятнее. Теперь можем поменять шрифт и, например, добавить линию регрессии (не хватает легенды, но что-то уже нет сил).\nattach(hapax_plato)\noptions(scipen=999) # избавляет от научной нотации\nplot(words, hapax, log = \"xy\", col = c(\"darkblue\", \"darkgreen\", \"darkred\")[group], pch = c(2, 3, 5)[group], family = \"serif\")\ntext(hapax ~ words, labels = dialogue, \n     pos = 2, cex = 0.7, col = c(\"darkblue\", \"darkgreen\", \"darkred\")[group], family = \"serif\")\n\n# добавим линию регрессии\nmy_lm &lt;- lm(hapax_plato$hapax ~ hapax_plato$words)\nabline(my_lm, lty = \"dashed\", col = \"darkgrey\", untf = T)\n\n# и заголовок\ntitle(main = \"Число гапаксов в зависимости от длины диалога\")\nПри помощи графических параметров3 можно контролировать множество настроек. Но в этом и недостаток базовой графики. Не всем хватает терпения и вкуса этим заниматься, поэтому эта система сейчас не очень употребительна.\nПопробуйте интерпретировать график, который у нас получился. Прав ли был профессор Кэмпбелл, утверждая, что высокая доля гапаксов характерна для “поздних” текстов? Исходите из того, что единственный текст, о котором точно известно, что он поздний – это “Законы”.\nСудя по графику, количество гапаксов зависит от количества слов в тексте. Чем длиннее текст, тем больше вероятность встретить там редкое слово.\nПрежде чем двигаться дальше, проверьте свои знания.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#базовый-r",
    "href": "plot.html#базовый-r",
    "title": "2  Визуализации",
    "section": "",
    "text": "Значения атрибута pch.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nСнова запустите swirl(); курс R Programming E у вас уже установлен. Из него надо сделать урок 15 Base Graphics.\nДополнительно пройдите урок 2 Exploratory Graphs из курса Exploratory Data Analysis; он знакомит с важнейшими типами графиков в базовом R (диаграмма размаха, гистограмма, столбиковая диаграмма, диаграмма рассеяния).\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nДля каждой из диаграмм ниже укажите ее тип.\n\n\n\n\n\nдиаграмма размаха\nгистограмма\nдиаграмма рассеяния\n\n\n\n\n\n\n\n\nдиаграмма размаха\nгистограмма\nдиаграмма рассеяния\n\n\n\n\n\n\n\n\nдиаграмма размаха\nгистограмма\nдиаграмма рассеяния",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#lattice",
    "href": "plot.html#lattice",
    "title": "2  Визуализации",
    "section": "2.2 Lattice",
    "text": "2.2 Lattice\nСистема Lattice (букв. “Решетка”) была разработана специально для анализа многомерных данных (Sarkar 2008).\n\n\n\nТут должны быть графики цветочки.\n\n\n\nНапример, мы сравниваем точность классификации текстов в зависимости от длины отрывка и количества слов-предикторов. Это уже три переменные (длина – количество слов – точность). Система решеток, или панелей, позволяет представить такие многомерные данные.\n\n\n\nМногомерно нет слов! Источник.\n\n\n\nВ базовом R тоже можно решить такую задачу, изменив графические параметры:\n\npar(mfrow = c(1,2)) # вот тут указываем число рядов и столбцов\nplot(hapax_plato$hapax ~ hapax_plato$words)\nplot(hapax_plato$ratio ~ hapax_plato$group)\n\n\n\n\n\n\n\n\nНо видно, что по умолчанию пространство расходуется неэффективно. Кроме того, к таким графикам сложно создавать заголовки и подзаголовки, подбирать подписи и легенды т.п. Все эти задачи решает Lattice.\nИдея этой системы в том, что каждый график строится с помощью одного вызова функции. При этом необходимо сразу указать большое количество информации, чтобы у функции было достаточно данных для построения графика.\n\nlibrary(lattice)\n\n# после вертикальной черты указана переменная, \n# которая используется для группировки данных; \n# в нашем случае номер группы (по Кэмпбеллу)\n\nxyplot(hapax ~ words | group, data = hapax_plato,\n       scales=list(x=list(log=10))) # трансформация по одной оси\n\n\n\n\n\n\n\n\nНедостаток Lattice, однако, в том, что бывает сложно аннотировать отдельные панели, а также приходится сразу задавать весь график в одном вызове функции. Это не всегда удобно. После создания графика уже ничего нельзя добавить или убавить.\n\n\n\n\n\n\nЗадание\n\n\n\nСнова запустите swirl(), выберите курс “Exploratory Data Analysis” и пройдите из него урок 6 Lattice Plotting System.\n\n\n Это задание выполнять не обязательно (потому что работать мы будем в основном в ggplot2), но полезно: оно поможет понять графическую идиоматику R.\n\n\n\n\n\n\nНа заметку\n\n\n\nНебольшое пояснение: в заданиях этого урока swirl встречается аргумент .... Он бывает нужен, когда вы пишете функцию, внутри которой есть другая функция со своими аргументами. Для более полной информации загляните вот сюда – или просто пропустите. Для выполнения заданий это пока не понадобится.\n\n\nДля тех, кто все-таки справился с этим уроком – один вопрос. (Если решили его не проходить, попробуйте самостоятельно найти ответ: это тоже важный навык).\n\n\n\n\n\n\nВопрос\n\n\n\nЕсли нужная вам функция хранится в рабочей директории в файле my_func.R, какая встроенная функция R позволит его прочитать в глобальное окружение? Введите только название функции без скобок и аргументов.\n\n\n\n\n\n\n\n\nВремя сделать перерыв, а потом можно двигаться дальше – к самому интересному.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#ggplot2",
    "href": "plot.html#ggplot2",
    "title": "2  Визуализации",
    "section": "2.3 Ggplot2",
    "text": "2.3 Ggplot2\nНастоящая графическая сила R – это пакет ggplot2. В его основе лежит идея “грамматики графических элементов” Лиланда Уилкинсона (Мастицкий 2017) (отсюда “gg” в названии), и он объединяет достоинства базовой графики R и Lattice. С одной стороны, вы можете постепенно достраивать график, добавляя элемент за элементом; с другой – множество параметров подбираются автоматически, как в Lattice.\n\n2.3.1 Быстрое решение: qplot()\nФункция qplot() – рабочая лошадка пакета. Настройки по умолчанию хорошо видно на графике ниже, позже вы научитесь их менять.\n\nlibrary(ggplot2) # часть пакета tidyverse\noptions(scipen = 999)\nqplot(words, hapax, data = hapax_plato, log = \"xy\")\n\nWarning: `qplot()` was deprecated in ggplot2 3.4.0.\n\n\n\n\n\n\n\n\n\nФункция qplot() – это хотя и рабочая, но старая лошадка. В современных версиях ggplot2 использование функции qplot() не рекомендуется (deprecated), чтобы побудить пользователей изучать ggplot() как более совершенный инструмент. Тем не менее полезно знать, что такое решение есть.\nВыше мы построили диаграмму рассеяния, используя логарифмическую трансформацию по двум осям. Можно также выделить цветом различные типы диалогов, изменить размер точек, их прозначность и т.п.\n\nqplot(words, hapax, data = hapax_plato, log = \"xy\", col = group, size = 1.5) + theme(legend.position = \"none\")\n\n\n\n\n\n\n\n\nДиаграмма размаха (о ней подробнее можно посмотреть видео) удобна в тех случаях, когда необходимо представить обобщенную статистическую информацию о распределении значений количественной переменной в разных группах.\n\nattach(hapax_plato)\nqplot(group, ratio, data = hapax_plato, geom = \"boxplot\", color = group)\n\n\n\n\n\n\n\n\nДиаграмму размаха можно совместить с одномерной диаграммой рассеяния. Для этого аргументу geom передаем вектор с названиями геомов.\n\nqplot(group, ratio, data = hapax_plato, geom = c(\"boxplot\", \"jitter\"), color = group) # вместо color можно использовать shape, который отвечает за форму элементов\n\n\n\n\n\n\n\n\n\nТеперь предлагаем немного потренироваться. Пройдите обзорный урок на все графические системы R.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс “Exploratory Data Analysis” и пройдите из него 4 Plotting Systems.\n\n\nСнова полный коварства вопрос. Проверьте свои знания!\n\n\n\n\n\n\nВопрос\n\n\n\nВ уроке несколько раз встречалась функция with(). Что можно ей передать в качестве второго аргумента?\n\n\n\n\nдатафрейм\n\n\nвектор\n\n\nфункцию\n\n\nматрицу\n\n\nсписок\n\n\n\n\n\nСледующее задание позволит закрепить знания о функции qplot().\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс “Exploratory Data Analysis” и пройдите из него урок 8 GGPlot2 Part1.\n\n\nИ всего один вопрос по этому уроку.\n\n\n\n\n\n\nВопрос\n\n\n\nЧто нельзя построить при помощи функции qplot()?\n\n\n\n\nгистограмму\n\n\nдиаграмму рассеяния\n\n\nдиаграмму размаха\n\n\nнет верного ответа\n\n\n\n\n\nПолурока позади, время сделать паузу и ответить на важнейший вопрос: чай или кофе?\n\n\nчай\nкофе\n\n\n\n\n\n\n\n2.3.2 Слой за слоем: ggplot()\nВ уроке swirl выше вы имели дело лишь с функцией qplot(). Для более детальной настройки графика рекомендуется использовать функцию ggplot(), которая имеет два основных аргумента: data и aes (англ. aesthetics).\nПод “эстетикой” подразумеваются графические атрибуты, такие как размер, форма или цвет. Вы не увидите их на графике, пока не добавите какие-нибудь “геомы” – геометрические объекты (точки, линии, столбики и т.п.). Эти объекты могут слоями накладываться друг на друга (Wickham и Grolemund 2016).\nПосмотрим, как это работает, на примере столбиковой диаграммы. Такая диаграмма позволяет представить распределение как количественных, так и качественных переменных.\nДля примера возьмем датасет diorisis_meta, который хранит данные о древнегреческих текстах, доступных в репозитории Diorisis4. Можете скачать его из репозитория курса по ссылке. Столбиковая диаграмма позволяет увидеть, тексты каких жанров чаще всего встречаются в этом корпусе.\n\n\n\n  \n\n\n\nПодготовим этот датасет для визуализации (пока не надо вникать, что тут происходит – мы вернемся к этому в следующих уроках).\n\nlibrary(tidyverse)\ndiorisis_count &lt;- diorisis_meta %&gt;%\n  group_by(genre) %&gt;% \n  count() \n\ndiorisis_count\n\n\n  \n\n\n\nТеперь передадим эти данные функции ggplot…\n\nggplot(aes(genre, n, fill = genre), \n       data = diorisis_count)\n\n\n\n\n\n\n\n\n…И ничего не увидим. Надо добавить геомов! (А также развернем график, чтобы лучше читались подписи).\n\nggplot(aes(genre, n, fill = genre), \n       data = diorisis_count) + \n  geom_bar(stat = \"identity\") +\n  coord_flip()\n\n\n\n\n\n\n\n\nИнтересно, а если поменять геомы на точки? Что-то, конечно, получится, но здесь это явно не лучший способ представить данные.\n\nggplot(aes(genre, n, color = genre), \n       data = diorisis_count) + \n  geom_point(show.legend = F) +\n  coord_flip()\n\n\n\n\n\n\n\n\nТочечная диаграмма, или dotplot, подходит для тех случаев, когда мы исследуем распределение наблюдений для разных групп данных, причем наблюдений не очень много. Например, мы можем отразить распределение текстов в корпусе по годам. Категориальную переменную (например, жанр) можно дополнительно закодировать цветом (зд. подробнее о том, что можно увидеть на этом графике). Поскольку мы изучаем распределение, считать число наблюдений в каждой группе заранее не надо.\n\nggplot(aes(date, fill = factor(genre)), \n       data = diorisis_meta) + \n  geom_dotplot(binwidth = 10, stackdir = \"centerwhole\", binpositions = \"all\") +  \n  #убираем все обозначения по шкале y\n  scale_y_continuous(NULL, breaks = NULL) +\n  # добавляем делений на шкале x\n  scale_x_continuous(breaks = scales::pretty_breaks(n = 10))\n\n\n\n\n\n\n\n\nРазличные группы данных можно выделять не только цветом и формой, но и помещать каждую в свое окошко (facet), как вы это уже делали в Lattice. Попробуем выяснить: сколько поджанров в каждом жанре?\n\n# готовим данные, пока можно не вникать\ndiorisis_sub &lt;- diorisis_meta %&gt;% \n  group_by(genre, subgenre) %&gt;% \n  count %&gt;%\n  filter(genre %in% c(\"Poetry\", \"Technical\"))\n\ndiorisis_sub\n\n\n  \n\n\n\n\nggplot(aes(reorder(subgenre, n), n, fill = subgenre), \n       data = diorisis_sub) + \n  geom_col(show.legend = F) +\n  # вот здесь задаем  группы\n  facet_wrap(~genre, scales = \"free\") + \n  coord_flip()\n\n\n\n\n\n\n\n\nВыше мы сталкивались с проблемой, что текстовые подписи наезжают друг на друга. Пакет ggrepel позволяет легко с этим справиться.\n\nlibrary(ggrepel)\nhapax_plato %&gt;% ggplot(aes(words, hapax, col = group)) +\n  geom_point(size = 1.2, alpha = 0.7, show.legend = F) +\n  geom_label_repel(label = dialogue) +\n  scale_x_log10() +\n  scale_y_log10() +\n  theme_bw()\n\n\n\n\n\n\n\n\nПлиний Старший говорил, что нет такой плохой книги, в которой не найдется ничего полезного. А мы думаем, что нет такого упражнения на кодинг, из которого нельзя извлечь пользы. Особенно если это упражнения на работу с ggplot2 – дальше мы постоянно будем пользоваться этим инструментом.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс “Exploratory Data Analysis” и пройдите из него урок 9 GGPlot2 Part2.\n\n\nПравда или ложь?\n\n\n\n\n\n\nВопрос\n\n\n\nНа одной диаграмме может быть несколько геомов.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nВсе эстетические атрибуты для всех геомов задаются при вызове ggplot().\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nОтметьте все термины “грамматики графических элементов” ggplot2.\n\n\n\n\nданные\n\n\nгеометрические объекты\n\n\nстатистические преобразования\n\n\nшкалы\n\n\nсистемы координат\n\n\nфасеты\n\n\n\n\n\nПока не расслабляемся, впереди еще один урок swirl.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс “Exploratory Data Analysis” и пройдите из него урок 10 GGPlot2 Extras.\n\n\nПравда или ложь?\n\n\n\n\n\n\nВопрос\n\n\n\nЧтобы построить диаграмму рассеяния, нужно добавить к графическому объекту, созданному функцией ggplot, геометрический объект под названием geom_scatterplot.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nФункция cut() позволяет преобразовать числовой вектор в фактор.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nПолуинтервал (0.2,0.5] включает 0.2 и не включает 0.5.\n\n\n\n\nПравда\nЛожь",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#работа-с-цветом",
    "href": "plot.html#работа-с-цветом",
    "title": "2  Визуализации",
    "section": "2.4 Работа с цветом",
    "text": "2.4 Работа с цветом\nВ качестве дополнительного упражнения вы можете выполнить задание и ответить на вопросы к нему.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс “Exploratory Data Analysis” и пройдите из него урок 7 Working with Colors.\n\n\n Время для самопроверки!\n\n\n\n\n\n\nВопрос\n\n\n\nСколько цветов содержит стандартная цветовая палитра R?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nФункция rgb() позволяет создать любой цвет путем “смешения” красного, синего и зеленого. А что регулирует ее аргумент alpha? (Вы встретите его и в других контекстах).\n\n\n\n\nшкалу\n\n\nяркость\n\n\nпрозрачность\n\n\nконтраст\n\n\n\n\n\nВ уроке упоминались различные виды палитр. Проверьте, все ли вы усвоили.\n\n\n\nИсточник.\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nДана качественная переменная с упорядоченными уровнями (например, “холодный”, “теплый”, “горячий”) или количественная переменная. Необходимо подчеркнуть разницу между высокими и низкими значениями. Какая палитра подходит для визуализации?\n\n\n\n\nпоследовательная\n\n\nрасходящаяся\n\n\nкачественная\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nДана количественная переменная с осмысленным средним значением, например нулем, 50%, медианой, целевым показателем и т.п. Какая палитра подходит для визуализации?\n\n\n\n\nпоследовательная\n\n\nрасходящаяся\n\n\nкачественная\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nДана качественная переменная, уровни которой невозможно упорядочить (названия городов, имена авторов и т.п.). Какая палитра подойдет?\n\n\n\n\nпоследовательная\n\n\nрасходящаяся\n\n\nкачественная",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#экспорт-графиков-из-среды-r",
    "href": "plot.html#экспорт-графиков-из-среды-r",
    "title": "2  Визуализации",
    "section": "2.5 Экспорт графиков из среды R",
    "text": "2.5 Экспорт графиков из среды R\nСпособы:\n\nреализованные в R драйверы стандартных графических устройств;\nфункция ggsave()\nменю программы RStudio.\n\n\n# код сохранит pdf в рабочую директорию \npdf(file = \"Diorisis.pdf\")\n \nggplot(diorisis_sub, aes(reorder(subgenre, n), n, fill = subgenre)) + \n  geom_col(show.legend = F) +\n  facet_wrap(~genre, scales = \"free\") +\n  coord_flip()\ndev.off()\n\nЕще один способ сохранить последний график из пакета ggplot2.\n\nggsave(\n  filename = \"Diorisis.png\",\n  plot = last_plot(),\n  device = \"png\",\n  scale = 1,\n  width = NA,\n  height = 500,\n  units = \"px\",\n  dpi = 300\n)\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс “Exploratory Data Analysis” и пройдите из него урок 3 Graphics Devices in R.\n\n\nНе расслабляемся! Еще один вопросик.\n\n\n\n\n\n\nВопрос\n\n\n\nЧто делает функция dev.off()?\n\n\n\n\nвызывает дьявола\n\n\nотгоняет дьявола\n\n\nотключает графическое устройство\n\n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nПРАКТИЧЕСКОЕ ЗАДАНИЕ 2: СТАРОФРАНЦУЗСКАЯ ЛИТЕРАТУРА\n\n\n\n\n# загружаем нужные пакеты\nlibrary(languageR)\nlibrary(ggplot2)\n\n# загружаем датасет\nmeta &lt;- oldFrenchMeta\n\n# допишите ваш код ниже\n# постройте столбиковую диаграмму, \n# показывающую распределение произведений по темам; цветом закодируйте жанр; \n# уберите названия осей; \n# поверните координатную ось; \n# поменяйте тему оформления на черно-белую, \n# а шрифт -- на Palatino; \n# добавьте заголовок \"Plot by [Your Name]\"\n\n\n\n#  экспортируйте график в формате jpg \n# с раширением 300 dpi; \n# в названии файла должна быть \n# ваша фамилия и номер группы\n\n\n\n\n\nSarkar, Deepayan. 2008. Lattice: Multivariate Data Visualization with R. Springer.\n\n\nWickham, Hadley, и Garrett Grolemund. 2016. R for Data Science. O’Reilly. https://r4ds.had.co.nz/index.html.\n\n\nМастицкий, Сергей. 2017. Визуализация данных с помощью ggplot2. ДМК.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "plot.html#footnotes",
    "href": "plot.html#footnotes",
    "title": "2  Визуализации",
    "section": "",
    "text": "Источник: https://bookdown.org/rdpeng/exdata/principles-of-analytic-graphics.html. Русский пересказ: https://habr.com/ru/companies/skillfactory/articles/536012/. Видео: https://youtu.be/6lOvA_y7p7w?si=se_X6UUEM8sPIGdl↩︎\nhttps://youtu.be/a4mvbyNGdBA↩︎\nhttps://www.rdocumentation.org/packages/graphics/versions/3.6.2/topics/par↩︎\nhttps://figshare.com/articles/dataset/The_Diorisis_Ancient_Greek_Corpus/6187256↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Визуализации</span>"
    ]
  },
  {
    "objectID": "tidy.html",
    "href": "tidy.html",
    "title": "3  Опрятные данные",
    "section": "",
    "text": "3.1 Синтаксис tidyverse\nСуществуют два основных “диалекта” R, один из которых опирается главным образом на функции и структуры данных базового R, а другой пользуется синтаксисом tidyverse (Winter 2020). Tidyverse – это семейство пакетов (метапакет), разработанных Хадли Уикхемом и др., которое включает в себя в том числе пакеты dplyr, ggplot2 и многие другие.\n# загрузить все семейство\nlibrary(tidyverse)\n\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.5\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n✔ purrr     1.0.2     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Опрятные данные</span>"
    ]
  },
  {
    "objectID": "tidy.html#синтаксис-tidyverse",
    "href": "tidy.html#синтаксис-tidyverse",
    "title": "3  Опрятные данные",
    "section": "",
    "text": "3.1.1 Tibble\nОсновная структура данных в tidyverse – это tibble, современный вариант датафрейма1. Тиббл, как говорят его разработчики, это ленивые и недовольные датафреймы: они делают меньше и жалуются больше2. Это позволяет решать проблемы на более ранних этапах, что, как правило, приводит к созданию более чистого и выразительного кода.\nОсновные отличия от обычного датафрейма:\n\nтекст по умолчанию конвертируется в строки, а не в факторы;3\nусовершенствованный метод print(), не нужно постоянно вызывать head();\nнет имен рядов;\nдопускает синтаксически “неправильные” имена столбцов;\nпри индексировании не меняет тип данных на вектор и др.\n\n\nload(\"../data/diorisis_meta.Rdata\")\n\n# распечатывает только первые 10 рядов, для каждого столбца указан тип данных, строки пронумерованы\nas_tibble(diorisis_meta)\n\n\n  \n\n\n# индексирование \nhead(as.data.frame(diorisis_meta)[, 1])  # возвращает вектор\n\n[1] \"Achilles Tatius\" \"Aelian\"          \"Aelian\"          \"Aelian\"         \n[5] \"Aeneas Tacticus\" \"Aeschines\"      \n\nas_tibble(diorisis_meta)[,1] # возвращает тиббл\n\n\n  \n\n\n# имена столбцов\ndf &lt;- data.frame('var 1' = 1:2, two = 3:4)\ndf\n\n\n  \n\n\ntbl &lt;- tibble('var 1' = 1:2, two = 3:4)\ntbl\n\n\n  \n\n\n\nПора тренироваться.\n\n\n\n\n\n\nЗадание\n\n\n\nУстановите курс swirl::install_course(\"Getting and Cleaning Data\"). Загрузите библиотеку library(swirl), запустите swirl(), выберите этот курс и пройдите из него урок 1 Manipulating Data with dplyr.\n\n\n\n\n\n\n\n\n\nНа заметку\n\n\n\nПри попытке загрузить урок вы можете получить сообщение об ошибке: /Library/Frameworks/R.framework/Versions/4.1-arm64/Resources/library/swirl/Courses/Getting_and_Cleaning_Data/Manipulating_Data_with_dplyr/lesson.yaml) Scanner error: while scanning a tag at line 205, column 9 did not find expected whitespace or line break at line 205, column 19. Скопируйте из этого сообщения путь до папки с курсом. На MacOS откройте Finder &gt; Go &gt; Go to Folder. Вставьте путь до папки в открывшееся окно, найдите там файл lesson.yaml. Скачайте исправленный файл по ссылке и замените его в папке. Не меняйте название! Обсуждение проблемы здесь.\n\n\nВсе попробовали, не получилось?\n\n\n\n\n\n\nНажмите, чтобы увидеть подсказку.\n\n\n\n\n\nНу и ладно, двигайтесь дальше.\n\n\n\nВсе получилось?\n\n\n\n\n\n\nНажмите, чтобы увидеть подсказку.\n\n\n\n\n\nКласс! Двигайтесь дальше.\n\n\n\nВремя вопросов! Обычный датафрейм или тиббл?\n\n\n\n\n\n\nВопрос\n\n\n\nПо умолчанию распечатывает только первые 10 рядов в консоль.\n\n\n\n\nдатафрейм\n\n\nтиббл\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nМолчаливо исправляет некорректные названия столбцов.\n\n\n\n\nдатафрейм\n\n\nтиббл\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nПо умолчанию конвертирует строки в факторы при импорте данных.\n\n\n\n\nдатафрейм\n\n\nтиббл\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nНе имеет названий рядов.\n\n\n\n\nдатафрейм\n\n\nтиббл\n\n\n\n\n\nКстати, обратили внимание, как работает оператор &lt;= с символьным вектором?\n\n\n3.1.2 Dplyr\nВ уроке swirl выше вы уже немного познакомились с “грамматикой манипуляции данных”, лежащей в основе dplyr4. Здесь об этом будет сказано подробнее. Эта грамматика предоставляет последовательный набор глаголов, которые помогают решать наиболее распространенные задачи манипулирования данными:\n\nmutate() добавляет новые переменные, которые являются функциями существующих переменных;\nselect() выбирает переменные на основе их имен;\nfilter() выбирает наблюдения на основе их значений;\nsummarise() обобщает значения;\narrange() изменяет порядок следования строк.\n\nВсе эти глаголы естественным образом сочетаются с функцией group_by(), которая позволяет выполнять любые операции “по группам”, и с оператором pipe %&gt;% из пакета magrittr.\nВ итоге получается более лаконичный и читаемый код, что можно показать на примере.\n\ndiorisis_meta %&gt;% \n  select(-subgenre) %&gt;% \n  filter(genre == \"Narrative\") %&gt;%  \n  group_by(name) %&gt;% \n  count() %&gt;% \n  arrange(-n)\n\n\n  \n\n\n\nВ базовом R мы бы делали то же самое вот так:\n\ndiorisis_df &lt;- as.data.frame(diorisis_meta)\ndiorisis_select &lt;- diorisis_df[,-5] # remove column\ndiorisis_filter &lt;- diorisis_select[diorisis_select$genre == \"Narrative\", ]\ndiorisis_names &lt;- diorisis_filter$name\ndiorisis_count &lt;- as.data.frame(table(diorisis_names))\ndiorisis_sort &lt;- diorisis_count[order(diorisis_count$Freq, decreasing =T),]\nhead(diorisis_sort)\n\n\n  \n\n\n\nТут должен быть какой-то поучительный вывод. Но вместо него будет задание на кодинг. Вам придется редактировать код, который предложит программа, так что сгруппируйтесь.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс Getting and Cleaning Data и пройдите из него урок 2 Grouping and Chaining with dplyr.\n\n\nПравда или ложь?\n\n\n\n\n\n\nВопрос\n\n\n\nФункция n_distinct() возвращает все уникальные значения.\n\n\n\n\nПравда\n\n\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nЕсли x &lt;- 1:100, то функция quantile(x, probs = 0.9) вернет значения от 91 до 100.\n\n\n\n\nПравда\n\n\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nНа заметку\n\n\n\nКванти́ль в математической статистике — значение, которое заданная случайная величина не превышает с фиксированной вероятностью. В нашем случае 90% данных ниже 90.1.\n\n\nЭто было сложное задание, можно сделать перерыв ☕",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Опрятные данные</span>"
    ]
  },
  {
    "objectID": "tidy.html#опрятные-данные",
    "href": "tidy.html#опрятные-данные",
    "title": "3  Опрятные данные",
    "section": "3.2 Опрятные данные",
    "text": "3.2 Опрятные данные\nНо tidyverse – это не только особый синтаксис, но и отдельная идеология “опрятных данных”. “Сырые” данные, с которыми мы работаем, редко бывают опрятны, и перед анализом их следует “почистить” и преобразовать5.\nОсновные принципы опрятных данных:\n\nотдельный столбец для каждой переменной;\nотдельный ряд для каждого наблюдения;\nу каждого значения отдельная ячейка;\nодин датасет – одна таблица.\n\n\n\n\nПринципы опрятных данных. Источник.\n\n\n\nПосмотрите на учебные тибблы из пакета tidyr и подумайте, какое из этих правил нарушено в каждом случае.\n\ndata(\"table2\")\ntable2\n\n\n  \n\n\ndata(\"table3\")\ntable3\n\n\n  \n\n\ndata(\"table4a\")\ntable4a\n\n\n  \n\n\ndata(\"table4b\")\ntable4b\n\n\n  \n\n\n\nВажные функции для преобразования данных из пакета tidyr:6\n\nseparate() делит один столбец на новые;\nunite() объединяет столбцы;\npivot_longer() удлиняет таблицу;\npivot_wider() расширяет таблицу;\ndrop_na() и replace_na() указывают, что делать с NA и др.\n\nТакже упомянем функцию distinct() из dplyr, которая оставляет только уникальные наблюдения и предсталяет собой аналог базовой unique() для таблиц.\nКроме того, в dplyr есть полезное семейство функций _join, позволяющих объединять данные в различных таблицах.7 Дальше мы потренируемся с ними работать, но сначала пройдем урок swirl. Это достаточно сложный урок (снова понадобится редактировать скрипт), но он нам дальше здорово поможет.\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl(), выберите курс Getting and Cleaning Data и пройдите из него урок 3 Tidying Data with tidyr.\n\n\nПравда или ложь?\n\n\n\n\n\n\nВопрос\n\n\n\nФункция separate() обязательно требует указать разделитель.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nПринципы опрятных данных требуют, чтобы одному наблюдению соответствовал один столбец.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nФункция contains() используется вместе с filter() для выбора рядов.\n\n\n\n\nПравда\nЛожь\n\n\n\n\n\nОтличная работа! Прежде чем двигаться дальше, приведите в порядок table2, 3, 4a-4b (последние две также объедините) в единый датасет.\n\n\n\n\n\n\nЗадание\n\n\n\nПРАКТИЧЕСКОЕ ЗАДАНИЕ 3: БИБЛИОТЕКА GUTENBERG\n\n\n\n\ndevtools::install_github(\"ropensci/gutenbergr\")\nlibrary(gutenbergr)\nlibrary(dplyr)\nlibrary(tidyr)\n\nworks &lt;- gutenberg_works()\n\n# Отберите ряды, в которых gutenberg_author_id равен 65;\n# после этого выберите два столбца: author, title\nmy_data &lt;- works %&gt;% \n  # ваш код здесь\n  \n# Загрузите данные об авторах и выберите столбцы: author, deathdate\nauthors &lt;- gutenberg_authors %&gt;% \n  # ваш код здесь\n\n# Соедините my_data с данными о смерти автора из authors, \n# так чтобы к my_data добавился новый столбец. \n# После этого используйте функцию separate, \n# чтобы разделить столбец с именем и фамилией на два новых: author, name. \n# Удалите столбец с именем автора, оставив только фамилию.\n# Добавьте новый столбец century, \n# используя функцию mutate и данные из столбца deathdate. \n# Используйте оператор pipe, не сохраняйте промежуточные результаты!\n\nmy_data %&gt;% \n  # ваш код здесь",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Опрятные данные</span>"
    ]
  },
  {
    "objectID": "tidy.html#пример-буккроссинг",
    "href": "tidy.html#пример-буккроссинг",
    "title": "3  Опрятные данные",
    "section": "3.3 Пример: буккроссинг",
    "text": "3.3 Пример: буккроссинг\n\n3.3.1 Смотрим на данные\nЗагрузим пример неопрятных данных и попробуем их преобразовать для анализа. Book-Crossing – датасет с рейтингами миллионов книг и обезличенными демографическими данными о более 250 тысячах их читателей. Этот датасет хранится в трех разных файлах, которые надо скачать архивом отсюда. Распечатайте архив, прежде чем выполнять код ниже.\n\nratings &lt;- read_delim(\"../files/BX/BX-Book-Ratings.csv\", delim = \";\")\nratings\n\nbooks &lt;- read_delim(\"../files/BX/BX_Books.csv\", delim = \";\")\nbooks\n\nusers &lt;- read_delim(\"../files/BX/BX-Users.csv\", delim = \";\")\nusers\n\n\nsave(users, file = \"../data/UsersBX.Rdata\")\nsave(books, file = \"../data/BooksBX.Rdata\")\nsave(ratings, file = \"../data/RatingsBX.Rdata\")\n\n\nhead(ratings)\n\n\n  \n\n\nhead(users)\n\n\n  \n\n\nhead(books)\n\n\n  \n\n\n\nЧто не так с этими данными?\n\n\n\n\n\n\nНажмите, чтобы увидеть подсказку\n\n\n\n\n\n\nusers содержит больше одного значения в столбце Location\nмного отсутствующих значений\nданные вводятся самими пользователями через сайт https://www.bookcrossing.com/ ; они могут содержать недостоверную информацию, см. напр. moscow, yukon territory, russia (Юкон – это территория Канады).\nAge представляет собой строку и др.\n\n\n\n\nПрежде чем начинать преобразование, надо сформулировать примерный вопрос и понять, что для нас важно, а что нет.\n\n\n\n\n\n\nНажмите, чтобы увидеть подсказку\n\n\n\n\n\n\nСколько читателей старше 30 лет пользуются сервисом в Австралии?\nВ какие года опубликованы самые популярные книги?\nКто популярнее у читателей, Роулинг или Толкин?\nКакой процент пользователей никогда не оставляет отзывы?\nЕсть ли связь между возрастом и количеством оценок? и т.п.\n\n\n\n\nЧтобы объединить данные, надо понять, через какие переменные они связаны.\n\n\n\n\n\n\nНажмите, чтобы увидеть подсказку\n\n\n\n\n\nОтвет: ratings и books связаны через переменную isbn, ratings и users связаны через переменную User-ID.\n\n\n\n\n\n3.3.2 Трансформируем данные\nНачнем с пользователей.\n\nusers_separated &lt;- users %&gt;% \n  mutate(Age = as.numeric(Age)) %&gt;%\n  filter(!is.na(Age))  %&gt;% # drop_na(Age) тоже решил бы нашу задачу\n  separate(Location, into = c(NA, NA, \"country\"), sep = \",\")\n\nhead(users_separated) # можно было бы не сохранять, но так нагляднее\n\n\n  \n\n\n\nЗдесь можно сразу посмотреть, из каких стран и какого возраста пользователи.\n\nusers_separated %&gt;% \n  group_by(country) %&gt;%\n  count() %&gt;% \n  arrange(-n)\n\n\n  \n\n\n\nПоследние ряды этого тибла выглядят достаточно причудливо:\n\nusers_separated %&gt;% \n  group_by(country) %&gt;%\n  count() %&gt;% \n  arrange(n)\n\n\n  \n\n\n\nЗдесь возможно несколько стратегий. Можно выбрать все ряды с названиями реальных стран либо (если это соответствует исследовательской задаче) какую-то одну страну. Можно и проигнорировать, если происхождение пользователей не так важно.\nДопустим, мы решаем сосредоточиться на Испании. Обратите внимание, что в название страны после разделения функцией separate() попали пробелы, и от них надо избавиться. Это делается при помощи регулярных выражений (о них в другой раз) и функции mutate().\n\nspain_data &lt;- users_separated %&gt;%\n  mutate(country = str_replace_all(country, pattern = \"\\\\s+\", \"\")) %&gt;% # это означает, что пробел мы меняем на \"ничто\", т.е. убираем\n  filter(country == \"spain\") %&gt;% \n  group_by(Age) %&gt;%\n  count() %&gt;% \n  arrange(-n)\n\nhead(spain_data)\n\n\n  \n\n\n\nСтолбиковая диаграмма подходит для визуализации подобных данных:\n\nspain_data %&gt;% \n  ggplot(aes(Age, n)) + \n  geom_bar(stat = \"identity\", col = \"blue\", fill = \"white\") +\n  theme_bw()\n\n\n\n\n\n\n\n\nКакие целеустремленные испанцы! Читают от 0 до 183 лет 😵\nПосле того, как мы убрали лишние пробелы из названий стран, можно фильтровать:\n\nspain_id &lt;- users_separated %&gt;%\n  mutate(country = str_replace_all(country, pattern = \"\\\\s+\", \"\")) %&gt;%\n  filter(country == \"spain\") # на этот раз мы не считаем число наблюдений в группе, а забираем все ряды, которые отвечают условию\n\n\n\n3.3.3 Объединяем данные\nМы уже выяснили, что ratings и users связаны через переменную User-ID, и в ratings хотели бы оставить только те id, которые отвечают заданному условию (страна, возраст и т.п.). Для такого рода объединений как раз подходят функции _join8.\nФункции семейства _join\n\nspain_ratings &lt;- spain_id %&gt;% \n  left_join(ratings) %&gt;% \n  filter(!is.na(ISBN)) %&gt;% \n  filter(`Book-Rating` &gt; 7) %&gt;% # имена синтаксически неправильные, поэтому требуется знак \"`\"\n  group_by(ISBN) %&gt;% \n  count() %&gt;% \n  arrange(-n)\n\nJoining with `by = join_by(`User-ID`)`\n\nspain_ratings\n\n\n  \n\n\n\nОсталось выяснить, что это за книги. Для этого объединяем spain_ratings и books.\n\nspain_books &lt;- spain_ratings %&gt;% \n  filter(n &gt; 2) %&gt;% \n  left_join(books) %&gt;% \n  filter(!is.na(`Book-Title`), !is.na(`Book-Author`)) %&gt;% \n  ungroup()\n\nspain_books\n\n\n  \n\n\n\nКак минимум мы выяснили, что испанцы предпочитают читать по-испански! (Здесь снова можно подумать. Возможно, у одной книги разные ISBN, и стоило группировать не по ISBN, а по названию или автору?)\nОсталось избавиться от неинформативных столбцов (это ссылки, часто битые, на изображения обложки). Если мы знаем номера этих столбцов, то это можно сделать по индексу:\n\nspain_books %&gt;% \n  select(3:5) %&gt;% \n  rename(title = `Book-Title`, author = `Book-Author`)\n\n\n  \n\n\n\nОднако у select() есть функции-помощники9, которые подходят для таких случаев:\n\nstarts_with()\nends_with()\ncontains()\nmatches()\nnum_range()\n\n\nspain_books %&gt;% \n  select(-contains(\"URL\"), -matches(\"Publisher\")) %&gt;% # удалим заодно и издателя\n  rename(title = `Book-Title`, \n         author = `Book-Author`,\n         published = `Year-Of-Publication`) # чиним имена\n\n\n  \n\n\n\nУра! Еще один сложный урок позади. Похвалите себя.\n\n\n\n\n\nWinter, Bodo. 2020. Statistics for Linguists: An Introduction Using R. Routledge.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Опрятные данные</span>"
    ]
  },
  {
    "objectID": "tidy.html#footnotes",
    "href": "tidy.html#footnotes",
    "title": "3  Опрятные данные",
    "section": "",
    "text": "https://r4ds.had.co.nz/tibbles.html↩︎\nhttps://tibble.tidyverse.org/↩︎\nПодробнее о том, почему так вообще происходит: https://simplystatistics.org/posts/2015-07-24-stringsasfactors-an-unauthorized-biography/↩︎\nhttps://dplyr.tidyverse.org/↩︎\nhttps://r4ds.had.co.nz/tidy-data.html↩︎\nhttps://tidyr.tidyverse.org/reference/index.html↩︎\nhttps://r4ds.had.co.nz/relational-data.html↩︎\nhttps://r4ds.had.co.nz/relational-data.html↩︎\nhttps://r4ds.had.co.nz/transform.html↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Опрятные данные</span>"
    ]
  },
  {
    "objectID": "iterate.html",
    "href": "iterate.html",
    "title": "4  Функциональное программирование",
    "section": "",
    "text": "4.1 Зачем писать функции?\nПрограммировать на R – прежде всего значит писать функции. Несмотря на десятки тысяч функций, обитающих в тысячах пакетов, рано или поздно вам понадобится своя функция, которая будет подходить для решения именно ваших задач.\nФункция и код – не одно и то же. Чтобы стать функцией, кусок кода должен, как минимум, получить имя. Зачем давать имя коду, который и так работает?\nВот три причины, которые приводит Хадли Уикхем:\nЧтобы определить функцию, необходимо дать ей имя. Машине все равно, как вы назовете функцию, но тем, кто будет читать код, не все равно. Имена должны быть информативы (поэтому функция f() – плохая идея). Также не стоит переписывать уже существующие в R имена!\nДалее следует определить формальные аргументы и, при желании, значения по умолчанию. Тело функции пишется в фигурных скобках. В конце кода функции располагается команда return(); если ее нет, то функция возвращает последнее вычисленное значение (см. здесь о том, когда что предпочесть).\nНаписание функций – навык, который можно бесконечно совершенствовать. Начать проще всего с обычного кода. Убедившись, что он работает как надо, вы можете упаковать его в функцию.\nНапример, нам нужна функция, которая ищет совпадения в двух векторах и возвращает совпавшие элементы. Сначала решим задачу для двух векторов.\nx &lt;- c(\"гнев\", \"богиня\", \"воспой\")\ny &lt;- c(\"в\", \"мысли\", \"ему\", \"то\", \"вложила\", \"богиня\", \"державная\", \"гера\")\nidx &lt;- which(x %in% y) # 2\nx[idx]\n\n[1] \"богиня\"\nТеперь заменяем фактические переменные на формальные.\ncommon_words &lt;- function(x, y){\n  idx &lt;- which(x %in% y)\n  x[idx]\n}\nИ применяем к новым данным.\nx &lt;- c(\"лишь\", \"явилась\", \"заря\", \"розоперстая\", \"вестница\", \"утра\")\ny &lt;- c(\"вестница\", \"утра\", \"заря\", \"на\", \"великий\", \"олимп\", \"восходила\")\ncommon_words(x, y)\n\n[1] \"заря\"     \"вестница\" \"утра\"\nУра, все работает! Запомните простое правило: если вы трижды скопировали код, пора писать функцию!\nнабрать имя функции без аргументов и без скобок\n\n\nединственный способ — найти код функции в репозитории на GitHub\n\n\nвызвать help к функции\n\n\nиспользовать специальную функцию для просмотра кода",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функциональное программирование</span>"
    ]
  },
  {
    "objectID": "iterate.html#зачем-писать-функции",
    "href": "iterate.html#зачем-писать-функции",
    "title": "4  Функциональное программирование",
    "section": "",
    "text": "у функции есть выразительное имя, которое облегчает понимание кода;\nпри изменении требований необходимо обновлять код только в одном месте, а не во многих;\nменьше вероятность случайных ошибок при копировании (например, обновление имени переменной в одном месте, но не в другом)\n\n\nWriting good functions is a lifetime journey.\n— Hadley Wickham\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗагрузите библиотеку swirl, выберите курс R Programming E и пройдите из него урок 9 Functions.\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nДля просмотра исходного кода любой функции необходимо…",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функциональное программирование</span>"
    ]
  },
  {
    "objectID": "iterate.html#область-видимости-переменных",
    "href": "iterate.html#область-видимости-переменных",
    "title": "4  Функциональное программирование",
    "section": "4.2 Область видимости переменных",
    "text": "4.2 Область видимости переменных\nНапишем функцию, которая будет центрировать данные, то есть вычитать среднее из каждого значения (забудем на время, что это уже делает базовая scale()):\n\ncenter &lt;- function(x){ \n  n = x - mean(x)\n  return(n) \n}\n\nx &lt;- c(5, 10, 15)\ncenter(x) \n\n[1] -5  0  5\n\n\nВнутри нашей функции есть переменная n, которую не видно в глобальном окружении. Это локальная переменная. Область ее видимости – тело функции. Когда функция возвращает управление, переменная исчезает. Обратное неверно: глобальные переменные доступны в теле функции.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функциональное программирование</span>"
    ]
  },
  {
    "objectID": "iterate.html#аргументы-функции",
    "href": "iterate.html#аргументы-функции",
    "title": "4  Функциональное программирование",
    "section": "4.3 Аргументы функции",
    "text": "4.3 Аргументы функции\nФункция может принимать произвольное число аргументов. Доработаем наш код:\n\ncenter &lt;- function(x, na.rm = F){\n  if(na.rm) { x &lt;- x[!is.na(x)]} # добавим условие\n  x - mean(x) # на этот раз без return()\n}\n\nx &lt;- c(5, 10, NA)\ncenter(x)\n\n[1] NA NA NA\n\n\nЧто произошло? Почему следующий код выдает другой результат?\n\ncenter(x, na.rm = T)\n\n[1] -2.5  2.5\n\n\nВычисления в R ленивы, то есть они откладываются до тех пор, пока не понадобится результат. Если вы зададите аргумент, который не нужен в теле функции, ошибки не будет.\n\ncenter &lt;- function(x, na.rm = F, what_is_your_name){\n  if(na.rm) { x &lt;- x[!is.na(x)]} # добавим условие\n  x - mean(x) # на этот раз без return()\n}\n\ncenter(x, na.rm = T)\n\n[1] -2.5  2.5\n\ncenter(x, na.rm = T, what_is_your_name = \"Locusclassicus\")\n\n[1] -2.5  2.5\n\n\nЧасто имеет смысл добавить условие остановки или сообщение, которое будет распечатано в консоль при выполнении.\n\ncenter &lt;- function(x){\n  if (length(x) == 1) {stop(\"И без меня посчитаете\")}\n  x - mean(x) # на этот раз без return()\n}\n\nx &lt;- 10\ncenter(x) # вернет ошибку",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функциональное программирование</span>"
    ]
  },
  {
    "objectID": "iterate.html#векторизируй-это",
    "href": "iterate.html#векторизируй-это",
    "title": "4  Функциональное программирование",
    "section": "4.4 Векторизируй это",
    "text": "4.4 Векторизируй это\nТеперь самое главное: если мы хотим применить функцию к каждому элементу вектора, то в большинстве случаев достаточно просто вызвать функцию. Это называется векторизация.\nЭто относится не только ко многим встроенным функциям R, но и к даже к операторам. x + 4 в действительности представляет собой +(x, 4):\n\nx &lt;- c(1.2, 2.51, 3.8)\n\n`+`(x, 4) \n\n[1] 5.20 6.51 7.80\n\n\nКлючевую роль здесь играет переработка данных, о которой мы уже говорили: короткий вектор повторяется до тех пор, пока его длина не сравняется с длиной более длинного вектора. Как-то так:\n\\[\\left(\n    \\begin{array}{c}\n      1.2 \\\\\n      2.51 \\\\\n      3.8\n    \\end{array}\n  \\right) + \\left(\n    \\begin{array}{c}\n      4 \\\\\n      4 \\\\\n      4\n    \\end{array}\n  \\right)\\]\nПонимание того, как действуют векторизованные вычисления, очень важно для написания корректного кода. Посмотрите на пример ниже: почему функция is_article() возвращает два значения, хотя на входе только одно?\n\nis_article &lt;- function(x){\n  x == c(\"a\", \"the\")\n}\n\nx &lt;- \"the\"\nis_article(x)\n\n[1] FALSE  TRUE\n\n\nПоскольку векторы сравниваются поэлементно, то функция ниже вернет разный результат в зависимости от того, в каком порядке заданы элементы:\n\nx &lt;- c(\"just\", \"the\")\nis_article(x) \n\n[1] FALSE  TRUE\n\nx &lt;- c(\"the\", \"just\")\nis_article(x) # взрыв мозга\n\n[1] FALSE FALSE\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nПодумайте, вектор какого типа и какой длины вернет код ниже.\n\n\n\nis_article &lt;- function(x) { \n  articles &lt;- c(\"a\", \"the\")\n  x %in% articles\n}\n\nx &lt;- c(rep(\"the\", 5), rep(\"if\", 5))\nis_article(x)\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nНапишите функцию awesome_plot, которая будет принимать в качестве аргументов два вектора, трансформировать их в тиббл и строить диаграмму рассеяния при помощи ggplot(). Задайте цвет и прозрачность точек, а в подзаголовке выведите коеффицент корреляции.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функциональное программирование</span>"
    ]
  },
  {
    "objectID": "iterate.html#векторизованные-конструкции",
    "href": "iterate.html#векторизованные-конструкции",
    "title": "4  Функциональное программирование",
    "section": "4.5 Векторизованные конструкции",
    "text": "4.5 Векторизованные конструкции\n\n4.5.1 Циклы\nЕще один способ повторить действия в R, при этом не копируя один и тот же код много раз, – это циклы.\n\nОдин из главных принципов программирования на R гласит, что следует обходиться без циклов, а если это невозможно, то циклы должны быть простыми.\n— Нормат Мэтлофф\n\nСуществует два основных цикла: цикл for и цикл while. На практике чаще используется цикл for, потому что цикл while легко отправить в бесконечность.\n\n4.5.1.1 Цикл for\nЦикл ниже считает количество букв для каждого слова в векторе. Вы можете заметить, что в циклах часто используется буква i. Но никакой особой магии в ней нет, имя переменной можно изменить.\n\ny &lt;- c(\"в\", \"мысли\", \"ему\", \"то\", \"вложила\", \"богиня\", \"державная\", \"гера\")\n\nresult &lt;- c()\nfor(i in y) { \n  n &lt;- nchar(i)\n  result &lt;- c(result, n)\n}\n\nresult\n\n[1] 1 5 3 2 7 6 9 4\n\n\nВ данном случае мы указали, что надо совершить какую-то операцию над каждым элементом вектора; но по сути это избыточно, потому что nchar() тоже векторизована.\n\nnchar(y)\n\n[1] 1 5 3 2 7 6 9 4\n\n\nПоэтому чаще цикл for применяют к другим структурам данных. Например, к спискам и датафреймам. Загрузим и немного изменим датасет о гапаксах у Платона. Изменения нужны, так как цикл работает для данных только одного типа, в то время как в нашей таблице столбец dialogue содержит символьные строки, а group – фактор. Обратите внимание, что оператор pipe и функции из dplyr работают и с обычными датафреймами:\n\nrownames(hapax_plato) &lt;- hapax_plato$dialogue \n\nhapax_plato_num &lt;- hapax_plato %&gt;% select(-group, -dialogue) # \nstr(hapax_plato_num)\n\n'data.frame':   26 obs. of  3 variables:\n $ words: chr  \"8745\" \"8311\" \"17944\" \"4950\" ...\n $ hapax: chr  \"36\" \"31\" \"122\" \"104\" ...\n $ ratio: chr  \"0.004\" \"0.004\" \"0.007\" \"0.021\" ...\n\n\nСейчас все данные в нашей таблице имеют тип chr, то есть строка, и при помощи цикла мы можем их трансформировать.\n\nfor (i in seq_along(hapax_plato_num)) {  # seq_along ≈ 1:length(x)\n  hapax_plato_num[,i] &lt;- as.numeric(hapax_plato_num[,i])\n}\n\nstr(hapax_plato_num) # убеждаемся, что все получилось\n\n'data.frame':   26 obs. of  3 variables:\n $ words: num  8745 8311 17944 4950 4169 ...\n $ hapax: num  36 31 122 104 19 87 15 125 12 32 ...\n $ ratio: num  0.004 0.004 0.007 0.021 0.005 0.007 0.003 0.005 0.003 0.008 ...\n\n\nПри помощи циклов можно не только трансформировать данные, но и создавать новые. Чтобы посчитать среднее для столбца, цикл писать не надо: для этого есть функция colSums() (или, для других задач, rowSums()). А вот посчитать медиану таким образом не получится, тут может пригодиться цикл.\n\nlibrary(tictoc)\n\ntic()\nmedians &lt;- c()\nfor (i in seq_along(hapax_plato_num)) { \n  m &lt;- median(hapax_plato_num[,i])\n  medians &lt;- c(medians, m)\n}\ntoc()\n\n0.003 sec elapsed\n\nmedians\n\n[1] 15589.500    94.500     0.007\n\n\nМы сохранили результат, инициировав пустой вектор, к которому затем привязали данные по каждому столбцу. Это не всегда хорошая идея, поскольку для больших данных может сильно замедлить цикл1. Еще один способ – сразу инициировать вектор нужной длины. Сравнить скорость можно при помощи функций из пакета tictoc.\n\ntic()\nmedians &lt;- vector(\"double\", ncol(hapax_plato_num))\nfor (i in seq_along(hapax_plato_num)) { \n  medians[i] &lt;- median(hapax_plato_num[,i])\n}\ntoc()\n\n0.003 sec elapsed\n\n\nВторой способ чуть быстрее, и для больших данных это может быть существенно.\n\n\n4.5.1.2 Цикл while\nКак уже говорилось, с циклами while стоит быть осторожнее. Посмотрите, например, на этот цикл, который перебирает слова, пока не найдет слово длиной 6 букв. Что могло пойти не так?\n\ntic()\nk &lt;- 0\nn &lt;- 0\nwhile (n != 6) {\n  k &lt;- k + 1\n  n &lt;- nchar(y[k])\n}\ny[k]\n\n[1] \"богиня\"\n\ntoc()\n\n0.005 sec elapsed\n\n\nТо же самое можно сделать без цикла, причем быстрее!\n\ntic()\ny[nchar(y) == 6][1] \n\n[1] \"богиня\"\n\ntoc()\n\n0.001 sec elapsed\n\n\nВ целом, ничего незаконного в циклах нет, но\n\nмножество вложенных друг в друга циклов сложно воспринимать;\nпорой они могут замедлить выполнение кода.\n\nИ в базовом R, и в диалекте tidyverse для этого есть несколько решений, о которых скажем чуть ниже. Сначала рассмотрим еще одну векторизованную конструкцию – условие.\n\n\n\n4.5.2 Условия\nИногда необходимо ограничить выполнение функции неким условием. Короткие условия можно писать в одну строку без фигурных скобок.\n\nif(any(nchar(y) &gt; 6)) print(\"многабукв\")\n\n[1] \"многабукв\"\n\n\nБолее сложные и множественные условия требуют фигурных скобок. Можно сравнить это с условным периодом: протасис (всегда либо TRUE, либо FALSE) в круглых скобках, аподосис в фигурных.\n\nif (sum(nchar(y)) &gt; 10) {\n  print(\"много букв\")\n} else if (sum(nchar(y)) &lt; 5) {\n  print(\"мало букв\")\n} else {\n  print(\"норм букв\")\n}\n\n[1] \"много букв\"\n\n\nТакже в R можно использовать специальную функцию:\n\nifelse((sum(nchar(y)) &gt; 10), \"много букв\", \"мало букв\")\n\n[1] \"много букв\"\n\n\nПрописывая условие, не забывайте, что применение булева оператора к вектору возвращает логический вектор:\n\nx &lt;- c(1:10)\nx &gt;= 5\n\n [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE\n\n\nТакое условие вернет ошибку.\n\nif (x &gt;= 5) print(\"все сломалось\")\n\nError in if (x &gt;= 5) print(\"все сломалось\"): the condition has length &gt; 1\n\n\nМожно скорректировать код так:\n\nif (any(x &gt;= 5)) print(\"все сработало\")\n\n[1] \"все сработало\"\n\n\nПо той же причине внутри условия не надо использовать логические операторы | (“или”) или & (“и”), потому что они векторизованы:\n\nx &lt; 3 | x &gt; 7\n\n [1]  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nПРАКТИЧЕСКОЕ ЗАДАНИЕ 4: ГАРРИ ПОТТЕР\n\n\n\n\n# скачайте датасет о Гарри Поттере (источник: сайт Британской библиотеки)  \nmy_url &lt;- \"https://github.com/locusclassicus/text_analysis_2024/raw/main/files/HP.zip\"\ndownload.file(url = my_url, destfile = \"HP.zip\")\n\n\n# после этого перейдите в директорию с архивом и распакуйте его \n\nunzip(\"HP.zip\")\n\n# сохраните список всех файлов с расширением .csv, \n# используя подходящую функцию из base R\n\n# ваш код здесь\n# my_files &lt;- \n\n# напишите цикл, который:\n# 1) прочитает все файлы из my_files, используя для этого функцию read_csv() из пакета readr\n# (аргумент show_col_types установите на FALSE);\n# 2) для каждого датасета выяснит количество рядов _без_ NA в столбце BNB Number;\n# 3) разделит число таких рядов на общее число рядов;\n# 4) вернет таблицу c четырьми столбцами: \n# - название файла (id), \n# - число рядов (total), \n# - число рядов без NA (complete), \n# - доля полных рядов (ratio)\n\nmy_df &lt;- data.frame(id = my_files, \n                    total = rep(0, length(my_files)),\n                    complete = rep(0, length(my_files)),\n                    ratio = rep(0, length(my_files)))\n\nfor (i in 1:length(my_files)) {\n  # ваш код здесь\n}",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функциональное программирование</span>"
    ]
  },
  {
    "objectID": "iterate.html#вместо-циклов-семейство-_apply",
    "href": "iterate.html#вместо-циклов-семейство-_apply",
    "title": "4  Функциональное программирование",
    "section": "4.6 Вместо циклов: семейство _apply",
    "text": "4.6 Вместо циклов: семейство _apply\nФункция tapply() из базового R принимает на входе вектор, фактор (или список факторов) и функцию. Каждый фактор должен быть той же длины, что и вектор. Код ниже считает среднюю долю гапаксов по группам диалогов:\n\n# подготавливаем векторы \nmy_fct &lt;- as.factor(hapax_plato$group)\nmy_vct &lt;- as.numeric(hapax_plato$ratio)\n\n# применяем к ним функцию mean()\ntapply(my_vct, my_fct, mean)\n\n         1          2          3 \n0.00550000 0.00750000 0.01133333 \n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nПодумайте, как решить эту задачу на диалекте tidyverse.\n\n\n\nЕсли группировка не нужна, то подойдет функция apply(): она вызывает функцию для каждого ряда или столбца матрицы или датафрейма. В качестве второго аргумента функция принимает 1 (для вычислений по рядам) или 2 (для вычислений по столбцам).\n\ntic()\nround(apply(hapax_plato_num, 2, mean), 3)\n\n    words     hapax     ratio \n19364.423   146.692     0.007 \n\ntoc()\n\n0.001 sec elapsed\n\n\nЭти функции работают быстрее циклов. Сравните:\n\ntic()\nmy_means &lt;- c()\nfor (i in seq_along(hapax_plato_num)) {  \n  m &lt;- round(mean(hapax_plato_num[,i]), 3)\n  my_means &lt;- c(my_means, m)\n}\nmy_means\n\n[1] 19364.423   146.692     0.007\n\ntoc()\n\n0.003 sec elapsed\n\n\nФункция apply() позволяет применять к данным собственные функции, в том числе анонимные.\n\nhapax_centered &lt;- apply(hapax_plato_num, 2, function(x) x - mean(x))\nhead(hapax_centered)\n\n                words      hapax         ratio\nApology    -10619.423 -110.69231 -0.0031538462\nCharmides  -11053.423 -115.69231 -0.0031538462\nCratylus    -1420.423  -24.69231 -0.0001538462\nCritias    -14414.423  -42.69231  0.0138461538\nCrito      -15195.423 -127.69231 -0.0021538462\nEuthydemus  -6911.423  -59.69231 -0.0001538462\n\n\nТакже можно использовать грамматику трансформации данных dplyr:\n\ntic()\nas_tibble(hapax_plato_num) %&gt;% \n  mutate(words = words - mean(words), \n         hapax = hapax - mean(hapax),\n         ratio = ratio - mean(ratio))\ntoc()\n\nВидно, что по времени мы при этом сильно не выигрываем; к тому же, нам пришлось повторить один код три раза. Значит, надо что-то менять. Например, так2:\n\ntic()\nas_tibble(hapax_plato_num) %&gt;% \n  mutate_all(function(x) x - mean(x))\ntoc()\n\nИли даже так3:\n\nfn &lt;- function(x) x - mean(x)\nas_tibble(hapax_plato_num) %&gt;%\n  mutate(across(1:3, fn)) %&gt;% \n  invisible()\n\nВ любом случае, нам удалось обойтись без цикла, код понятен и хорошо читается.\nФункции lapply() и sapply() подходят для применения функций к спискам (и к датафреймам, которые по сути представляют собой прямоугольные списки).\nЧтобы понять, как они работают, сначала создадим список.\n\n\n\n\n\n\nНа заметку\n\n\n\nПри анализе текста со списками приходится иметь дело достаточно часто: объекты типа stylo.corpus, которые создает пакет stylo по сути являются списками.\n\n\nСоздадим игрушечный корпус из двух текстов.\n\nx &lt;- c(\"гнев\", \"богиня\", \"воспой\")\ny &lt;- c(\"в\", \"мысли\", \"ему\", \"то\", \"вложила\", \"богиня\", \"державная\", \"гера\")\ncorpus &lt;- list(x = x, y = y)\n\nНаш условный корпус – это список из 2 элементов (текстов), а каждый текст хранится как символьный вектор. Допустим, мы хотим взять из каждого текста выборку размером 5 слов, то есть применить функцию sample() к элементам списка. При помощи lapply() (l = list) это делается так:\n\nset.seed(0211) \nlapply(corpus, sample, 5, replace = T)\n\n$x\n[1] \"воспой\" \"воспой\" \"воспой\" \"богиня\" \"воспой\"\n\n$y\n[1] \"державная\" \"вложила\"   \"то\"        \"мысли\"     \"вложила\"  \n\n\nФункция sapply() ведет себя так же, но упрощает результат до вектора или матрицы (s = simplify).\n\nsapply(corpus, sample, 5, replace = T)\n\n     x        y          \n[1,] \"богиня\" \"ему\"      \n[2,] \"гнев\"   \"державная\"\n[3,] \"гнев\"   \"ему\"      \n[4,] \"богиня\" \"то\"       \n[5,] \"воспой\" \"мысли\"    \n\n\nФункция vapply() позволяет задать тип данных на выходе.\n\nvapply(corpus, sample, size = 5, replace = T, character(5))\n\n     x        y        \n[1,] \"воспой\" \"то\"     \n[2,] \"богиня\" \"гера\"   \n[3,] \"гнев\"   \"вложила\"\n[4,] \"гнев\"   \"гера\"   \n[5,] \"гнев\"   \"мысли\"  \n\n\nПоскольку наш “корпус” – это список, применять грамматику dplyr не очень удобно. Но списко легко превращается в таблицу:\n\ncorpus_tbl &lt;- stack(corpus) %&gt;% \n  as_tibble()\ncorpus_tbl\n\n\n  \n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nИспользуйте relocate() и rename(), чтобы поменять столбцы местами и переименовать их.\n\n\n\nПовторные выборки из тиббла можно делать так:\n\nset.seed(0211)\ncorpus_tbl %&gt;% \n  group_by(ind) %&gt;% \n  sample_n(size = 5, replace = T)\n\n\n  \n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nПройдите урок 10 lapply and sapply и урок 11 vapply and tapply из курса R Programming E в swirl.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функциональное программирование</span>"
    ]
  },
  {
    "objectID": "iterate.html#purrr",
    "href": "iterate.html#purrr",
    "title": "4  Функциональное программирование",
    "section": "4.7 Purrr",
    "text": "4.7 Purrr\n\n4.7.1 map()\nПо-настоящему мощный инструмент для итераций – это пакет purrr из семейства tidyverse4. Разработчики предупреждают, что потребуется время, чтобы овладеть этим инструментом (Wickham и Grolemund 2016).\n\nYou should never feel bad about using a loop instead of a map function. The map functions are a step up a tower of abstraction, and it can take a long time to get your head around how they work.\n— Hadley Wickham & Garrett Grolemund\n\nВ семействе функций map_ из этого пакета всего 23 вариации5. Вот основные из них:\n\nmap()\nmap_lgl()\nmap_int()\nmap_dbl()\nmap_chr()\n\nВсе они принимают на входе данные и функцию (или формулу), которую следует к ним применить, и возвращают результат в том виде, который указан после подчеркивания. Просто map() вернет список, а map_int() – целочисленный вектор, и т.д.\nВоспользуемся возможностями purrr, чтобы исследовать датасет starwars из пакета dplyr. Для начала узнаем число отсутствующих значений в каждом столбце. Тильда (~) указывает на то, что мы используем формулу.\n\nlibrary(purrr)\ndata(starwars)\nmap_int(starwars, ~sum(is.na(.)))\n\n      name     height       mass hair_color skin_color  eye_color birth_year \n         0          6         28          5          0          0         44 \n       sex     gender  homeworld    species      films   vehicles  starships \n         4          4         10          4          0          0          0 \n\n\nОбратите внимание, что map_int, как и map_dbl возвращает именованный вектор. Чтобы избавиться от имен, можно использовать unname():\n\nunname(map_chr(starwars, class))\n\n [1] \"character\" \"integer\"   \"numeric\"   \"character\" \"character\" \"character\"\n [7] \"numeric\"   \"character\" \"character\" \"character\" \"character\" \"list\"     \n[13] \"list\"      \"list\"     \n\n\n\n\nИспользуйте map_dbl и n_distinct, чтобы узнать число уникальных наблюдений в каждом столбце.\n\n\nЕсли функция принимает дополнительные аргументы, их можно задать после названия функции. В таком случае для каждого вызова функции будет использовано это значение аргумента. В примере ниже это аргумент na.rm. Заметьте, что map можно использовать с оператором pipe %&gt;%:\n\nstarwars %&gt;% \n  select(mass, height) %&gt;% \n  map(mean, na.rm = TRUE)\n\n$mass\n[1] 97.31186\n\n$height\n[1] 174.6049\n\n\nПри вызове map_df есть дополнительная возможность сохранить названия столбцов, используя аргумент .id:\n\nstarwars %&gt;% \n  map_df(~data.frame(distinct = n_distinct(.x),\n                     class = class(.x)),\n         .id = \"variable\"\n         )\n\n\n  \n\n\n\nФункции map можно передать пользовательскую функцию. Для примера создадим функцию describe_vec(), которая возвращает строку с длиной и классом вектора, и применим ее к игрушечному корпусу, который мы создали выше.\n\n# пользовательская функция\ndescribe_vec &lt;- function(vec){\n  l = paste(\"Длина вектора: \", length(vec))\n  c = paste(\"Класс вектора: \", class(vec))\n  result = paste(l, c, sep = \" | \")\n  return(result)\n}\n\nunname(map_chr(corpus, describe_vec))\n\n[1] \"Длина вектора:  3 | Класс вектора:  character\"\n[2] \"Длина вектора:  8 | Класс вектора:  character\"\n\n\nКроме того, мы можем передать map анонимную функцию:\n\nmap_chr(corpus, \n        function(x) paste(\"Длина вектора: \", length(x))\n        )\n\n                  x                   y \n\"Длина вектора:  3\" \"Длина вектора:  8\" \n\n\n\n\n4.7.2 map2()\nЕсли необходимо несколько раз вызывать одну и ту же функцию с двумя аргументами, используется функция map2() 6. Аргументы, которые меняются при каждом вызове, пишутся до функции; аргументы, которые остаются неизменны, – после.\n\nmean = list(5, 10, -3)\nsd = list(1, 5, 50)\nmap2(mean, sd, rnorm, n = 5)\n\n[[1]]\n[1] 5.727572 4.812749 4.528140 6.565481 4.356073\n\n[[2]]\n[1] 18.6183347  0.5775309 23.3592929  3.2133071 15.5702820\n\n[[3]]\n[1] -10.13466  51.54818 -23.10523 -12.53555 -66.80735\n\n\n\n\n\n\n_Как работает map2()_\n\n\n\nЭто можно обобщить следующим образом (источник):\n\nМожно было бы предположить, что должны быть и map3(), map4() и т.д., но во всех случаеях, когда у функции больше двух аргументов, используется pmap().\nВ анализе текстовых данных функция map2() применяется, например, при создании скользящего окна. Такие окна используются при создании эмбеддингов.7\nРазделим наш игрушечный корпус на окна. Функция вернет список с тибблами, число рядов в каждом из которых соответствует заданному размеру окна.\n\nwindows &lt;- slider::slide(corpus_tbl, ~.x, .after = 1)\nwindows[[1]]\n\n\n  \n\n\n\nДля анализа этих данных каждому окну следует присвоить id. Здесь пригодится map2().\n\nout &lt;- map2(.x = windows, .y = 1:length(windows), ~ mutate(.x, window_id = .y)) # out  -- это список\nout[[1]]\n\n\n  \n\n\n\nПоскольку аргумент .y – это, по сути, индекс, можно было бы использовать функцию imap():\n\nout &lt;- imap(.x = windows, ~ mutate(.x, window_id = .y))\nout[[1]]\n\n\n  \n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nУстановите курс swirl::install_course(\"Advanced R Programming\") и пройдите из него урок 3 Functional Programming with purrr.\n\n\nНесколько вопросов для самопроверки.\n\n\n\n\n\n\nВопрос\n\n\n\nФункции-предикаты (predicate functions) возвращают TRUE или FALSE. Выберите из списка все функции-предикаты.\n\n\n\n\nevery()\n\n\nsome()\n\n\nnone()\n\n\nhas_element()\n\n\nis.factor()\n\n\nkeep()\n\n\ndiscard()\n\n\nis.numeric()\n\n\ndetect()\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nКакие из функций ниже принимают в качестве аргумента функции-предикаты?\n\n\n\n\nevery()\n\n\nsome()\n\n\nnone()\n\n\nhas_element()\n\n\nis.factor()\n\n\nkeep()\n\n\ndiscard()\n\n\nis.numeric()\n\n\ndetect()\n\n\n\n\n\n\n\n\n4.7.3 Дополнительные возможности purrr\nВы уже поняли, что благодаря циклам можно прочитать сразу несколько файлов (см. Практическое задание выше). Та же задача решается и при помощи map. Рассмотрим на том же примере с датасетом Британской библиотеки про Гарри Поттера. Если вы еще не скачали архив, посмотрите выше, как это сделать.\nУзнаем имена файлов в директории и прочитаем их все одним вызовом функции (подробнее про формат .csv будет рассказано в следующем уроке).\n\n# чтение файлов \nlibrary(readr)\n\nfiles &lt;- list.files(\"../files/HP\", pattern = \".csv\", full.names = TRUE)\n\nHP &lt;- map(files, read_csv, col_types = cols())\n\nОбъект HP – это список. В нем пять элементов, так как на входе у нас было пять файлов. Для удобства назначим имена элементам списка. Пока можно не вникать, что здесь происходит – регулярные выражения мы рассмотрим в одном из следующих уроков.\n\nlibrary(stringr) \nnames(HP) &lt;- str_extract(files, \"\\\\w+(?=.csv)\")\nnames(HP)\n\n[1] \"classification\" \"names\"          \"records\"        \"titles\"        \n[5] \"topics\"        \n\n\nНачнем с простого: при помощи map можно извлечь столбцы (по имени) или ряды (по условию) из всех пяти таблиц. Прежде чем выполнить код ниже, подумайте, как будет выглядеть результат.\n\n# извлечь столбцы\nmap(HP, select, `BNB number`)\n\n# извлечь ряды\nmap(HP, filter, !(is.na(`BNB number`)))\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nИзвлеките все уникальные названия (столбец Title) из всех пяти таблиц в HP. Используйте функцию distinct.\n\n\n\nЧто, если мы не знаем заранее, какие столбцы есть во всех пяти таблицах, и хотим это выяснить? Для этого подойдет функция reduce() из того же purrr. Она принимает на входе вектор (или список) и функцию и применяет функцию последовательно к каждой паре значений.\n\n\n\nИсточник.\n\n\n\nВоспользуемся этим, чтобы найти общие для всех таблиц имена столбцов.\n\nmap(HP, colnames) %&gt;% \n  reduce(intersect)\n\n [1] \"Dewey classification\"       \"BL record ID\"              \n [3] \"Type of resource\"           \"Content type\"              \n [5] \"Material type\"              \"BNB number\"                \n [7] \"ISBN\"                       \"ISSN\"                      \n [9] \"Name\"                       \"Dates associated with name\"\n[11] \"Type of name\"               \"Role\"                      \n[13] \"Title\"                      \"Series title\"              \n[15] \"Number within series\"       \"Country of publication\"    \n[17] \"Place of publication\"       \"Publisher\"                 \n[19] \"Date of publication\"        \"Edition\"                   \n[21] \"Physical description\"       \"BL shelfmark\"              \n[23] \"Genre\"                      \"Languages\"                 \n[25] \"Notes\"                     \n\n\nЕще одна неочевидная возможность функции reduce - объединение нескольких таблиц в одну одним вызовом. Например, так:\n\nHP_joined &lt;- HP %&gt;% \n  reduce(left_join)\n\nТеперь можно почистить данные и построить несколько разведывательных графиков.\n\nlibrary(ggplot2)\nlibrary(tidyr)\ndata_sum &lt;- HP_joined %&gt;% \n  separate(`Date of publication`, into = c(\"year\", NA)) %&gt;% \n  separate(`Country of publication`, into = c(\"country\", NA), sep = \";\") %&gt;%\n  mutate(country = str_squish(country)) %&gt;% \n  mutate(country = \n           case_when(country == \"England\" ~ \"United Kingdom\",\n                     country == \"Scotland\" ~ \"United Kingdom\",\n                     TRUE ~ country)) %&gt;% \n  group_by(year, country) %&gt;% \n  summarise(n = n()) %&gt;% \n  filter(!is.na(year)) %&gt;% \n  filter(!is.na(country)) \n  \n\n# график\ndata_sum %&gt;% \n  ggplot(aes(year, n, fill = country)) + \n  geom_col() + \n  xlab(NULL) +\n  theme(axis.text.x = element_text(angle = 90))\n\n\n\n\n\n\n\n\nВ качестве небольшого бонуса к этому уроку построим облако слов. Вектор слов возьмем из столбца Topic.\n\nlibrary(tidyr)\ndata_topics &lt;- HP_joined %&gt;% \n  filter(!is.na(Topics)) %&gt;% \n  separate(Topics, into = c(\"topic\", NA)) %&gt;% \n  mutate(topic = tolower(topic)) %&gt;% \n  group_by(topic) %&gt;% \n  summarise(n = n()) %&gt;% \n  filter(!topic %in% c(\"harry\", \"rowling\", \"potter\", \"children\", \"literary\"))\n\n\npal &lt;- c(\"#f1c40f\", \"#34495e\", \n         \"#8e44ad\", \"#3498db\",\n         \"#2ecc71\")\n\nlibrary(wordcloud)\n\nLoading required package: RColorBrewer\n\npar(mar = c(1, 1, 1, 1))\nwordcloud(data_topics$topic, \n          data_topics$n,\n          min.freq = 3,\n          #max.words = 50, \n          scale = c(3, 0.8),\n          colors = pal, \n          random.color = T, \n          rot.per = .2,\n          vfont=c(\"script\",\"plain\")\n          )\n\n\n\n\n\n\n\n\nИнтерактивное облако слов можно построить с использованием пакета wordcloud2. Сделаем облако в форме шляпы волшебника!\n\n# devtools::install_github(\"lchiffon/wordcloud2\")\nlibrary(wordcloud2)\n\n\nwordcloud2(data_topics, \n           figPath = \"./images/hat.png\",\n           size = 1.5,\n           color=\"random-light\", \n           fontWeight = \"normal\",\n           backgroundColor=\"black\"\n           )\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nПРАКТИЧЕСКОЕ ЗАДАНИЕ 5: АЛИСА В СТРАНЕ ЧУДЕС\n\n\n\n\n# постройте облако слов для \"Алисы в стране чудес\"\n\nlibrary(languageR)\nlibrary(dplyr)\nlibrary(tidytext)\n\n# вектор с \"Алисой\"\nalice &lt;- tolower(alice)\n\n# частотности для слов\nfreq &lt;- as_tibble(table(alice)) %&gt;% \n  rename(word = alice)\n\n# удалить стоп-слова\nfreq_tidy &lt;- freq %&gt;% \n  anti_join(stop_words) \n# возможно, вы захотите произвести и другие преобразования\n\n# облако можно строить в любой библиотеке\n\n\n\n\n\nWickham, Hadley, и Garrett Grolemund. 2016. R for Data Science. O’Reilly. https://r4ds.had.co.nz/index.html.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функциональное программирование</span>"
    ]
  },
  {
    "objectID": "iterate.html#footnotes",
    "href": "iterate.html#footnotes",
    "title": "4  Функциональное программирование",
    "section": "",
    "text": "https://r4ds.had.co.nz/iteration.html↩︎\nhttps://dplyr.tidyverse.org/reference/mutate_all.html↩︎\nhttps://dplyr.tidyverse.org/articles/colwise.html↩︎\nhttps://purrr.tidyverse.org/↩︎\nhttps://adv-r.hadley.nz/functionals.html↩︎\nhttps://adv-r.hadley.nz/functionals.html↩︎\nПример отсюда, с некоторыми упрощениями: https://smltar.com/embeddings.html#understand-word-embeddings-by-finding-them-yourself. Подробный разбор в видео↩︎",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Функциональное программирование</span>"
    ]
  },
  {
    "objectID": "import.html",
    "href": "import.html",
    "title": "5  Импорт и экспорт данных",
    "section": "",
    "text": "5.1 Работа с табличными данными\nЛюбой анализ данных начинается с импорта данных. Прежде чем что-то делать, проверьте свою рабочую директорию при помощи getwd(). Для смены можно использовать как абсолютный, так и относительный путь:\nsetwd(\"/Users/olga/R_Workflow/Text_Analysis_2024\")\n\n# искать в текущей директории\nsetwd(\"./Text_Analysis_2023\")\n\n# перейти на уровень вверх\nsetwd(\"../\")\nОсновная функция для скачивания файлов из Сети – download.file(), которой необходимо задать в качестве аргументов url, название сохраняемого файла, иногда также метод.\nПопробуем скачать датасет из Репозитория открытых данных по русской литературе и фольклору под названием “Байрон в русских переводах 1810–1860-х годов”.\nurl &lt;- \"https://dataverse.pushdom.ru/api/access/datafile/:persistentId?persistentId=doi:10.5072/openlit-2019.11-R002/VQRXXK\"\n\n# если url начинается с https, на Mac _может_ потребоваться указать method = \"curl\"\ndownload.file(url, destfile = \"../files/Byron.tab\")\nПосле этого в папке files появится новый файл. Получить список скачанных файлов можно при помощи list.files().\nlist.files(\"../files\", pattern = \"\\\\.tab\")\n\n[1] \"Byron.tab\"",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "import.html#чтение-табличных-данных",
    "href": "import.html#чтение-табличных-данных",
    "title": "5  Импорт и экспорт данных",
    "section": "5.2 Чтение табличных данных",
    "text": "5.2 Чтение табличных данных\nОсновные функции для чтения табличных данных в базовом R - это read.table() и read.csv().\n\n5.2.1 csv и tsv\nФайл, который мы скачали, имеет расширение .tab. Такие файлы по структуре аналогичны файлам .tsv (tab separated values). Чтобы его прочитать, используем read.table(), указав тип разделителя:\n\nByron &lt;- read.table(\"../files/Byron.tab\", sep = \"\\t\", header = TRUE)\n\nhead(Byron[,5])\n\n[1] \"б.п.\"                     \"б.п., с пометой: Варшава\"\n[3] \"К. П. Б.\"                 \"И. Козлов\"               \n[5] \"К.\"                       \"NN\"                      \n\n\nФункция read.csv() отличается лишь тем, что автоматически выставляет значения аргументов sep = \",\", header = TRUE.\nВ диалекте tidyverse для импорта подобных файлов используется функция read_csv из пакета readr1.\nВернемся к нашему датасету про буккроссинг, файлы которого имеют расширение csv. К сожалению, это не всегда гарантия того, что перед вами действительно csv:\n\nlibrary(readr)\nusers &lt;- read_csv(\"../files/BX/BX-Users.csv\", show_col_types = FALSE)\nhead(users)\n\n\n  \n\n\n\nЧтобы исправить дело, воспользуемся другой функцией из того же пакета:\n\nusers &lt;- read_delim(\"../files/BX/BX-Users.csv\", delim = \";\", show_col_types = FALSE)\nusers\n\n\n  \n\n\n\nОчевидно, это не решает всех проблем, но как справиться с оставшимися, мы рассказывали в уроке об опрятных данных.\n\n\n5.2.2 xls и xlsx\nНе самый любимый аналитиками, но очень распространенный тип файлов. Чтобы с ним работать, нужно установить пакет readxl из семейства tidyverse2. Это не единственный пакет для работы с Excel, но, пожалуй, самый удобный. Файл с самыми популярными на Amazon книгами можно взять здесь.\n\nlibrary(readxl)\namazon &lt;- read_excel(\"../files/AmazonBooks.xlsx\")\nhead(amazon)\n\n\n  \n\n\n\nМожно указать отдельные листы, которые необходимо прочитать.3",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "import.html#чтение-текстовых-данных",
    "href": "import.html#чтение-текстовых-данных",
    "title": "5  Импорт и экспорт данных",
    "section": "5.3 Чтение текстовых данных",
    "text": "5.3 Чтение текстовых данных\n\n5.3.1 txt\nДля чтения текстовых файлов в базовом R есть функция readlines(). Аргумент n указывает, сколько строк прочитать; при n = 1 функция дойдет до первого переноса строки или параграфа.\n\nreadLines(con = \"../files/karamzin_liza.txt\", n = 1) \n\n[1] \"    Может быть, никто из живущих в Москве не знает так хорошо окрестностей города сего, как я, потому что никто чаще моего не бывает в поле, никто более моего не бродит пешком, без плана, без цели -- куда глаза глядят -- по лугам и рощам, по холмам и равнинам. Всякое лето нахожу новые приятные места или в старых новые красоты. Но всего приятнее для меня то место, на котором возвышаются мрачные, готические башни Си...нова монастыря. Стоя на сей горе, видишь на правой стороне почти всю Москву, сию ужасную громаду домов и церквей, которая представляется глазам в образе величественного амфитеатра: великолепная картина, особливо когда светит на нее солнце, когда вечерние лучи его пылают на бесчисленных златых куполах, на бесчисленных крестах, к небу возносящихся! Внизу расстилаются тучные, густо-зеленые цветущие луга, а за ними, по желтым пескам, течет светлая река, волнуемая легкими веслами рыбачьих лодок или шумящая под рулем грузных стругов, которые плывут от плодоноснейших стран Российской империи и наделяют алчную Москву хлебом. \"\n\n\n\n\n5.3.2 doc\nЕсли есть возможность конвертировать документ Word в простой текстовый формат, то лучше так и сделать. Если нет, то устанавливаем пакет officer.\n\nlibrary(officer)\nfiles &lt;- list.files(path = \"../files\", pattern = \"docx\") \n\n# read file\ndoc &lt;- read_docx(paste0(\"../files/\", files[1]))\ncontent &lt;- docx_summary(doc) \nhead(content) # весь текст доступен в столбце text\n\n\n  \n\n\n\nТаким образом, однако, мы теряем все сноски. Следующий код позволяет их достать:\n\nlibrary(xml2)\nxml_text(xml_find_all(doc$footnotes$get(), \"*\"))\n\nТут уже применяются функции для работы с xml. Поэтому лишний раз подумайте, не проще ли конвертировать документ Word в .txt.\n\n\n5.3.3 pdf\nС pdf тоже без нужды лучше не иметь дела. Но если все-таки пришлось читать pdf, для этого есть пакет pdftools4.\n\nlibrary(pdftools)\n\n# длинющий вектор, который придется очищать от \\n (новая строка)\nliza &lt;- pdf_text(pdf = \"../files/karamzin_liza.pdf\")\n\n# метаданные в виде списка\nmeta &lt;- pdf_info(pdf = \"../files/karamzin_liza.pdf\")\nmeta$created\n\n[1] \"2023-07-16 19:36:09 MSK\"\n\n\nРазработчики утверждают, что пакет справится и с распознаванием текста, но для этого должен быть установлен пакет tesseract.\n\ninstall.packages(\"tesseract\")\n\nВозможно, сначала вам придется установить нужные языки. Код ниже вы можете попробовать выполнить самостоятельно, указав актуальный путь до файла.\n\nlibrary(tesseract)\ntesseract_download(\"deu\")\ntext &lt;- pdf_ocr_text(\"../files/German.pdf\", language = \"deu\")\ncat(text)\n\n\n\n5.3.4 png\nТот же фокус сработает и с изображениями. Но точность распознавания сильно зависит от качества картинки.\n\n# tesseract_download(\"lat\")\nlat &lt;- tesseract::tesseract(\"lat\")\ntext &lt;- tesseract::ocr(\"./images/latin.png\", engine = lat)\ncat(text)",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "import.html#архивы",
    "href": "import.html#архивы",
    "title": "5  Импорт и экспорт данных",
    "section": "5.4 Архивы",
    "text": "5.4 Архивы\n\n5.4.1 zip\nДля работы с архивами есть функция unzip(). Полезно помнить, что большой архив не обязательно распечатывать полностью. Если выставить аргумент list = TRUE, то функция вернет список всех файлов в архиве, из которых можно прочитать в память лишь избранные:\n\narchive &lt;- unzip(\"../files/BX.zip\", files = NULL, list = TRUE) \narchive\n\n\n  \n\n\n\nКод ниже позволяет извлечь из архива только нужный файл:\n\nunzip(\"files/archive.zip\", files = \"BX_Books.csv\")\n\nПосле этого файл можно прочитать в R, как указано выше.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "import.html#структурированные-данные",
    "href": "import.html#структурированные-данные",
    "title": "5  Импорт и экспорт данных",
    "section": "5.5 Структурированные данные",
    "text": "5.5 Структурированные данные\n\n5.5.1 json\nФормат JSON (JavaScript Object Notation) предназначен для представления структурированных данных. JSON имеет шесть основных типов данных5. Четыре из них - скаляры6:\n\nСамый простой тип - null (нуль), который играет ту же роль, что и NA в R. Он представляет собой отсутствие данных.\nСтрока (string) похожа на строку в R, но в ней всегда должны использоваться двойные кавычки.\nЧисло аналогично числам в R; поддерживается целочисленная (например, 123), десятичная (например, 123.45) или научная (например, 1,23e3) нотация. JSON не поддерживает Inf, -Inf или NaN.\nЛогическое значение аналогично TRUE и FALSE в R, но использует строчные буквы true и false.\n\nСтроки, числа и булевы значения в JSON очень похожи на символьные, числовые и логические векторы в R. Основное отличие заключается в том, что скаляры JSON могут представлять только одно значение. Для представления нескольких значений необходимо использовать один из двух оставшихся типов: массивы и объекты.\nИ массивы, и объекты похожи на списки в R, разница заключается в том, именованы они или нет. Массив подобен безымянному списку и записывается через []. Например, [1, 2, 3] - это массив, содержащий 3 числа, а [null, 1, \"string\", false] - массив, содержащий ноль, число, строку и булево значение.\nОбъект подобен именованному списку и записывается через {}. Имена (ключи в терминологии JSON) являются строками, поэтому должны быть заключены в кавычки. Например, {“x”: 1, “y”: 2} - это объект, который сопоставляет x с 1, а y – с 2.\nЗагрузим небольшой файл TBBT.json, хранящий данные о сериале “Теория большого взрыва” (источник). Скачать лучше из репозитория курса ссылка.\n\nlibrary(jsonlite)\n\npath &lt;- \"../files/TBBT.json\"\ntbbt &lt;- fromJSON(txt =  path,\n                 simplifyVector = T)\n\nФункция fromJSON() вернет нам список, который мы выборочно преобразуем в тиббл:\n\nlibrary(tidyverse)\n\ncast_tbl &lt;- tbbt$casting %&gt;% \n  transpose() %&gt;% \n  map(as.character) %&gt;% \n  as_tibble()\n\ncast_tbl\n\n\n  \n\n\n\nПроделаем то же самое для списка эпизодов, но немного другим способом.\n\nepisodes_tbl &lt;- tibble(\n  episode_id = map_chr(tbbt$episode_list, pluck, \"episode_id\"),\n  title = map_chr(tbbt$episode_list, pluck, \"title\"))\n\nepisodes_tbl\n\n\n  \n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nСамостоятельно создайте тиббл, в котором будет храниться количество серий для каждого сезона.\n\n\n\n\n\n5.5.2 xml\nXML (от англ. eXtensible Markup Language) — расширяемый язык разметки. Слово “расширяемый” означает, что список тегов не зафиксирован раз и навсегда: пользователи могут вводить свои собственные теги и создавать так называемые настраиваемые языки разметки (Холзнер 2004, 29). Один из таких настраиваемых языков – это TEI (Text Encoding Initiative), о котором будет сказано дальше.\nНазначение языков разметки заключается в описании структурированных документов. Структура документа представляется в виде набора вложенных в друг друга элементов (дерева XML). У элементов есть открывающие и закрывающие теги.\nВсе составляющие части документа обобщаются в пролог и корневой элемент. Корневой элемент — обязательная часть документа, в которую вложены все остальные элементы. Пролог может включать объявления, инструкции обработки, комментарии.\nВ правильно сформированном XML открывающий и закрывающий тег вложенного элемента всегда находятся внутри одного родительского элемента.\nСоздадим простой XML из строки. Сначала идет инструкция по обработке XML (со знаком вопроса), за ней следует объявление типа документа (с восклицательным знаком) и открывающий тег корневого элемента. В этот корневой элемент вложены все остальные элементы.\n\nstring_xml &lt;- '&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;!DOCTYPE recipe&gt;\n&lt;recipe name=\"хлеб\" preptime=\"5min\" cooktime=\"180min\"&gt;\n   &lt;title&gt;\n      Простой хлеб\n   &lt;/title&gt;\n   &lt;composition&gt;\n      &lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n      &lt;ingredient amount=\"0.25\" unit=\"грамм\"&gt;Дрожжи&lt;/ingredient&gt;\n      &lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n   &lt;/composition&gt;\n   &lt;instructions&gt;\n     &lt;step&gt;\n        Смешать все ингредиенты и тщательно замесить. \n     &lt;/step&gt;\n     &lt;step&gt;\n        Закрыть тканью и оставить на один час в тёплом помещении. \n     &lt;/step&gt;\n     &lt;step&gt;\n        Замесить ещё раз, положить на противень и поставить в духовку.\n     &lt;/step&gt;\n   &lt;/instructions&gt;\n&lt;/recipe&gt;'\n\nДля работы с xml понадобится установить одноименную библиотеку. Функция xmlTreeParse() создаст R-структуру, представляющую дерево XML.\n\nlibrary(XML)\ndoc &lt;- xmlTreeParse(string_xml)\nclass(doc)\n\n[1] \"XMLDocument\"         \"XMLAbstractDocument\"\n\n\nФункция xmlRoot позволяет извлечь корневой элемент вместе со всеми детьми.\n\nrootnode &lt;- xmlRoot(doc)\nrootnode\n\n&lt;recipe name=\"хлеб\" preptime=\"5min\" cooktime=\"180min\"&gt;\n &lt;title&gt;Простой хлеб&lt;/title&gt;\n &lt;composition&gt;\n  &lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n  &lt;ingredient amount=\"0.25\" unit=\"грамм\"&gt;Дрожжи&lt;/ingredient&gt;\n  &lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n &lt;/composition&gt;\n &lt;instructions&gt;\n  &lt;step&gt;Смешать все ингредиенты и тщательно замесить.&lt;/step&gt;\n  &lt;step&gt;Закрыть тканью и оставить на один час в тёплом помещении.&lt;/step&gt;\n  &lt;step&gt;Замесить ещё раз, положить на противень и поставить в духовку.&lt;/step&gt;\n &lt;/instructions&gt;\n&lt;/recipe&gt;\n\n\nЕсли документ большой, бывает удобнее не распечатывать все дерево, а вывести имена дочерних элементов.\n\nnames(xmlChildren(rootnode))\n\n[1] \"title\"        \"composition\"  \"instructions\"\n\n\nРазмер узла – это число вложенных в него “детей”. Его можно узнать, применив к узлу функцию xmlSize() – или подсчитав число “детей”.\n\nxmlSize(rootnode) == length(xmlChildren(rootnode))\n\n[1] TRUE\n\n\nРаботать с xml можно как с обычным списком, то есть индексировать узлы по имени или по номеру элемента при помощи квадратных скобок. Так мы достаем узел по имени:\n\nrootnode[[\"composition\"]]\n\n&lt;composition&gt;\n &lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n &lt;ingredient amount=\"0.25\" unit=\"грамм\"&gt;Дрожжи&lt;/ingredient&gt;\n &lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n&lt;/composition&gt;\n\n\nА так – по индексу:\n\nrootnode[[2]]\n\n&lt;composition&gt;\n &lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n &lt;ingredient amount=\"0.25\" unit=\"грамм\"&gt;Дрожжи&lt;/ingredient&gt;\n &lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n&lt;/composition&gt;\n\n\nКак и с обычными списками, мы можем использовать последовательности квадратных скобок:\n\ningr_node &lt;- rootnode[[2]][[\"ingredient\"]]\ningr_node\n\n&lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n\n\nНо обычно нам нужен не элемент как таковой, а его содержание (значение). Чтобы добраться до него, используем функцию xmlValue():\n\nxmlValue(ingr_node)\n\n[1] \"Мука\"\n\n\nМожно уточнить атрибуты узла при помощи xmlAttrs():\n\nxmlAttrs(ingr_node)\n\n  amount     unit \n     \"3\" \"стакан\" \n\n\nЧтобы извлечь значение атрибута, используем функцию xmlGetAttr(). Первым аргументом функции передаем xml-узел, вторым – имя атрибута.\n\nxmlGetAttr(ingr_node, \"unit\")\n\n[1] \"стакан\"\n\n\nКак насчет того, чтобы применить функцию к набору узлов – например, ко всем инредиентам? Вспоминаем функции для работы со списками – sapply() из базового R или map() из пакета purrr:\n\ningr_nodes &lt;- xmlChildren(rootnode[[2]])\n\nsapply(ingr_nodes, xmlValue)\n\n   ingredient    ingredient    ingredient \n       \"Мука\"      \"Дрожжи\" \"Тёплая вода\" \n\n\n\nsapply(ingr_nodes, xmlGetAttr, \"unit\")\n\ningredient ingredient ingredient \n  \"стакан\"    \"грамм\"   \"стакан\" \n\n\nДобраться до узлов определенного уровня можно также при помощи синтаксиса XPath. XPath – это язык запросов к элементам XML-документа. С его помощью можно описать “путь” до нужного узла: абсолютный (начиная с корневого элемента) или относительный. В пакете XML синтаксис XPath поддерживает функция getNodeSet().\n\n# абсолютный путь\ningr_nodes &lt;- getNodeSet(rootnode, \"/recipe//composition//ingredient\")\n\ningr_nodes\n\n[[1]]\n&lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n\n[[2]]\n&lt;ingredient amount=\"0.25\" unit=\"грамм\"&gt;Дрожжи&lt;/ingredient&gt;\n\n[[3]]\n&lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n\n\n\n# относительный путь\ningr_nodes &lt;- getNodeSet(rootnode, \"//composition//ingredient\")\n\ningr_nodes\n\n[[1]]\n&lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n\n[[2]]\n&lt;ingredient amount=\"0.25\" unit=\"грамм\"&gt;Дрожжи&lt;/ingredient&gt;\n\n[[3]]\n&lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n\n\n\n\n\n\n\n\n\nНа заметку\n\n\n\nВ большинстве случаев функция getNodeSet() требует задать пространство имен (namespace), но в нашем случае оно не определено, поэтому пока передаем только дерево и путь до узла. С пространством имен встретимся чуть позже!\n\n\n\nСинтаксис XPath позволяет отбирать узлы с определенными атрибутами. Допустим, нам нужны только те узлы, где значение атрибута unit = “стакан”:\n\ngetNodeSet(rootnode, \"//composition//ingredient[@unit='стакан']\")\n\n[[1]]\n&lt;ingredient amount=\"3\" unit=\"стакан\"&gt;Мука&lt;/ingredient&gt;\n\n[[2]]\n&lt;ingredient amount=\"1.5\" unit=\"стакан\"&gt;Тёплая вода&lt;/ingredient&gt;\n\n\nПри работе с xml в большинстве случаев наша задача – извлечь значения определеннных узлов или их атрибутов и сохранить их в прямоугольном формате.\nВ нашем простом примере это можно сделать несколькими способами. Первый: просто связать воедино несколько векторов.\n\ntitle &lt;- xmlValue(rootnode[[\"title\"]])\ningredients &lt;- map_chr(xmlChildren(rootnode[[\"composition\"]]), xmlValue)\nunit &lt;- map_chr(xmlChildren(rootnode[[\"composition\"]]), xmlGetAttr, \"unit\")\namount &lt;- map_chr(xmlChildren(rootnode[[\"composition\"]]), xmlGetAttr, \"amount\")\n\n\ntibble(title, ingredients, unit, amount)\n\n\n  \n\n\n\nВ некоторых случаях бывает удобно также воспользоваться функциями из пакета xml2 в сочетании с функциями семейства unnest_ из tidyr.\n\nlibrary(xml2)\n\ndoc &lt;- as_list(read_xml(string_xml))\n\n# попробуем достать атрибуты\ndoc %&gt;% \n  as_tibble() %&gt;% \n  unnest_longer(recipe) %&gt;% \n  filter(recipe_id == \"ingredient\") %&gt;% \n  mutate(unit = map_chr(recipe, attr, \"unit\")) %&gt;% \n  mutate(amount = map_chr(recipe, attr, \"amount\")) %&gt;% \n  select(-recipe_id) %&gt;% \n  unnest_longer(recipe)\n\n\n  \n\n\n\n\n\n5.5.3 tei\nБольшая часть размеченных литературных корпусов хранится именно в формате XML. Это очень удобно, и вот почему: документы в формате XML, как и документы в формате HTML, содержат данные, заключенные в теги, но если в формате HTML теги определяют оформление данных, то в формате XML теги нередко определяют структуру и смысл данных. С их помощью мы можем достать из документа именно то, что нам интересно: определенную главу, речи конкретных персонажей, слова на иностранных языках и т.п.\nДобавлять и удалять разметку может любой пользователь в редакторе XML кода или даже в простом текстовом редакторе. При этом в качестве универсального языка разметки в гуманитарных дисциплинах используется язык TEI (Скоринкин 2016). Корневой элемент в документах TEI называется TEI, внутри него располагается элемент teiHeader с метаинформацией о документе и элемент text. Последний содержит текст документа с элементами, определяющими его структурное членение.\n&lt;TEI&gt;\n  &lt;teiHeader&gt;&lt;/teiHeader&gt;\n  &lt;text&gt;&lt;/text&gt;\n&lt;/TEI&gt;\nПример оформления документа можно посмотреть по ссылке.\nУ teiHeader есть четыре главных дочерних элемента:\n\nfileDesc (описание документа c библиографической информацией)\nencodingDesc (описание способа кодирование первоисточника)\nprofileDesc (“досье” на текст, например отправитель и получатель для писем, жанр, используемые языки, обстоятельства создания, место написания и т.п.)\nrevisionDesc (история изменений документа)\n\nВ самом тексте язык TEI дает возможность представлять разные варианты (авторские, редакторские, корректорские и др.) Основным средством параллельного представления является элемент choice. Например, в тексте Лукреция вы можете увидеть такое:\nsic calor atque &lt;choice&gt;&lt;reg&gt;aer&lt;/reg&gt;&lt;orig&gt;aër&lt;/orig&gt;&lt;/choice&gt; et venti caeca potestas\nЗдесь reg указывает на нормализованное написание, а orig – на оригинальное.\nВ качестве примера загрузим датасет “Пушкинского дома”, подготовленный Д.А. Скоринкиным: “Персонажи «Войны и мира» Л. Н. Толстого: вхождения в тексте, прямая речь и семантические роли”.\n\nfilename = \"../files/War_and_Peace.xml\"\ndoc &lt;- xmlTreeParse(filename, useInternalNodes = T)\nrootnode &lt;- xmlRoot(doc)\n\nТеперь можно внимательнее взглянуть на структуру xml. Корневой элемент расходится на две ветви. Полностью они нам пока не нужны, узнаем только имена:\n\nnames(xmlChildren(rootnode)) \n\n[1] \"teiHeader\" \"text\"     \n\n\nОчевидно, что что-то для нас интересное будет спрятано в ветке text, глядим на нее:\n\nnames(xmlChildren(rootnode[[\"text\"]])) \n\n[1] \"div\" \"div\" \"div\" \"div\" \"div\"\n\n\nИтак, текст делится на какие-то пять частей. Функция xmlGetAttr() позволяет узнать значение атрибута type: как выясняется, это четыре тома и эпилог.\n\n# это список\ndivs &lt;-  rootnode[[\"text\"]][\"div\"]\n\nsapply(divs, xmlGetAttr, \"type\")\n\n       div        div        div        div        div \n  \"volume\"   \"volume\"   \"volume\"   \"volume\" \"epilogue\" \n\n\nКак мы уже знаем, добраться до определенного узла можно не только путем индексирования, но и – гораздо удобнее – при помощи синтаксиса XPath. Для этого просто указываем путь до узла. Попробуем спуститься на два уровня ниже: там тоже будет тег div, но с другим атрибутом. Как легко убедиться, теперь это главы, всего их 358.\n\ndivs &lt;- getNodeSet(doc, \"/tei:TEI//tei:text//tei:div//tei:div//tei:div\",\n                     namespaces = c(tei = \"http://www.tei-c.org/ns/1.0\")) \n\nlength(divs)\n\n[1] 358\n\nunique(sapply(divs, xmlGetAttr, \"type\"))\n\n[1] \"chapter\"\n\n\nОбратите внимание, что в данном случае надо прямо прописать пространство имен (namespaces). Это можно посмотреть в самом xml, а можно воспользоваться специальной функцией:\n\nxmlNamespace(rootnode)\n\n[1] \"http://www.tei-c.org/ns/1.0\"\nattr(,\"class\")\n[1] \"XMLNamespace\"\n\n\nЗабрать конкретную главу можно путем индексации, но лучше – по значению соответствующего атрибута.\n\nidx &lt;- which(map(divs, xmlGetAttr, \"xml:id\") == \"chapter1part1Volume1\")\nch1 &lt;- divs[[idx]]\n\nЧтобы извлечь текст, понадобится функция xmlValue.\n\nchapter_1 &lt;- xmlValue(ch1)\n\nРаспечатывать весь текст первой главы не будем (это очень длинный вектор); разобъем текст на параграфы и выведем первый и последний:\n\nlibrary(stringr)\nchapter_lines &lt;- str_split(chapter_1, pattern = \"\\n\")\n\nchapter_lines[[1]][[5]]\n\n[1] \"        — Eh bien, mon prince. Gênes et Lueques ne sont plus que des apanages, des поместья, de la famille Buonaparte. Non, je vous préviens que si vous ne me dites pas que nous avons la guerre, si vous vous permettez encore de pallier toutes les infamies, toutes les atrocités de cet Antichrist (ma parole, j'y crois) — je ne vous connais plus, vous n'êtes plus mon ami, vous n'êtes plus мой верный раб, comme vous dites. Ну, здравствуйте, здравствуйте. Je vois que je vous fais peur, садитесь и рассказывайте.\"\n\nchapter_lines[[1]][[838]]\n\n[1] \"       Ce sera dans votre famille que je ferai mon apprentissage de vieille fille.\"\n\n\nПервая и последняя реплика по-французски: все правильно!\n\n\n\n\n\n\n\nЗадание\n\n\n\nСкачайте по ссылке “Горе от ума” Грибоедова и преобразуйте xml в прямоугольный формат таким образом, чтобы для каждой реплики был указан акт, сцена и действующее лицо.\n\n\n\nПодбробнее о структуре XML документов и способах работы с ними вы можете прочитать в книгах: (Nolan и Lang 2014) и (Холзнер 2004).",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "import.html#gutenbergr",
    "href": "import.html#gutenbergr",
    "title": "5  Импорт и экспорт данных",
    "section": "5.6 GutenbergR",
    "text": "5.6 GutenbergR\nПакет GutenbergR поможет достать тексты из библиотеки Gutenberg, но будьте осторожны: распознаны они не всегда хорошо и порой содержат много разного шума, например примечания редактора, номера страниц и т.п. В билингвах источник и перевод могут идти вперемешку. И если в XML подобные элементы будут окружены соответствующими тегами, которые позволят их легко отбросить при анализе, то Gutenberg дает вам сырой текст. Часто его надо хорошенько чистить при помощи регулярных выражений или даже вручную.\nРаботать с метаданными GutenbergR вы уже научились, теперь можете пользоваться пакетом и для скачивания текстов. Сначала узнаем id нужных текстов [^https://cran.r-project.org/web/packages/gutenbergr/vignettes/intro.html]\n\nlibrary(gutenbergr)\n\ncaesar &lt;- gutenberg_works(author == \"Caesar, Julius\", languages = \"la\") \n\ncaesar \n\n\n  \n\n\n\nЧтобы извлечь отдельный текст (тексты):\n\nde_bello_gallico &lt;- gutenberg_download(218, meta_fields = \"title\", mirror = \"ftp://mirrors.xmission.com/gutenberg/\")\nde_bello_gallico\n\n\n  \n\n\n\n\n\n\n\n\n\nНа заметку\n\n\n\nСуществует несколько зеркал библиотеки Gutenberg, и, если при выполнении функции gutenberg_download() возникает ошибка “could not download a book at http://aleph.gutenberg.org/”, то следует использовать аргумент mirror. Список зеркал доступен по ссылке: https://www.gutenberg.org/MIRRORS.ALL\n\n\n\n\n\n\nNolan, D., и D. T. Lang. 2014. XML and Web Technologies for Data Science with R. Springer.\n\n\nСкоринкин, Даниил. 2016. «Электронное представление текста с помощью стандарта разметки TEI», 90–108.\n\n\nХолзнер, Стивен. 2004. Энциклопедия XML. Питер.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "import.html#footnotes",
    "href": "import.html#footnotes",
    "title": "5  Импорт и экспорт данных",
    "section": "",
    "text": "https://r4ds.had.co.nz/data-import.html↩︎\nhttps://readxl.tidyverse.org/↩︎\nhttps://r4ds.hadley.nz/spreadsheets↩︎\nhttps://rpubs.com/kbodwin/pdftools↩︎\nhttps://r4ds.hadley.nz/rectangling#json↩︎\nМассив строк, который имеет только один элемент, также называется строковым скаляром.↩︎",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Импорт и экспорт данных</span>"
    ]
  },
  {
    "objectID": "share.html",
    "href": "share.html",
    "title": "6  Воспроизводимые исследования",
    "section": "",
    "text": "6.1 О воспроизводимости\nПолученный в результате количественных исследований результат должен быть проверяем и воспроизводим. Даже на заре стилометрии, когда все вычисления проводились вручную, ученые стремились максимально подробно задокументировать свои вычисления: какие слова они считали, в каких текстах и т.п. Об одном исключении из этого правила можно прочитать вот здесь.\nСегодня к документации исследования предъявляются гораздо более строгие требования: в большинстве случаев недостаточно просто рассказать, что вы проделали. Теоретически читатель должен иметь возможность проделать тот же путь, что и автор: вопроизвести его результаты, но в обратном направлении.\nИллюстрация ниже заимствована из книги Роджера Пенга, специалиста по биостатистике1. За тем исключением, что вместо квадратика “Nature” в гуманитарном исследовании будет квадратик “Culture”, общие принципы те же: все, что вы делаете – от сбора данных до их оформления в виде графиков – должно быть задокументировано и воспроизводимо.\nДля этого должны выполняться три основных требования:\nИменно поэтому всегда, когда возможно, преимущество должно отдаваться свободно распространяемому ПО. В этом смысле R имеет преимущество перед такими программами, как SPSS, SAS, Matlab, STATA и др.\nВсе, что вы делаете на “не имеющем аналогов в мире” закрытом ПО может быть увлекательно лично для вас, но не отвечает научным критериям проверяемости. Поэтому многие разработчики, создающие приложения для анализа текста, тоже выкладывают их на GitHub. (Пример).\nПравило второ: код имеет преимущество перед GUI (Graphical User Interface): вспомнить, какие кнопки в каком порядке были нажаты, даже самому автору бывает непросто. От скачивания файла до экспорта графиков – все должно быть зафисировано, причем в виде, понятном не только для машины, но и для человека. Некоторые пакеты в R оснащены GUI (например, stylo), но пользоваться им лучше умеренно, пока вы только знакомитесь с инструментом.\nПравило третье: код и сырые данные для статьи принято публиковать на GitHub. Исследователи, работающие с разными изданиями Аристотеля, могут прийти к разным выводам. Вопроизвести ваше исследование на других данных может быть невозможно. Если вы работаете с материалом, защищенным копирайтом, на GitHub можно настроить доступ к репозиторию: он не будет виден всем, но, например, рецензенты смогут проверить ваши выводы2.\nАвторитетный International Journal of Digital Humanities прямо пишет в инструкциях для авторов:\nУже на этапе планирования исследования очень важно продумать, как вы будете его документировать. Это делается не после того, как вы все выяснили, а в процессе.\nПравило четвертое: код пишется не только для машин, но и для людей. Важно документировать не только то, что вы делали, но и почему. R дает для этого множество возможностей, главная из которых – это Markdown3.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Воспроизводимые исследования</span>"
    ]
  },
  {
    "objectID": "share.html#о-воспроизводимости",
    "href": "share.html#о-воспроизводимости",
    "title": "6  Воспроизводимые исследования",
    "section": "",
    "text": "На заметку\n\n\n\nВоспроизводимость (reproducibility) – это не то же, что повторяемость (replicability). Ученый, который повторяет исследование, проводит его заново на новых данных. Воспроизведение – гораздо более скромная задача, не требующая таких ресурсов, как повторение (Winter 2020, 47).\n\n\n\n\n\n\nдоступность данных и метаданных;\nдоступность компьютерного кода;\nдоступность программного обеспечения.\n\n\n\n\n\n\n\nPlease ensure you provide all relevant editable source files at every submission and revision. Failing to submit a complete set of editable source files will result in your article not being considered for review.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Воспроизводимые исследования</span>"
    ]
  },
  {
    "objectID": "share.html#markdown",
    "href": "share.html#markdown",
    "title": "6  Воспроизводимые исследования",
    "section": "6.2 Markdown",
    "text": "6.2 Markdown\nMarkdown – это облегчённый язык разметки. Он позволяет создавать документы разного формата – не только HTML (веб-страницы), но и PDF и Word. Markdown дает возможность создания полностью воспроизводимых документов, сочетающих код и поясняющий текст. Этот язык используется для создания сайтов, статей, книг, презентаций, отчетов, дашбордов и т.п. Этот курс написан с использованием Markdown.\nЧтобы начать работать с документами .rmd, нужен пакет rmarkdown; в RStudio он уже предустановлен. Создание нового документа .rmd происходит из меню4:\n\nПо умолчанию документ .rmd снабжен шапкой yaml. Она не обязательна. Здесь содержатся данные об авторе, времени создания, формате, сведения о файле с библиографией и т.п.\n---\ntitle: \"Demo\"\nauthor: \"My name\"\ndate: \"2024-08-11\"\noutput: html_document\n---\nТакже в документе .rmd скорее всего будет простой текст и блоки кода. Чтобы “сшить” html (pdf, doc), достаточно нажать кнопку knit. Либо можно запустить в консоли код: rmarkdown::render(\"Demo.Rmd\"). После этого в рабочей директории появится новый файл (html, pdf, или doc), которым можно поделиться с коллегами, грантодателями или друзьями.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Воспроизводимые исследования</span>"
    ]
  },
  {
    "objectID": "share.html#синтаксис-markdown",
    "href": "share.html#синтаксис-markdown",
    "title": "6  Воспроизводимые исследования",
    "section": "6.3 Синтаксис Markdown",
    "text": "6.3 Синтаксис Markdown\n\n6.3.1 Заголовки\nЗаголовки разного уровня задаются при помощи решетки5:\n# Заголовок первого уровня\n## Заголовок второго уровня\n### Заголовок третьего уровня\n#### Заголовок четвёртого уровня\nПример заголовка третьего уровня:\n\n\n6.3.2 Форматирование\n*курсив*  \n_курсив_\n\n**полужирный**  \n__полужирный__\n\n***полужирный курсив***  \n___полужирный курсив___\n\n~~зачеркнутый~~\n\n&lt;mark&gt;выделение&lt;/mark&gt;\nПример:\nкурсив\nполужирный\nуж и не знаю как выделить\nзачеркнутый\nвыделение\n\n\n6.3.3 Списки\nНумерованный список\n1. Пункт первый\n2. Пункт второй\n3. Пункт третий\nПример:\n\nПункт первый\nПункт второй\nПункт третий\n\nМаркированный список\n- Пункт первый\n- Пункт второй\n- Пункт третий\nПример:\n\nПункт первый\nПункт второй\nПункт третий\n\nТакже Markdown позволяет делать вложенные списки:\n1. Пункт первый\n    - Подпункт первый\n    - Подпункт второй\n2. Пункт второй\nПример:\n\nПункт первый\n\nПодпункт первый\nПодпункт второй\n\nПункт второй\n\nСамое удобное, что элементы списка не обязательно нумеровать:\n(@) Пункт первый.\n(@) Пункт не знаю какой.\n\nПункт первый.\nПункт не знаю какой.\n\n\n\n6.3.4 Ссылки\n[Текст ссылки](http://antibarbari.ru/)\nПример:\nТекст ссылки\n\n\n6.3.5 Изображения\n![Текст описания](http://antibarbari.ru/wp-content/uploads/2023/03/corderius-656x300.png)\nПример:\n\n\n\nМоя картинка\n\n\nДва нюанса:\n\nможно давать ссылки на локальные файлы (то есть такие файлы, которые хранятся на компьютере), но имейте в виду, что такой код не будет работать у другого пользователя;\nизображения можно вставлять, пользуясь непосредственно разметкой html.\n\n&lt;img src=\"images/my_image.jpg\" width=40%&gt;\n\n\n6.3.6 Блоки кода\nМожно вставлять непосредственно в текст; для этого код выделяют одинарным обратным апострофом (грависом). Но чаще код дают отдельным блоком. Эти блоки можно именовать; тогда в случае ошибки будет сразу понятно, где она случилась6.\n```{}\nsome code here\n```\nВ фигурных скобках надо указать язык, например {r}, только в этом случае код будет подсвечиваться и выполняться.\nТам же в фигурных скобках можно задать следующие параметры:\n\neval = FALSE код будет показан, но не будет выполняться;\ninclude = FALSE код будет выполнен, но ни код, ни результат не будут показаны;\necho = FALSE код будет выполнен, но не показан, результаты при этом видны;\nmessage = FALSE или warning = FALSE прячет сообщения или предупреждения;\nresults = 'hide' не распечатывает результат, а fig.show = 'hide' прячет графики;\nerror = TRUE “сшивание” продолжается, даже если этот блок вернул ошибку.\n\n\n\n6.3.7 Цитаты\n&gt; Omnia praeclara rara.\nПример:\n\nOmnia praeclara rara.\n\nЦитата с подписью может быть оформлена так:\n&gt; Omnia praeclara rara.\n&gt;\n&gt; --- Cicero\nПример:\n\nOmnia praeclara rara.\n— Cicero\n\n\n\n6.3.8 Разделители\nЧтобы создать горизонтальную линию, можно использовать ---, *** или ___.\nПример:\n\n\n\n6.3.9 Таблицы\nТаблицы можно задать вручную при помощи дефисов - и вертикальных линий |; идеальная точность при этом не нужна. Перед таблицей обязательно оставляйте пустую строку, иначе волшебство не сработает.\n\n| Фрукты   | Калории  |\n| -----  | ---- |\n| Яблоко   | 52  |\n| Апельсин | 47  |\nПример:\n\n\n\nФрукты\nКалории\n\n\n\n\nЯблоко\n52\n\n\nАпельсин\n47\n\n\n\nПо умолчанию Markdown распечатывает таблицы так, как они бы выглядели в консоли.\n\ndata(\"iris\")\nhead(iris)\n\n\n  \n\n\n\nДля дополнительного форматирования можно использовать функцию knitr::kable():\n\nknitr::kable(iris[1:6, ], caption = \"Таблица knitr\")\n\n\nТаблица knitr\n\n\nSepal.Length\nSepal.Width\nPetal.Length\nPetal.Width\nSpecies\n\n\n\n\n5.1\n3.5\n1.4\n0.2\nsetosa\n\n\n4.9\n3.0\n1.4\n0.2\nsetosa\n\n\n4.7\n3.2\n1.3\n0.2\nsetosa\n\n\n4.6\n3.1\n1.5\n0.2\nsetosa\n\n\n5.0\n3.6\n1.4\n0.2\nsetosa\n\n\n5.4\n3.9\n1.7\n0.4\nsetosa\n\n\n\n\n\nИнтерактивную таблицу можно создать так:\n\nDT::datatable(iris[1:6,])\n\n\n\n\n\n\n\n6.3.10 Чек-листы\n- [x] Таблицы\n- [ ] Графики\nПример:\n\nТаблицы\nГрафики\n\n\n\n6.3.11 Внутренние ссылки\nУдобны для навигации по документу. К названию любого раздела можно добавить {#id}.\n[Вернуться к чек-листам](#id)\nПример:\nВернуться к чек-листам\n\n\n6.3.12 Графики\nMarkdown позволяет встраивать любые графики.\n\nlibrary(ggplot2)\nggplot(aes(x = Sepal.Length, y = Petal.Length, col = Species), data = iris) +\n  geom_point(show.legend = F)\n\n\n\n\n\n\n\n\nДля интерактивных графиков понадобится пакет plotly:\n\nlibrary(plotly)\nplot_ly(data=iris, x = ~Sepal.Length, y = ~Petal.Length, color = ~Species)\n\n\n\n\n\nПодробное руководство по созданию интерактивных графиков можно найти на сайте https://plotly.com/r/.\n\n\n6.3.13 Математические формулы\nПишутся с использованием синтаксиса LaTeX, о котором можно прочитать подробнее здесь.\nФормулы заключаются в одинарный $, если пишутся в строку, и в двойной $$, если отдельным блоком.\n\\cos (2\\theta) = \\cos^2 \\theta - \\sin^2 \\theta\nВот так это выглядит в тексте: \\(\\cos (2\\theta) = \\cos^2 \\theta - \\sin^2 \\theta\\).\nА вот так – блоком:\n\\[\\cos (2\\theta) = \\cos^2 \\theta - \\sin^2 \\theta\\]\n\n\n6.3.14 Смайлы\nУдобнее вставлять через визуальный редактор (“шестеренка” &gt; Use Visual Editor), но можно и без него:\n\n# devtools::install_github(\"hadley/emo\")\nlibrary(emo)\nemo::ji(\"apple\")\n\n🍎 \n\n\nКод можно записать в строку, тогда смайл появится в тексте: 💀.7",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Воспроизводимые исследования</span>"
    ]
  },
  {
    "objectID": "share.html#библиография",
    "href": "share.html#библиография",
    "title": "6  Воспроизводимые исследования",
    "section": "6.4 Библиография",
    "text": "6.4 Библиография\nMarkdown позволяет добавлять библиографию в формате BibTeX. BibTeX — программное обеспечение для создания форматированных списков библиографии; обычно используется совместно с LaTeX’ом. Многие сайты, например GoogleScholar, позволяют экспортировать библиографические записи в формате BibTeX. При необходимости запись можно исправить вручную.\nКаждая запись имеет следующую форму.\n@book{winter2020,\n  author = {Bodo Winter},\n  title = \"{Statistics for Linguists: An Introduction Using R}\",\n  year = {2020},\n  publisher = {Routledge}\n}\nЗдесь book — тип записи («книга»), winter2020 — метка-идентификатор записи, дальше список полей со значениями.\nОдна запись описывает ровно одну публикацию статью, книгу, диссертацию, и т. д. Подробнее о типах записей можно посмотреть вот здесь.\nПодобные записи хранятся в текстовом файле с расширением .bib. Чтобы привязать библиографию, нужно указать имя файла в шапке yaml.\n---\nbibliography: bibliography.bib\n---\nДальше, чтобы добавить ссылку, достаточно ввести ключ публикации после @ (в квадратных скобках, чтобы публикация отражалась в круглых): [@wickham2016].\nПример:\n(Wickham и Grolemund 2016).\nМожно интегрировать BibTex с Zotero или другим менеджером библиографии. Для этого придется установить специальное расширение.\nЧтобы изменить стиль цитирования, необходимо добавить в шапку yaml название csl-файла (CSL - Citation Style Language), например:\n---\noutput: html_document\nbibliography: references.bib\ncsl: archiv-fur-geschichte-der-philosophie.csl\n---\nНайти необходимый csl-файл можно, например, в репозитории стилей Zotero.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Воспроизводимые исследования</span>"
    ]
  },
  {
    "objectID": "share.html#интерактивные-упражнения",
    "href": "share.html#интерактивные-упражнения",
    "title": "6  Воспроизводимые исследования",
    "section": "6.5 Интерактивные упражнения",
    "text": "6.5 Интерактивные упражнения\nДобавляются с использованием пакета checkdown. Подробнее позже.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Воспроизводимые исследования</span>"
    ]
  },
  {
    "objectID": "share.html#публикация-html",
    "href": "share.html#публикация-html",
    "title": "6  Воспроизводимые исследования",
    "section": "6.6 Публикация html",
    "text": "6.6 Публикация html\nДля публикации на RPubs понадобится установить пакеты packrat, rsconnect.\n\n\n\n\nWickham, Hadley, и Garrett Grolemund. 2016. R for Data Science. O’Reilly. https://r4ds.had.co.nz/index.html.\n\n\nWinter, Bodo. 2020. Statistics for Linguists: An Introduction Using R. Routledge.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Воспроизводимые исследования</span>"
    ]
  },
  {
    "objectID": "share.html#footnotes",
    "href": "share.html#footnotes",
    "title": "6  Воспроизводимые исследования",
    "section": "",
    "text": "https://rdpeng.github.io/Biostat776/lecture-reproducible-research-and-r-markdown.html↩︎\nВесьма поучительная статья: https://www.journals.uchicago.edu/doi/full/10.1086/702594 с весьма поучительной дискуссией вокруг нее: https://critinq.wordpress.com/2019/04/12/more-responses-to-the-computational-case-against-computational-literary-studies/↩︎\nhttps://rmarkdown.rstudio.com/↩︎\nhttps://docs.posit.co/how-to-guides/rsc/publish-rmd/↩︎\nhttps://www.markdownguide.org/basic-syntax/↩︎\nhttps://r4ds.had.co.nz/r-markdown.html#chunk-name↩︎\nhttps://github.com/hadley/emo↩︎",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Воспроизводимые исследования</span>"
    ]
  },
  {
    "objectID": "regex.html",
    "href": "regex.html",
    "title": "7  Регулярные выражения",
    "section": "",
    "text": "7.1 Regex в базовом R\nВ базовом R за работу со строками отвечают, среди прочего, такие функции, как grep() и grepl(). При этом grepl() возвращает TRUE, если шаблон найден в соответствующей символьной строке, а grep() возвращает вектор индексов символьных строк, содержащих паттерн.\nОбеим функциям необходим аргумент pattern и аргумент x, где pattern - регулярное выражение, по которому производится поиск, а аргумент x - вектор символов, по которым следует искать совпадения.\nФункция gsub() позволяет производить замену и требует также аргумента replacement.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Регулярные выражения</span>"
    ]
  },
  {
    "objectID": "regex.html#литералы-и-классы",
    "href": "regex.html#литералы-и-классы",
    "title": "7  Регулярные выражения",
    "section": "7.2 Литералы и классы",
    "text": "7.2 Литералы и классы\nБуквальные символы – это то, что вы ожидаете увидеть (или не увидеть – для управляющих и пробельных символов); можно сказать, что это символы, которые ничего не “имеют в виду”. Их можно объединять в классы при помощи квадратных скобок, например, так: [abc].\n\nvec &lt;- c(\"a\", \"d\", \"c\")\ngrepl(\"[abc]\", vec)\n\n[1]  TRUE FALSE  TRUE\n\ngrep(\"[abc]\", vec)\n\n[1] 1 3\n\n\nДля некоторых классов есть специальные обозначения.\n\n\n\n\n\n\n\n\nКласс\nЭквивалент\nЗначение\n\n\n\n\n[:upper:]\n[A-Z]\nСимволы верхнего регистра\n\n\n[:lower:]\n[a-z]\nСимволы нижнего регистра\n\n\n[:alpha:]\n[[:upper:][:lower:]]\nБуквы\n\n\n[:digit:]\n[0-9], т. е. \\d\nЦифры\n\n\n[:alnum:]\n[[:alpha:][:digit:]]\nБуквы и цифры\n\n\n[:word:]\n[[:alnum:]_], т. е. \\w\nСимволы, образующие «слово»\n\n\n[:punct:]\n[-!“#$%&’()*+,./:;&lt;=&gt;?@[\\]_`{|}~]\nЗнаки пунктуации\n\n\n[:blank:]\n[\\s\\t]\nПробел и табуляция\n\n\n[:space:]\n[[:blank:]\\v\\r\\n\\f], т. е. \\s\nПробельные символы\n\n\n[:cntrl:]\n\nУправляющие символы (перевод строки, табуляция и т.п.)\n\n\n[:graph:]\n\nПечатные символы\n\n\n[:print:]\n\nПечатные символы с пробелом\n\n\n\nЭти классы тоже можно задавать в качестве паттерна.\n\nvec &lt;- c(\"жираф\", \"верблюд1\", \"0зебра\")\ngsub( \"[[:digit:]]\",  \"\", vec)\n\n[1] \"жираф\"   \"верблюд\" \"зебра\"  \n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nВ пакете stringr есть небольшой датасет words. Найдите все слова с последовательностью символов wh. Сколько слов содержат два гласных после w?\n\n\n\nВ качестве классов можно рассматривать и следующие обозначения:\n\n\n\n\n\n\n\n\nПредставление\nЭквивалент\nЗначение\n\n\n\n\n\\d\n[0-9]\nЦифра\n\n\n\\D\n[^\\\\d]\nЛюбой символ, кроме цифры\n\n\n\\w\n[A-Za-zА-Яа-я0-9_]\nСимволы, образующие «слово» (буквы, цифры и символ подчёркивания)\n\n\n\\W\n[^\\\\w]\nСимволы, не образующие «слово»\n\n\n\\s\n[ \\t\\v\\r\\n\\f]\nПробельный символ\n\n\n\\S\n[^\\\\s]\nНепробельный символ\n\n\n\n\ngsub( \"\\\\d\",  \"\", vec) # вторая косая черта \"экранирует\" первую\n\n[1] \"жираф\"   \"верблюд\" \"зебра\"  \n\n\nВнутри квадратных скобор знак ^ означает отрицание:\n\ngsub( \"[^[:digit:]]\",  \"\", vec) \n\n[1] \"\"  \"1\" \"0\"\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nНайдите все слова в words, в которых за w следует согласный. Замените всю пунктуацию в строке “tomorrow?and-tomorrow_and!tomorrow” на пробелы.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Регулярные выражения</span>"
    ]
  },
  {
    "objectID": "regex.html#якоря",
    "href": "regex.html#якоря",
    "title": "7  Регулярные выражения",
    "section": "7.3 Якоря",
    "text": "7.3 Якоря\nЯкоря позволяют искать последовательности символов в начале или в конце строки. Знак ^ (вне квадратных скобок!) означает начало строки, а знак $ – конец. Мнемоническое правило: First you get the power (^) and then you get the money ($).\n\nvec &lt;- c(\"The spring is a lovely time\", \n         \"Fall is a time of peace\")\ngrepl(\"time$\", vec)\n\n[1]  TRUE FALSE\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nНайдите все слова в words, которые заканчиваются на x. Найдите все слова, которые начинаются на b или на g.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Регулярные выражения</span>"
    ]
  },
  {
    "objectID": "regex.html#метасимволы",
    "href": "regex.html#метасимволы",
    "title": "7  Регулярные выражения",
    "section": "7.4 Метасимволы",
    "text": "7.4 Метасимволы\nВсе метасимволы представлены в таблице ниже.\n\n\n\nОписание\nСимвол\n\n\n\n\nоткрывающая квадратная скобка\n[\n\n\nзакрывающая квадратная скобка\n]\n\n\nобратная косая черта\n\\\n\n\nкарет\n^\n\n\nзнак доллара\n$\n\n\nточка\n.\n\n\nвертикальная черта\n|\n\n\nзнак вопроса\n?\n\n\nастериск\n*\n\n\nплюс\n+\n\n\nоткрывающая фигурная скобка\n{\n\n\nзакрывающая фигурная скобка\n}\n\n\nоткрывающая круглая скобка\n(\n\n\nзакрывающая круглая скобка\n)\n\n\n\nКвадратные скобки используются для создания классов, карет и знак доллара – это якоря, но карет внутри квадратных скобок может также быть отрицанием. Точка – это любой знак.\n\nvec &lt;- c(\"жираф\", \"верблюд1\", \"0зебра\")\ngrep(\".б\", vec) \n\n[1] 2 3\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nНайдите все слова в words, в которых есть любые два символа между b и k.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Регулярные выражения</span>"
    ]
  },
  {
    "objectID": "regex.html#экранирование",
    "href": "regex.html#экранирование",
    "title": "7  Регулярные выражения",
    "section": "7.5 Экранирование",
    "text": "7.5 Экранирование\nЕсли необходимо найти буквальную точку, буквальный знак вопроса и т.п., то используется экранирование: перед знаком ставится косая черта. Но так как сама косая черта – это метасимвол, но нужно две косые черты, первая из которых экранирует вторую.\n\nvec &lt;- c(\"жираф?\", \"верблюд.\", \"зебра\")\ngrep(\"\\\\?\", vec) \n\n[1] 1\n\ngrepl(\"\\\\.\", vec)\n\n[1] FALSE  TRUE FALSE\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nУзнайте, все ли предложения в sentences (входит в stringr) кончаются на точку.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Регулярные выражения</span>"
    ]
  },
  {
    "objectID": "regex.html#квантификация",
    "href": "regex.html#квантификация",
    "title": "7  Регулярные выражения",
    "section": "7.6 Квантификация",
    "text": "7.6 Квантификация\nКвантификатор после символа, символьного класса или группы определяет, сколько раз предшествующее выражение может встречаться. Квантификатор может относиться более чем к одному символу в регулярном выражении, только если это символьный класс или группа.\n\n\n\nПредставление\nЧисло повторений\nЭквивалент\n\n\n\n\n?\nНоль или одно\n{0,1}\n\n\n*\nНоль или более\n{0,}\n\n\n+\nОдно или более\n{1,}\n\n\n\nПример:\n\nvec &lt;- c(\"color\", \"colour\", \"colouur\")\ngrepl(\"ou?r\", vec) # ноль или одно \n\n[1]  TRUE  TRUE FALSE\n\ngrepl(\"ou+r\", vec) # одно или больше\n\n[1] FALSE  TRUE  TRUE\n\ngrepl(\"ou*r\", vec) # ноль или больше\n\n[1] TRUE TRUE TRUE\n\n\nТочное число повторений (интервал) можно задать в фигурных скобках:\n\n\n\nПредставление\nЧисло повторений\n\n\n\n\n{n}\nРовно n раз\n\n\n{m,n}\nОт m до n включительно\n\n\n{m,}\nНе менее m\n\n\n{,n}\nНе более n\n\n\n\n\nvec &lt;- c(\"color\", \"colour\", \"colouur\", \"colouuuur\")\ngrepl(\"ou{1}r\", vec)\n\n[1] FALSE  TRUE FALSE FALSE\n\ngrepl(\"ou{1,2}r\", vec)\n\n[1] FALSE  TRUE  TRUE FALSE\n\ngrepl(\"ou{,2}r\", vec) # это включает и ноль!\n\n[1]  TRUE  TRUE  TRUE FALSE\n\n\nЧасто используется последовательность .* для обозначения любого количества любых символов между двумя частями регулярного выражения.\n\n\n\n\n\n\nЗадание\n\n\n\nУзнайте, в каких предложениях в sentences за пробелом следует ровно три согласных.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Регулярные выражения</span>"
    ]
  },
  {
    "objectID": "regex.html#жадная-и-ленивая-квантификация",
    "href": "regex.html#жадная-и-ленивая-квантификация",
    "title": "7  Регулярные выражения",
    "section": "7.7 Жадная и ленивая квантификация",
    "text": "7.7 Жадная и ленивая квантификация\nВ регулярных выражениях квантификаторам соответствует максимально длинная строка из возможных (квантификаторы являются жадными, англ. greedy). Это может оказаться значительной проблемой. Например, часто ожидают, что выражение &lt;.*&gt; найдёт в тексте теги HTML. Однако если в тексте есть более одного HTML-тега, то этому выражению соответствует целиком строка, содержащая множество тегов.\n\nvec &lt;- c(\"&lt;p&gt;&lt;b&gt;Википедия&lt;/b&gt; — свободная энциклопедия, в которой &lt;i&gt;каждый&lt;/i&gt; может изменить или дополнить любую статью.&lt;/p&gt;\")\ngsub(\"&lt;.*&gt;\", \"\", vec) # все исчезло!\n\n[1] \"\"\n\n\nЧтобы этого избежать, надо поставить после квантификатора знак вопроса. Это сделает его ленивым.\n\n\n\nregex\nзначение\n\n\n\n\n??\n0 или 1, лучше 0\n\n\n*?\n0 или больше, как можно меньше\n\n\n+?\n1 или больше, как можно меньше\n\n\n{n,m}?\nот n до m, как можно меньше\n\n\n\nПример:\n\ngsub(\"&lt;.*?&gt;\", \"\", vec) # все получилось!\n\n[1] \"Википедия — свободная энциклопедия, в которой каждый может изменить или дополнить любую статью.\"\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nДана строка “tomorrow (and) tomorrow (and) tomorrow”. Необходимо удалить первые скобки с их содержанием.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Регулярные выражения</span>"
    ]
  },
  {
    "objectID": "regex.html#regex-в-stringr-основы",
    "href": "regex.html#regex-в-stringr-основы",
    "title": "7  Регулярные выражения",
    "section": "7.8 Regex в stringr: основы",
    "text": "7.8 Regex в stringr: основы\nПакет stringr не является частью tidyverse, хотя и разделяет его принципы1. Его надо загружать отдельно:\n\nlibrary(stringr)\n\nЭто очень удобный инструмент для работы со строками. Вот так можно узнать длину строки или объединить ее с другими строками:\n\nvec &lt;- c(\"жираф\", \"верблюд\")\nstr_length(vec)\n\n[1] 5 7\n\nstr_c(\"красивый_\", vec)\n\n[1] \"красивый_жираф\"   \"красивый_верблюд\"\n\n\nЭлементы вектора можно объединить в одну строку:\n\nstr_c(vec, collapse = \", \") # теперь у них общие кавычки\n\n[1] \"жираф, верблюд\"\n\n\nС помощью str_sub() и str_sub_all() можно выбрать часть строки2.\n\nvec &lt;- c(\"жираф\", \"верблюд\")\nstr_sub(vec, 1, 3)\n\n[1] \"жир\" \"вер\"\n\nstr_sub(vec, 1, -2)\n\n[1] \"жира\"   \"верблю\"\n\n\nФункции ниже меняют начертание с прописного на строчное или наоборот:\n\nVEC &lt;- str_to_upper(vec)\nVEC\n\n[1] \"ЖИРАФ\"   \"ВЕРБЛЮД\"\n\nstr_to_lower(VEC)\n\n[1] \"жираф\"   \"верблюд\"\n\nstr_to_title(vec)\n\n[1] \"Жираф\"   \"Верблюд\"\n\n\nОдна из полезнейших функций в этом пакете – str_view(); она помогает увидеть, что поймало регулярное выражение – до того, как вы внесете какие-то изменения в строку.\n\nstr_view(c(\"abc\", \"a.c\", \"bef\"), \"a\\\\.c\")\n\n[2] │ &lt;a.c&gt;\n\n\nНапример, с помощью этой функции можно убедиться, что вертикальная черта выступает как логический оператор “или”:\n\nstr_view(c(\"grey\", \"gray\"), \"gr(e|a)y\")\n\n[1] │ &lt;grey&gt;\n[2] │ &lt;gray&gt;\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nСоздайте тиббл с двумя столбцами: letters и numbers (1:26). Преобразуйте, чтобы в третьем столбце появился результат соединения первых двух через подчеркивание, например a_1. Отфильтруйте, чтобы остались только ряды, где есть цифра 3 или буква x.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Регулярные выражения</span>"
    ]
  },
  {
    "objectID": "regex.html#str_detect-и-str_count",
    "href": "regex.html#str_detect-и-str_count",
    "title": "7  Регулярные выражения",
    "section": "7.9 str_detect() и str_count()",
    "text": "7.9 str_detect() и str_count()\nАналогом grepl() в stringr является функция str_detect()\n\nlibrary(rcorpora)\ndata(\"fruit\")\nhead(fruit)\n\n[1] \"apple\"       \"apricot\"     \"avocado\"     \"banana\"      \"bell pepper\"\n[6] \"bilberry\"   \n\nstr_detect(head(fruit), \"[aeiou]$\")\n\n[1]  TRUE FALSE  TRUE  TRUE FALSE FALSE\n\n# какая доля слов заканчивается на гласный?\nmean(str_detect(fruit, \"[aeiou]$\"))\n\n[1] 0.35\n\n# сколько всего слов заканчивается на гласный?\nsum(str_detect(fruit, \"[aeiou]$\"))\n\n[1] 28\n\n\nОтрицание можно задать двумя способами:\n\ndata(\"words\")\n\nno_vowels1 &lt;- !str_detect(words, \"[aeiou]\") # слова без гласных\n\nno_vowels2 &lt;- str_detect(words, \"^[^aeiou]+$\") # слова без гласных\n\nsum(no_vowels1 != no_vowels2)\n\n[1] 0\n\n\nЛогический вектор можно использовать для индексирования:\n\nwords[!str_detect(words, \"[aeiou]\")]\n\n[1] \"by\"  \"dry\" \"fly\" \"mrs\" \"try\" \"why\"\n\n\nЭту функцию можно применять вместе с функцией filter() из пакета dplyr:\n\nlibrary(dplyr)\ngods &lt;- corpora(which = \"mythology/greek_gods\")\n\ndf &lt;- tibble(god = as.character(gods$greek_gods), \n             i = seq_along(god)\n             )\n\ndf %&gt;% \n  filter(str_detect(god, \"s$\"))\n\n\n  \n\n\n\nВариацией этой функции является str_count():\n\nstr_count(as.character(gods$greek_gods), \"[Aa]\")\n\n [1] 1 1 1 1 2 0 0 1 1 1 0 1 0 0 1 2 1 0 0 0 0 1 2 1 0 2 3 2 1 0 0\n\n\nЭту функцию удобно использовать вместе с mutate() из dplyr:\n\ndf %&gt;% \n  mutate(\n    vowels = str_count(god, \"[AEIOYaeiou]\"),\n    consonants = str_count(god, \"[^AEIOYaeiou]\")\n  )\n\n\n  \n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nПреобразуйте sentences из пакета stringr в тиббл; в новом столбце сохраните количество пробелов в каждом предложении.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Регулярные выражения</span>"
    ]
  },
  {
    "objectID": "regex.html#str_extract-str_subset-и-str_match",
    "href": "regex.html#str_extract-str_subset-и-str_match",
    "title": "7  Регулярные выражения",
    "section": "7.10 str_extract(), str_subset() и str_match()",
    "text": "7.10 str_extract(), str_subset() и str_match()\nФункция str_extract() извлекает совпадения3.\nСначала зададим паттерн для поиска.\n\ncolours &lt;- c(\" red\", \"orange\", \"yellow\", \"green\", \"blue\", \"purple\")\ncolour_match &lt;- str_c(colours, collapse = \"|\")\ncolour_match\n\n[1] \" red|orange|yellow|green|blue|purple\"\n\n\nИ применим к предложениями. Используем str_extract_all(), т.к. str_extract() возвращает только первое вхождение.\n\nhas_colour &lt;- str_subset(sentences, colour_match)\nmatches &lt;- str_extract_all(has_colour, colour_match)\nhead(unlist(matches))\n\n[1] \"blue\"   \"blue\"   \"blue\"   \"yellow\" \"green\"  \" red\"  \n\n\nКруглые скобки используются для группировки. Например, мы можем задать шаблон для поиска существительного или прилагательного с артиклем.\n\nnoun &lt;- \"(a|the) ([^ ]+)\" # как минимум один непробельный символ после пробела\n\nhas_noun &lt;- sentences %&gt;%\n  str_subset(noun) %&gt;%\n  head(10)\nhas_noun\n\n [1] \"The birch canoe slid on the smooth planks.\"       \n [2] \"Glue the sheet to the dark blue background.\"      \n [3] \"It's easy to tell the depth of a well.\"           \n [4] \"These days a chicken leg is a rare dish.\"         \n [5] \"The box was thrown beside the parked truck.\"      \n [6] \"The boy was there when the sun rose.\"             \n [7] \"The source of the huge river is the clear spring.\"\n [8] \"Kick the ball straight and follow through.\"       \n [9] \"Help the woman get back to her feet.\"             \n[10] \"A pot of tea helps to pass the evening.\"          \n\n\nДальше можно воспользоваться уже известной функцией str_extract() или применить str_match. Результат будет немного отличаться: вторая функция вернет матрицу, в которой хранится не только сочетание слов, но и каждый компонент отдельно.\n\nhas_noun %&gt;% \n  str_extract(noun)\n\n [1] \"the smooth\" \"the sheet\"  \"the depth\"  \"a chicken\"  \"the parked\"\n [6] \"the sun\"    \"the huge\"   \"the ball\"   \"the woman\"  \"a helps\"   \n\nhas_noun %&gt;% \n  str_match(noun)\n\n      [,1]         [,2]  [,3]     \n [1,] \"the smooth\" \"the\" \"smooth\" \n [2,] \"the sheet\"  \"the\" \"sheet\"  \n [3,] \"the depth\"  \"the\" \"depth\"  \n [4,] \"a chicken\"  \"a\"   \"chicken\"\n [5,] \"the parked\" \"the\" \"parked\" \n [6,] \"the sun\"    \"the\" \"sun\"    \n [7,] \"the huge\"   \"the\" \"huge\"   \n [8,] \"the ball\"   \"the\" \"ball\"   \n [9,] \"the woman\"  \"the\" \"woman\"  \n[10,] \"a helps\"    \"a\"   \"helps\"  \n\n\nФункция tidyr::extract работает похожим образом, но требует дать имена для каждого элемента группы. Этим удобно пользоваться, если ваши данные хранятся в виде тиббла.\n\ntibble(sentence = sentences) %&gt;% \n  tidyr::extract(\n    sentence, c(\"article\", \"noun\"), \"(a|the) ([^ ]+)\", \n    remove = FALSE\n  )\n\n\n  \n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nНайдите в sentences все предложения, где есть to, и выберите следующее за этим слово. Переведите в нижний регистр. Узнайте, сколько всего уникальных сочетаний.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Регулярные выражения</span>"
    ]
  },
  {
    "objectID": "regex.html#str_replace",
    "href": "regex.html#str_replace",
    "title": "7  Регулярные выражения",
    "section": "7.11 str_replace",
    "text": "7.11 str_replace\nФункции str_replace() и str_replace_all() позволяют заменять совпадения на новые символы.\n\nx &lt;- c(\"apple\", \"pear\", \"banana\")\nstr_replace(x, \"[aeiou]\", \"-\")\n\n[1] \"-pple\"  \"p-ar\"   \"b-nana\"\n\nstr_replace_all(x, \"[aeiou]\", \"-\")\n\n[1] \"-ppl-\"  \"p--r\"   \"b-n-n-\"\n\n\nЭтим можно воспользоваться, если вы хотите, например, удалить из текста все греческие символы. Для стандартного греческого алфавита хватит [Α-Ωα-ω], но для древнегреческого этого, например, не хватит. Попробуем на отрывке из письма Цицерона Аттику, которое содержит греческий текст.\n\ncicero &lt;- \"nihil hāc sōlitūdine iūcundius, nisi paulum interpellāsset Amyntae fīlius. ὢ ἀπεραντολογίας ἀηδοῦς! \"\n\nstr_replace_all(cicero, \"[Α-Ωα-ω]\", \"\")\n\n[1] \"nihil hāc sōlitūdine iūcundius, nisi paulum interpellāsset Amyntae fīlius. ὢ ἀί ἀῦ! \"\n\n\nὢ ἀί ἀῦ! Не все у нас получилось гладко. Попробуем иначе:\n\nstr_replace_all(cicero, \"[\\u0370-\\u03FF]\", \"\")\n\n[1] \"nihil hāc sōlitūdine iūcundius, nisi paulum interpellāsset Amyntae fīlius. ὢ ἀ ἀῦ! \"\n\n\nУдалилась (буквально была заменена на пустое место) та диакритика, которая есть в новогреческом (ί). Но остались еще буквы со сложной диакритикой, которой современные греки не пользуются.\n\nno_greek &lt;- str_replace_all(cicero, \"[[\\u0370-\\u03FF][\\U1F00-\\U1FFF]]\", \"\")\nno_greek\n\n[1] \"nihil hāc sōlitūdine iūcundius, nisi paulum interpellāsset Amyntae fīlius.   ! \"\n\n\n! Мы молодцы. Избавились от этого непонятного греческого.\nНа самом деле, конечно, str_replace хорош тем, что он позволяет производить осмысленные замены. Например, мы можем в оставшемся латинском текст заменить гласные с макроном (черточка, означающая долготу) на обычные гласные.\n\nstr_replace_all(no_greek, c(\"ā\" = \"a\", \"ū\" = \"u\", \"ī\" = \"i\", \"ō\" = \"o\"))\n\n[1] \"nihil hac solitudine iucundius, nisi paulum interpellasset Amyntae filius.   ! \"\n\n\nКрасота. О более сложных заменах с перемещением групп можно посмотреть видео здесь и здесь. Это помогает даже в таком скорбном деле, как переоформление библиографии.\n\n\n\n\n\n\nЗадание\n\n\n\nДана библиографическая запись:\nAst, Friedrich. 1816. Platon’s Leben und Schriften. Leipzig, Weidmann.\nИспользуя регулярные выражения, замените полное имя на инициал. Запятую перед инициалом удалите. Уберите название издательства. Год поставьте в круглые скобки.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Регулярные выражения</span>"
    ]
  },
  {
    "objectID": "regex.html#str_split",
    "href": "regex.html#str_split",
    "title": "7  Регулярные выражения",
    "section": "7.12 str_split",
    "text": "7.12 str_split\nФункция str_split() помогает разбить текст на предложения, слова или просто на бессмысленные наборы символов. Это важный этап подготовки текста для анализа, и проводится он нередко именно с применением регулярных выражений.\n\nsentences %&gt;%\n  head(2) %&gt;% \n  str_split(\" \")\n\n[[1]]\n[1] \"The\"     \"birch\"   \"canoe\"   \"slid\"    \"on\"      \"the\"     \"smooth\" \n[8] \"planks.\"\n\n[[2]]\n[1] \"Glue\"        \"the\"         \"sheet\"       \"to\"          \"the\"        \n[6] \"dark\"        \"blue\"        \"background.\"\n\n\nНо можно обойтись и без регулярных выражений.\n\nx &lt;- \"This is a sentence.  This is another sentence.\"\nstr_view_all(x, boundary(\"word\"))\n\n[1] │ &lt;This&gt; &lt;is&gt; &lt;a&gt; &lt;sentence&gt;.  &lt;This&gt; &lt;is&gt; &lt;another&gt; &lt;sentence&gt;.\n\nstr_view_all(x, boundary(\"sentence\"))\n\n[1] │ &lt;This is a sentence.  &gt;&lt;This is another sentence.&gt;\n\n\nОчень удобно, но убедитесь, что в вашем языке границы слов и предложения выглядят как у людей. С древнегреческим эта штука не справится (как делить на предложения греческие и латинские тексты, я рассказывала здесь):\n\napology &lt;- c(\"νῦν δ' ἐπειδὴ ἀνθρώπω ἐστόν, τίνα αὐτοῖν ἐν νῷ ἔχεις ἐπιστάτην λαβεῖν; τίς τῆς τοιαύτης ἀρετῆς, τῆς ἀνθρωπίνης τε καὶ πολιτικῆς, ἐπιστήμων ἐστίν; οἶμαι γάρ σε ἐσκέφθαι διὰ τὴν τῶν ὑέων κτῆσιν. ἔστιν τις,” ἔφην ἐγώ, “ἢ οὔ;” “Πάνυ γε,” ἦ δ' ὅς. “Τίς,” ἦν δ' ἐγώ, “καὶ ποδαπός, καὶ πόσου διδάσκει;\")\n\nstr_view_all(apology, boundary(\"sentence\"))\n\n[1] │ &lt;νῦν δ' ἐπειδὴ ἀνθρώπω ἐστόν, τίνα αὐτοῖν ἐν νῷ ἔχεις ἐπιστάτην λαβεῖν; τίς τῆς τοιαύτης ἀρετῆς, τῆς ἀνθρωπίνης τε καὶ πολιτικῆς, ἐπιστήμων ἐστίν; οἶμαι γάρ σε ἐσκέφθαι διὰ τὴν τῶν ὑέων κτῆσιν. ἔστιν τις,” ἔφην ἐγώ, “ἢ οὔ;” “Πάνυ γε,” ἦ δ' ὅς. &gt;&lt;“Τίς,” ἦν δ' ἐγώ, “καὶ ποδαπός, καὶ πόσου διδάσκει;&gt;\n\n\nПолный крах 💩",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Регулярные выражения</span>"
    ]
  },
  {
    "objectID": "regex.html#footnotes",
    "href": "regex.html#footnotes",
    "title": "7  Регулярные выражения",
    "section": "",
    "text": "https://r4ds.had.co.nz/strings.html↩︎\nhttps://stringr.tidyverse.org/reference/str_sub.html↩︎\nhttps://r4ds.had.co.nz/strings.html#extract-matches↩︎",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Регулярные выражения</span>"
    ]
  },
  {
    "objectID": "scrape.html",
    "href": "scrape.html",
    "title": "8  Веб-скрапинг",
    "section": "",
    "text": "8.1 Структура html\nДокументы html (HyperText Markup Language) имеют ирархическую структуру, состоящую из элементов. В каждом элементе есть открывающий тег (&lt;tag&gt;), опциональные атрибуты (id='first') и закрывающий тег (&lt;/tag&gt;). Все, что находится между открывающим и закрывающим тегом, называется содержанием элемента.\nВажнейшие теги, о которых стоит знать:\nЧтобы увидеть структуру веб-страницы, надо нажать правую кнопку мыши и выбрать View Source (это работает и для тех html, которые хранятся у вас на компьютере).",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Веб-скрапинг</span>"
    ]
  },
  {
    "objectID": "scrape.html#структура-html",
    "href": "scrape.html#структура-html",
    "title": "8  Веб-скрапинг",
    "section": "",
    "text": "&lt;html&gt; (есть всегда), с двумя детьми (дочерними элементами): &lt;head&gt; и &lt;body&gt;\nэлементы, отвечающие за структуру: &lt;h1&gt; (заголовок), &lt;section&gt;, &lt;p&gt; (параграф), &lt;ol&gt; (упорядоченный список)\nэлементы, отвечающие за оформление: &lt;b&gt; (bold), &lt;i&gt; (italics), &lt;a&gt; (ссылка)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Веб-скрапинг</span>"
    ]
  },
  {
    "objectID": "scrape.html#каскадные-таблицы-стилей",
    "href": "scrape.html#каскадные-таблицы-стилей",
    "title": "8  Веб-скрапинг",
    "section": "8.2 Каскадные таблицы стилей",
    "text": "8.2 Каскадные таблицы стилей\nУ тегов могут быть именованные атрибуты; важнейшие из них – это id и class, которые в сочетании с CSS контролируют внешний вид страницы.\n\n\n\n\n\n\nНа заметку\n\n\n\nCSS (англ. Cascading Style Sheets «каскадные таблицы стилей») — формальный язык декорирования и описания внешнего вида документа (веб-страницы), написанного с использованием языка разметки (чаще всего HTML или XHTML).\n\n\nПример css-правила:\n.infobox {\n  padding: 1em 1em 1em 4em;\n  background: aliceblue 5px center/3em no-repeat;\n  color: black;\n}\nПроще говоря, это инструкция, что делать с тем или иным элементом. Каждое правило CSS имеет две основные части — селектор и блок объявлений. Селектор, расположенный в левой части правила до знака «{», определяет, на какие части документа (возможно, специально обозначенные) распространяется правило. Блок объявлений располагается в правой части правила. Он помещается в фигурные скобки, и, в свою очередь, состоит из одного или более объявлений, разделённых знаком «;».\nСелекторы CSS полезны для скрапинга, потому что они помогают вычленить необходимые элементы. Это работает так:\n\np выберет все элементы &lt;p&gt;\n.title выберет элементы с классом “title”\n#title выберет все элементы с атрибутом id=‘title’\n\nВажно: если изменится структура страницы, откуда вы скрапили информацию, то и код, возможно, придется переписывать.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Веб-скрапинг</span>"
    ]
  },
  {
    "objectID": "scrape.html#извлечение-данных",
    "href": "scrape.html#извлечение-данных",
    "title": "8  Веб-скрапинг",
    "section": "8.3 Извлечение данных",
    "text": "8.3 Извлечение данных\nЧтобы прочесть файл html, используем одноименную функцию.\n\nlibrary(rvest)\nmessages &lt;- read_html(\"../files/antibarbari.html\")\n\nmessages\n\n{html_document}\n&lt;html&gt;\n[1] &lt;head&gt;\\n&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8 ...\n[2] &lt;body onload=\"CheckLocation();\"&gt;\\n\\n  &lt;div class=\"page_wrap\"&gt;\\n\\n   &lt;div  ...\n\n\nНа следующем этапе важно понять, какие именно элементы нужны. Рассмотрим на примере одного сообщения. Для примера я сохраню этот элемент как небольшой отдельный html; rvest позволяет это сделать (но внутри двойных кавычек должны быть только одинарные):\n\nhtml &lt;-  minimal_html(\"\n&lt;div class='message default clearfix' id='message83'&gt;\n      &lt;div class='pull_left userpic_wrap'&gt;\n       &lt;div class='userpic userpic2' style='width: 42px; height: 42px'&gt;\n        &lt;div class='initials' style='line-height: 42px'&gt;\nA\n        &lt;/div&gt;\n       &lt;/div&gt;\n      &lt;/div&gt;\n      &lt;div class='body'&gt;\n       &lt;div class='pull_right date details' title='19.05.2022 11:18:07 UTC+03:00'&gt;\n11:18\n       &lt;/div&gt;\n       &lt;div class='from_name'&gt;\nAntibarbari HSE \n       &lt;/div&gt;\n       &lt;div class='text'&gt;\nЭтот пост открывает серию переложений из «Дайджеста платоновских идиом» Джеймса Ридделла (1823–1866), английского филолога-классика, чей научный путь был связан с Оксфордским университетом. По приглашению Бенджамина Джоветта он должен был подготовить к изданию «Апологию», «Критон», «Федон» и «Пир». Однако из этих четырех текстов вышла лишь «Апология» с предисловием и приложением в виде «Дайджеста» (ссылка) — уже после смерти автора. &lt;br&gt;&lt;br&gt;«Дайджест» содержит 326 параграфов, посвященных грамматическим, синтаксическим и риторическим особенностям языка Платона. Знакомство с этим теоретическим материалом позволяет лучше почувствовать уникальный стиль философа и добиться большей точности при переводе. Ссылки на «Дайджест» могут быть уместны и в учебных комментариях к диалогам Платона. Предлагаемая здесь первая часть «Дайджеста» содержит «идиомы имен» и «идиомы артикля» (§§ 1–39).&lt;br&gt;&lt;a href='http://antibarbari.ru/2022/05/19/digest_1/'&gt;http://antibarbari.ru/2022/05/19/digest_1/&lt;/a&gt;\n       &lt;/div&gt;\n       &lt;div class='signature details'&gt;\nOlga Alieva\n       &lt;/div&gt;\n      &lt;/div&gt;\n     &lt;/div&gt;\n\")\n\nИз всего этого мне может быть интересно id сообщения (&lt;div class=‘message default clearfix’ id=‘message83’&gt;), текст сообщения (&lt;div class=‘text’&gt;), а также, если указан, автор сообщения (&lt;div class=‘signature details’&gt;). Извлекаем текст (для этого рекомендуется использовать функцию html_text2()):\n\nhtml %&gt;%\n  html_element(\".text\") %&gt;% \n  html_text2()\n\n[1] \"Этот пост открывает серию переложений из «Дайджеста платоновских идиом» Джеймса Ридделла (1823–1866), английского филолога-классика, чей научный путь был связан с Оксфордским университетом. По приглашению Бенджамина Джоветта он должен был подготовить к изданию «Апологию», «Критон», «Федон» и «Пир». Однако из этих четырех текстов вышла лишь «Апология» с предисловием и приложением в виде «Дайджеста» (ссылка) — уже после смерти автора.\\n\\n«Дайджест» содержит 326 параграфов, посвященных грамматическим, синтаксическим и риторическим особенностям языка Платона. Знакомство с этим теоретическим материалом позволяет лучше почувствовать уникальный стиль философа и добиться большей точности при переводе. Ссылки на «Дайджест» могут быть уместны и в учебных комментариях к диалогам Платона. Предлагаемая здесь первая часть «Дайджеста» содержит «идиомы имен» и «идиомы артикля» (§§ 1–39).\\nhttp://antibarbari.ru/2022/05/19/digest_1/\"\n\n\nВ классе signature details есть пробел, достаточно на его месте поставить точку:\n\nhtml %&gt;%\n  html_element(\".signature.details\") %&gt;% \n  html_text2()\n\n[1] \"Olga Alieva\"\n\n\nВажно помнить, что html_element всегда возвращает один элемент. Если их больше, надо использовать html_elements.\nОсталось добыть message id:\n\nhtml %&gt;%\n  html_element(\"div\") %&gt;% \n  html_attr(\"id\")\n\n[1] \"message83\"",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Веб-скрапинг</span>"
    ]
  },
  {
    "objectID": "scrape.html#извлечение-в-тиббл",
    "href": "scrape.html#извлечение-в-тиббл",
    "title": "8  Веб-скрапинг",
    "section": "8.4 Извлечение в тиббл",
    "text": "8.4 Извлечение в тиббл\n\nlibrary(tidyverse)\n\ntibble(id = html %&gt;% \n         html_element(\"div\") %&gt;% \n         html_attr(\"id\"),\n       signature = html %&gt;%\n         html_element(\".signature.details\") %&gt;% \n         html_text2(),\n       text = html %&gt;% \n         html_element(\".text\") %&gt;%\n         html_text2()\n)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Веб-скрапинг</span>"
    ]
  },
  {
    "objectID": "scrape.html#скрапим-телеграм-канал",
    "href": "scrape.html#скрапим-телеграм-канал",
    "title": "8  Веб-скрапинг",
    "section": "8.5 Скрапим телеграм-канал",
    "text": "8.5 Скрапим телеграм-канал\nДо сих пор наша задача упрощалась тем, что мы имели дело с игрушечным html для единственного сообщения. В настоящем html тег div повторяется на разных уровнях, нам надо извлечь только такие div, которым соответствует определенный класс:\n\nmessages %&gt;%\n  html_elements(\"div.message.default\") %&gt;% \n  head()\n\n{xml_nodeset (6)}\n[1] &lt;div class=\"message default clearfix\" id=\"message3\"&gt;\\n\\n      &lt;div class= ...\n[2] &lt;div class=\"message default clearfix\" id=\"message5\"&gt;\\n\\n      &lt;div class= ...\n[3] &lt;div class=\"message default clearfix\" id=\"message6\"&gt;\\n\\n      &lt;div class= ...\n[4] &lt;div class=\"message default clearfix\" id=\"message7\"&gt;\\n\\n      &lt;div class= ...\n[5] &lt;div class=\"message default clearfix\" id=\"message8\"&gt;\\n\\n      &lt;div class= ...\n[6] &lt;div class=\"message default clearfix\" id=\"message9\"&gt;\\n\\n      &lt;div class= ...\n\n\nУже из этого списка можем доставать все остальное.\n\nmessages_tbl &lt;- tibble(id = messages %&gt;% \n         html_elements(\"div.message.default\") %&gt;% \n         html_attr(\"id\"),\n       signature = messages %&gt;%\n         html_elements(\"div.message.default\") %&gt;% \n         html_element(\".signature.details\") %&gt;% \n         html_text2(),\n       text = messages %&gt;% \n         html_elements(\"div.message.default\") %&gt;% \n         html_element(\".text\") %&gt;%\n         html_text2()\n)\n\nОбратите внимание, что мы сначала извлекаем нужные элементы при помощи html_elements(), а потом применяем к каждому из них html_element(). Это гарантирует, что в каждом столбце нашей таблицы равное число наблюдений, т.к. функция html_element(), если она не может найти, например, подпись, возвращает NA.\nСоздатели канала не сразу разрешили подписывать посты, поэтому для первых нескольких десятков подписи не будет. В некоторых постах только фото, для них в столбце text – NA, их можно сразу отсеять.\n\nmessages_tbl &lt;- messages_tbl %&gt;%\n  filter(!is.na(text))\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nИзвлеките из архива антиварваров дату публикации для каждого поста.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Веб-скрапинг</span>"
    ]
  },
  {
    "objectID": "scrape.html#эмотиконы",
    "href": "scrape.html#эмотиконы",
    "title": "8  Веб-скрапинг",
    "section": "8.6 Эмотиконы",
    "text": "8.6 Эмотиконы\nВ постах довольно много эмотиконов. Я их удалю, но сначала скажу о полезном пакете, который позволяет их все извлечь и, например, посчитать.\n\nlibrary(emoji)\n\nmessages_tbl %&gt;% \n  mutate(emoji = emoji_extract_all(text)) %&gt;% \n  pull(emoji) %&gt;% \n  unlist() %&gt;% \n  as_tibble() %&gt;%\n  count(value) %&gt;% \n  arrange(-n) \n\n\n  \n\n\n\nЗаменяем их все на пробелы.\n\nmessages_tbl &lt;- messages_tbl %&gt;% \n  mutate(text = emoji_replace_all(text, \" \"))",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Веб-скрапинг</span>"
    ]
  },
  {
    "objectID": "scrape.html#рутинная-уборка",
    "href": "scrape.html#рутинная-уборка",
    "title": "8  Веб-скрапинг",
    "section": "8.7 Рутинная уборка",
    "text": "8.7 Рутинная уборка\nПодготовка текста для анализа включает в себя удаление сносок, иногда хэштегов, чисел, имейлов, возможно имен и т.п. В нашем случае ситуация осложняется тем, что тексты включают цитаты на латыни и древнегреческом, некоторые технические сокращения, номера страниц и др. Вот так, например, выглядит типичный пост:\n\nexample &lt;- messages_tbl$text[340]\n\nexample\n\n[1] \"🎞 Теэтет #10 149b7-150b8\\nСократ продолжает засыпать семнадцатилетнего математика подробностями из области акушерства и гинекологии, и мы вместе с ним терпеливо изучаем, чем сводничество отличается от сватовства. Верните квадратные корни. #платон #теэтет\\nhttps://vk.com/video-211800158_456239238\"\n\n\nВот так вылавливается гиперссылка.\n\nstr_extract_all(example, \"(http|https)(\\\\S+)\")\n\n[[1]]\n[1] \"https://vk.com/video-211800158_456239238\"\n\n\nВот так вылавливается пагинация и номер семинара (и некоторые другие числа).\n\nstr_extract_all(example, \"#?\\\\d{2,3}\\\\w?\\\\d?-?\")\n\n[[1]]\n[1] \"#10\"    \"149b7-\" \"150b8\"  \"21180\"  \"0158\"   \"45623\"  \"9238\"  \n\n\nПохожим образом можно выловить даты, имейлы и т.п. Все это удаляем из текста.\n\nmessages_clean &lt;- messages_tbl %&gt;% \n  mutate(text = str_replace_all(text, \"(http|https)(\\\\S+)\", \" \")) %&gt;% \n  mutate(text = str_replace_all(text, \"\\\\d{2}\\\\.\\\\d{2}\\\\.\\\\d{4}\", \" \")) %&gt;% \n  mutate(text = str_replace_all(text, \"\\\\W[-A-Za-z0-9_.%]+\\\\@[-A-Za-z0-9_.%]+\\\\.[A-Za-z]\", \" \")) %&gt;% \n  mutate(text = str_replace_all(text, \"#?\\\\d{2,3}\\\\w?\\\\d?-?\", \" \")) %&gt;% \n  mutate(text = str_replace_all(text, \"\\\\n+\", \" \"))\n\nОстались еще сокращения вроде “г.”, но токены из одной буквы можно будет удалить после разделения на слова. Знаки пунктуации можно оставить или убрать – иногда они бывают интересным стилистическим маркером. В любом случае лучше это делать после лемматизации, т.к. на тексте без знаков препинания анализатор покажет себя хуже.\n\nmessages_clean %&gt;% \n  filter(row_number() == 340)\n\n\n  \n\n\n\nЧисло id и число текстов не совпадает, поскольку для некоторых постов текста нет (NA), а у других он совпадает (“Пост выходного дня”). Это надо сразу исправить, чтобы результат лемматизации можно было потом соединить с данными о подписи. Я просто уберу очень короткие посты, поскольку для анализа они неинтересны.\n\nmessages_clean &lt;- messages_clean %&gt;%\n  filter(nchar(text) &gt; 19)\n\n\ndim(messages_clean)\n\n[1] 689   3\n\n\nПереименуем первый столбец и переназначим id, чтобы можно было потом соединить с результатами лемматизации.\n\nmessages_clean &lt;- messages_clean %&gt;% \n  rename(doc_id = id) %&gt;% \n  mutate(doc_id = paste0(\"doc\", row_number()))",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Веб-скрапинг</span>"
    ]
  },
  {
    "objectID": "scrape.html#html-таблицы",
    "href": "scrape.html#html-таблицы",
    "title": "8  Веб-скрапинг",
    "section": "8.8 Html таблицы",
    "text": "8.8 Html таблицы\nЕсли вам повезет, то ваши данные уже будут храниться в HTML-таблице, и их можно будет просто считать из этой таблицы1. Распознать таблицу в браузере обычно несложно: она имеет прямоугольную структуру из строк и столбцов, и ее можно скопировать и вставить в такой инструмент, как Excel.\nТаблицы HTML строятся из четырех основных элементов: &lt;table&gt;, &lt;tr&gt; (строка таблицы), &lt;th&gt; (заголовок таблицы) и &lt;td&gt; (данные таблицы). Мы соберем информацию о проектных группах ФГН в 2022-2024 г.\n\nhtml &lt;- read_html(\"https://hum.hse.ru/proj/project2022_2024\")\nmy_table &lt;- html %&gt;%  \n  html_element(\".bordered\") %&gt;% \n  html_table()\n\nDT::datatable(my_table)\n\n\n\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nС сайта Новой философской энциклопедии извлеките список слов на букву П. Используйте map_df() для объединения таблиц.\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nСколько всего слов на букву П в НФЭ?",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Веб-скрапинг</span>"
    ]
  },
  {
    "objectID": "scrape.html#wikisource",
    "href": "scrape.html#wikisource",
    "title": "8  Веб-скрапинг",
    "section": "8.9 Wikisource",
    "text": "8.9 Wikisource\nМногие тексты доступны на сайте Wikisource.org. Попробуем извлечь все сказки Салтыкова-Щедрина.\n\nurl &lt;- \"https://ru.wikisource.org/wiki/%D0%9C%D0%B8%D1%85%D0%B0%D0%B8%D0%BB_%D0%95%D0%B2%D0%B3%D1%80%D0%B0%D1%84%D0%BE%D0%B2%D0%B8%D1%87_%D0%A1%D0%B0%D0%BB%D1%82%D1%8B%D0%BA%D0%BE%D0%B2-%D0%A9%D0%B5%D0%B4%D1%80%D0%B8%D0%BD\"\nhtml = read_html(url)\n\nДля того, чтобы справиться с такой страницей, пригодится Selector Gadget (расширение для Chrome). Вот тут можно посмотреть короткое видео, как его установить. При помощи селектора выбираем нужные уровни.\n\ntoc &lt;- html %&gt;% \n  html_elements(\"ul:nth-child(22) a\")\n\nhead(toc)\n\n{xml_nodeset (6)}\n[1] &lt;a href=\"/wiki/%D0%9F%D0%BE%D0%B2%D0%B5%D1%81%D1%82%D1%8C_%D0%BE_%D1%82%D ...\n[2] &lt;a href=\"/wiki/%D0%93%D0%BE%D0%B4%D0%BE%D0%B2%D1%89%D0%B8%D0%BD%D0%B0_(%D ...\n[3] &lt;a href=\"/wiki/%D0%9F%D1%80%D0%BE%D0%BF%D0%B0%D0%BB%D0%B0_%D1%81%D0%BE%D0 ...\n[4] &lt;a href=\"/wiki/%D0%94%D0%B8%D0%BA%D0%B8%D0%B9_%D0%BF%D0%BE%D0%BC%D0%B5%D1 ...\n[5] &lt;a href=\"/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D1%83%D0%B4%D1%80%D1%8B%D0%B9_%D0 ...\n[6] &lt;a href=\"/wiki/%D0%A1%D0%B0%D0%BC%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1%80%D0% ...\n\n\nТеперь у нас есть список ссылок.\n\ntales &lt;- tibble(\n  title = toc %&gt;%\n    html_attr(\"title\"),\n  href = toc %&gt;% \n    html_attr(\"href\")\n)\n\nДанных о годе публикации под тегом  нет; надо подняться на уровень выше:\n\ntoc2 &lt;- html %&gt;% \n  html_elements(\"ul:nth-child(22) li\")\n\nhead(toc2)\n\n{xml_nodeset (6)}\n[1] &lt;li&gt;\\n&lt;a href=\"/wiki/%D0%9F%D0%BE%D0%B2%D0%B5%D1%81%D1%82%D1%8C_%D0%BE_%D ...\n[2] &lt;li&gt;\\n&lt;a href=\"/wiki/%D0%93%D0%BE%D0%B4%D0%BE%D0%B2%D1%89%D0%B8%D0%BD%D0% ...\n[3] &lt;li&gt;\\n&lt;a href=\"/wiki/%D0%9F%D1%80%D0%BE%D0%BF%D0%B0%D0%BB%D0%B0_%D1%81%D0 ...\n[4] &lt;li&gt;\\n&lt;a href=\"/wiki/%D0%94%D0%B8%D0%BA%D0%B8%D0%B9_%D0%BF%D0%BE%D0%BC%D0 ...\n[5] &lt;li&gt;\\n&lt;a href=\"/wiki/%D0%9F%D1%80%D0%B5%D0%BC%D1%83%D0%B4%D1%80%D1%8B%D0% ...\n[6] &lt;li&gt;\\n&lt;a href=\"/wiki/%D0%A1%D0%B0%D0%BC%D0%BE%D0%BE%D1%82%D0%B2%D0%B5%D1% ...\n\n\n\ntoc2 %&gt;%\n  html_text2()\n\n [1] \"Повесть о том, как один мужик двух генералов прокормил, 1869\"\n [2] \"Годовщина, 1869\"                                             \n [3] \"Пропала совесть, 1869\"                                       \n [4] \"Дикий помещик, 1869\"                                         \n [5] \"Премудрый пискарь, 1883\"                                     \n [6] \"Самоотверженный заяц, 1883\"                                  \n [7] \"Бедный волк, 1883\"                                           \n [8] \"Добродетели и Пороки, 1884\"                                  \n [9] \"Медведь на воеводстве, 1884\"                                 \n[10] \"Обманщик-газетчик и легковерный читатель, 1884\"              \n[11] \"Вяленая вобла, 1884\"                                         \n[12] \"Орёл-меценат, 1884\"                                          \n[13] \"Карась-идеалист, 1884\"                                       \n[14] \"Игрушечного дела людишки, 1879, 1886\"                        \n[15] \"Чижиково горе, 1884\"                                         \n[16] \"Верный Трезор, 1885\"                                         \n[17] \"Недреманное око, конец 1885 или начало 1886\"                 \n[18] \"Дурак, 1885\"                                                 \n[19] \"Соседи, 1885\"                                                \n[20] \"Здравомысленный заяц, 1885\"                                  \n[21] \"Либерал, 1885\"                                               \n[22] \"Баран-непомнящий, 1885\"                                      \n[23] \"Коняга, 1855\"                                                \n[24] \"Кисель, 1855\"                                                \n[25] \"Праздный разговор, 1886\"                                     \n[26] \"Деревенский пожар, 1885\"                                     \n[27] \"Путём-дорогою, 1886\"                                         \n[28] \"Богатырь, 1886\"                                              \n[29] \"Гиена, 1886\"                                                 \n[30] \"Приключение с Крамольниковым, 1886\"                          \n[31] \"Христова ночь, 1886\"                                         \n[32] \"Ворон-челобитчик, 1886\"                                      \n[33] \"Рождественская сказка, 1886\"                                 \n\n\nСоединяем:\n\ntales &lt;- tibble(\n  title_year = toc2 %&gt;%\n    html_text2(),\n  href = toc %&gt;% \n    html_attr(\"href\")\n)\n\ntales\n\n\n  \n\n\n\nДальше можно достать текст для каждой сказки. Потренируемся на одной. Снова привлекаем Selector Gadget для составления правила.\n\nurl_test &lt;- tales %&gt;% \n  filter(row_number() == 1) %&gt;% \n  pull(href) %&gt;% \n  paste0(\"https://ru.wikisource.org\", .)\n\ntext &lt;- read_html(url_test) %&gt;% \n  html_elements(\".indent p\") %&gt;% \n  html_text2() \n\ntext[1]\n\n[1] \"Жили да были два генерала, и так как оба были легкомысленны, то в скором времени, по щучьему велению, по моему хотению, очутились на необитаемом острове.\"\n\ntext[length(text)]\n\n[1] \"Однако, и об мужике не забыли; выслали ему рюмку водки да пятак серебра: веселись, мужичина!\"\n\n\nПервый и последний параграф достали верно; можно обобщать.\n\ntales &lt;- tales %&gt;% \n    mutate(href = paste0(\"https://ru.wikisource.org\", href))\n\n\nurls &lt;- tales %&gt;% \n  pull(href)\n\nФункция для извлечения текстов.\n\nget_text &lt;- function(url) {\n  read_html(url) %&gt;% \n  html_elements(\".indent p\") %&gt;% \n  html_text2() %&gt;% \n  paste(collapse= \" \")\n}\n\n\ntales_text &lt;- map(urls, get_text)\n\nНесколько сказок не выловились: там другая структура html, но в целом все получилось.\n\ntales_text &lt;- tales_text %&gt;%\n  flatten_chr() %&gt;% \n  as_tibble()\n\ntales &lt;- tales %&gt;% \n  bind_cols(tales_text)\n\n\ntales\n\n\n  \n\n\n\nДальше можно разделить столбец с названием и годом и, например, удалить ссылку, она больше не нужна. Разделить по запятой не получится, т.к. она есть в некоторых названиях.\n\ntales &lt;- tales %&gt;% \n  select(-href) %&gt;% \n  separate(title_year, into = c(\"title\", \"year\"), sep = -5) %&gt;% \n  mutate(title = str_remove(title, \",$\"))\n\n\ntales\n\n\n  \n\n\n\nНедостающие две сказки я не буду пытаться извлечь, но логику вы поняли.",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Веб-скрапинг</span>"
    ]
  },
  {
    "objectID": "scrape.html#footnotes",
    "href": "scrape.html#footnotes",
    "title": "8  Веб-скрапинг",
    "section": "",
    "text": "https://r4ds.hadley.nz/webscraping#tables↩︎",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Веб-скрапинг</span>"
    ]
  },
  {
    "objectID": "start.html#векторы-и-матрицы",
    "href": "start.html#векторы-и-матрицы",
    "title": "1  Начало работы",
    "section": "1.6 Векторы и матрицы",
    "text": "1.6 Векторы и матрицы\nВектор – это объект, предназначенный для хранения данных. К таким же объектам относятся также матрицы, списки, таблицы данных и др. Заметим, что в языке R нет скаляров (отдельных чисел). Числа считаются векторами из одного элемента.\n\nx &lt;- 2\nclass(x) # числовой вектор\n\n[1] \"numeric\"\n\nlength(x) # длина вектора\n\n[1] 1\n\n\nКак вы уже поняли, функция c() позволяет собрать несколько элементов в единый вектор:\n\nx &lt;- c(3, 5, 7)\nx_mean &lt;- mean(x) \nx_mean\n\n[1] 5\n\n\n Над векторами можно совершать арифметические операции, но будьте внимательны, применяя операции к векторам разной длины: в этом случае более короткий вектор будет переработан, то есть повторен до тех пор, пока его длина не сравняется с длиной вектора большей длины.\n\nx &lt;- 2\ny &lt;- c(10, 20, 30)\ny / x \n\n[1]  5 10 15\n\nx + y \n\n[1] 12 22 32\n\n\nВекторы можно индексировать, то есть забирать из них какие-то элементы:\n\nx &lt;- seq(1, 5, 0.5)\nx[4:5] # индексы начинаются с 1 (в отличие от Python)\n\n[1] 2.5 3.0\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nЗапустите swirl() и пройдите урок 6 Subsetting Vectors.\n\n\nПроверьте, все ли вы поняли из этого урока.\n\n\n\n\n\n\nВопрос\n\n\n\nЕсли вектор x содержит числовые значения и некоторое количество NA, то что вернет команда x[is.na(x)]?\n\n\n\n\nвектор длиной 0\n\n\nвектор всех NA\n\n\nлогический вектор\n\n\nвектор без NA\n\n\nошибку\n\n\n\n\n\nЧто надо изменить в этом коде, чтобы получить все, кроме NA?\nМатрица – это вектор, который имеет два дополнительных атрибута: количество строк и количество столбцов. Из этого следует, что матрица, как и вектор, может хранить данные одного типа. Проверим.\n\nM = matrix(c(1, 2, 3, 4), nrow = 2)\nM # все ок\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\nM = matrix(c(1, 2, 3, \"a\"), nrow = 2)\nM # все превратилось в строку! \n\n     [,1] [,2]\n[1,] \"1\"  \"3\" \n[2,] \"2\"  \"a\" \n\n\nВ матрице есть ряды и столбцы. Их количество определяет размер (порядок) матрицы. Выше мы создали матрицу 2 x 2. Элементы матрицы, как и элементы вектора, можно извлекать по индексу. Сначала указывается номер ряда (строки), потом номер столбца.\n\nM = matrix(c(1, 2, 3, 4), nrow = 2)\nM\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n\n\nM[1, ] # первая строка полностью\n\n[1] 1 3\n\nM[,2] # второй столбец полностью\n\n[1] 3 4\n\nM[1,1] # одно значение\n\n[1] 1\n\n\nОбратите внимание, как меняется размерность при индексировании.\n\nM = matrix(c(1, 2, 3, 4), nrow = 2)\ndim(M) # функция для извлечения измерений\n\n[1] 2 2\n\ndim(M[1, ]) \n\nNULL\n\n\nПопытка узнать измерения вектора возвращает NULL, потому что, с точки зрения R, векторы не являются матрицами из одного столбца или одной строки и потому не имеют измерений.\nИ векторы, и матрицы могут хранить данные одного типа – в отличие от списков и датафреймов. Поэтому, прежде чем к ним перейти, следует сказать о типах данных в R.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#списки-и-таблицы",
    "href": "start.html#списки-и-таблицы",
    "title": "1  Начало работы",
    "section": "1.10 Списки и таблицы",
    "text": "1.10 Списки и таблицы\nКак уже было сказано, списки, или рекурсивные векторы (в отличие от атомарных векторов), могут хранить данные разных типов.\n\nlist = list(a = c(\"a\", \"b\", \"c\"), b = c(1, 2, 3), c = c(T, F, T))\nlist\n\n$a\n[1] \"a\" \"b\" \"c\"\n\n$b\n[1] 1 2 3\n\n$c\n[1]  TRUE FALSE  TRUE\n\n\nМожно получить доступ как к элементам списка целиком, так и к их содержимому.\n\nlist$a # обращение к поименованным элементам \n\n[1] \"a\" \"b\" \"c\"\n\nlist[2] # одинарные квадратные скобки извлекают элемент списка целиком\n\n$b\n[1] 1 2 3\n\nclass(list[2])\n\n[1] \"list\"\n\nlist[[2]] #  элементы второго элемента \n\n[1] 1 2 3\n\nclass(list[[2]])\n\n[1] \"numeric\"\n\nlist$c[1]# первый элемент второго элемента\n\n[1] TRUE\n\n\nОбратите внимание, что list[2] и list[[2]] возвращают объекты разных классов. Нам это еще понадобится при работе с XML.\n\n\n\nИндексирование списка в R. Источник 🧂\n\n\n\n\n\n\n\n\n\nЗадание\n\n\n\nУстановите библиотеку rcorpora и загрузите список с названиями хлеба и сладкой выпечки.\nlibrary(rcorpora)\nmy_list &lt;-  corpora(\"foods/breads_and_pastries\")\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nУзнайте длину my_list и введите ее в поле ниже.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nДостаньте из my_list элемент pastries и узнайте его длину.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nА теперь извлеките пятый элемент из pastries и введите ниже его название.\n\n\n\n\n\n\n\n\nСо списками покончено. Теперь можно пойти выпить кофе с my_list$pastries[13].\n\n\n\n\nBurns, Patrick. 2012. The R inferno. Lulu.com.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  },
  {
    "objectID": "start.html#пакеты",
    "href": "start.html#пакеты",
    "title": "1  Начало работы",
    "section": "1.3 Пакеты",
    "text": "1.3 Пакеты\nПосле установки R вы получите доступ к уже готовым методам статистического анализа и инструментам для визуализации. Если в базовой инсталляции R нет нужного решения – надо поискать в библиотеке пакетов. Пакет – это набор функций и иногда датасетов, созданный пользователями. На 1 июля 2023 г. в репозитории CRAN доступно 19789 пакетов. И это далеко не все: многие пакеты доступны только на GitHub.\n\n\n\n\n\n\nНа заметку\n\n\n\nНекоторые функции, которые вы найдете в пакетах, частично дублируют друг друга – это нормально, как и в естественном языке, “сказать” что-то можно разными способами.\n\n\nПо технической документации и так называемым “виньеткам” можно понять, какой пакет вам нужен. Например, вот так выглядит виньетка пакета RPerseus, при помощи которого можно получить доступ к корпусу греческой и латинской литературы.\nБывают еще “пакеты пакетов”, то есть очень большие семейства функций, своего рода “диалекты” R. Таково семейство tidyverse, объединяемое идеологией “опрятных” данных. Про него мы еще будем говорить.\nПакеты для работы устанавливаются один раз, однако подключать их надо во время каждой сессии. Чтобы установить новый пакет, можно воспользоваться меню Tools &gt; Install Packages. Также можно устанавливать пакеты из консоли. Установим пакет с интерактивными уроками программирования на языке R:\n\ninstall.packages(\"swirl\")\n\nДля подключения используем функцию library(), которой передаем в качестве аргумента название пакета без кавычек:\n\nlibrary(swirl)\n\nА теперь – первое задание.\n\n\n\n\n\n\nЗадание\n\n\n\nУстановите курс программирования на R: install_course(\"R Programming\"). После этого привяжите пакет командой library(swirl) и наберите: swirl(). Укажите ваше имя. Пройдите урок 2 Workspace and Files.\n\n\n После выполнения ответьте на несколько вопросов на закрепление материала.\n\n\n\n\n\n\nВопрос\n\n\n\nКакие действия в рабочей директории можно совершать из консоли?\n\n\n\n\nсоздать директорию\n\n\nудалить директорию\n\n\nсоздать файл\n\n\nпереименовать файл\n\n\nкопировать файл\n\n\nудалить файл\n\n\n\n\n\n\n\n\n\n\n\nВопрос\n\n\n\nЧтобы создать вложенную директорию при помощи функции dir.create(), аргументу recursive следует задать значение…\n\n\n\n\nTRUE\nFALSE\n\n\n\n\n\nЕсли все получилось, двигаемся дальше.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Начало работы</span>"
    ]
  }
]